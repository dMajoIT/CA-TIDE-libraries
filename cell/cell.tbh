'***********************************************************************************************************
'			CELLULAR LIBRARY
'***********************************************************************************************************
#ifndef CELL__DEBUG_PRINT
	#define CELL__DEBUG_PRINT 0
#endif

#ifndef CELLULAR_AVAILABLE
	#define CELLULAR_AVAILABLE 1	
#endif

#ifndef CELL__PING_IP
	#define CELL__PING_IP "8.8.8.8"
#endif

#ifndef CELL_BANDTYPE
	#define CELL_BANDTYPE "3"	'<----- CHANGE THIS AS NEEDED (1: CAT-M, 2: NB-Iot, 3: CAT-M and NB-IoT)
#endif

'XXXXXXXXXXXXXXXXXXX USING IO EXTENDER FOR CELL
#ifndef CELL_IO_EXTENDER
	#define CELL_IO_EXTENDER 0 '<-------------------- Not using IO extender
#endif

'CELL MODES----------------------------------------------------------
'PPP
#ifndef CELL__PPP_MODE_ISENABLED
	#define CELL__PPP_MODE_ISENABLED 1
#endif

#if CELL__PPP_MODE_ISENABLED = 0
	'COMMAND
	#ifndef CELL__AT_USERMODE_ISENABLED
		#define CELL__AT_USERMODE_ISENABLED 1
	#endif
	
	#if CELL__AT_USERMODE_ISENABLED = 0
		'GPS
		#ifndef CELL__GPS_MODE_ISENABLED
			#define CELL__GPS_MODE_ISENABLED 1
		#endif
	#endif
#endif

'AUTO-POLARITY-ADJUST
#ifndef CELL__AUTO_POLARITY_ADJUST_ISENABLED
	#define CELL__AUTO_POLARITY_ADJUST_ISENABLED 1
#endif


'UDP DEBUGPRINT---------------------------------------------------
'1: Enable print in debugmode
'0: Disable print in debugmode
#ifndef CELL__DEBUGPRINT_UDP_ISENABLED
	#define CELL__DEBUGPRINT_UDP_ISENABLED 0
#endif

'SERIAL DEBUGPRINT---------------------------------------------------
'1: Enable print in debugmode
'0: Disable print in debugmode
#ifndef CELL__DEBUGPRINT_SERPORT_ISENABLED
	#define CELL__DEBUGPRINT_SERPORT_ISENABLED 0
#endif

'POWER DEBUGPRINT----------------------------------------------------
#ifndef CELL__DEBUGPRINT_PWR_ISENABLED
	#define CELL__DEBUGPRINT_PWR_ISENABLED 1
#endif

'AT DEBUGPRINT-------------------------------------------------------
#ifndef CELL__DEBUGPRINT_AT_ISENABLED
	#define CELL__DEBUGPRINT_AT_ISENABLED 1
#endif

'PPP DEBUGPRINT------------------------------------------------------
#if CELL__PPP_MODE_ISENABLED
	#ifndef CELL__DEBUGPRINT_PPP_ISENABLED
		#define CELL__DEBUGPRINT_PPP_ISENABLED 1
	#endif
#endif

'GPS DEBUGPRINT------------------------------------------------------
#if CELL__GPS_MODE_ISENABLED
	#ifndef CELL__DEBUGPRINT_GPS_ISENABLED
		#define CELL__DEBUGPRINT_GPS_ISENABLED 1
	#endif
#endif


'AT FAST LOAD--------------------------------------------------------
'1: Enable
'0: Disable
'REMARK: for NB-IOT, this option should be ENABLED. Otherwise the PPP-connection may fail.
#ifndef CELL__AT_FAST_LOAD_ISENABLED
	#define CELL__AT_FAST_LOAD_ISENABLED 1
#endif

'PPP FAST LOAD-------------------------------------------------------
'1: Enable
'0: Disable
'REMARK: for NB-IOT, this option should be ENABLED. Otherwise the PPP-connection may fail.
#ifndef CELL__PPP_FAST_LOAD_ISENABLED
	#define CELL__PPP_FAST_LOAD_ISENABLED 1
#endif


'LINE DEFINITION-----------------------------------------------------
#ifndef CELL__ON	 'Active state
	#define CELL__ON HIGH
#endif
#ifndef CELL__OFF	'Inactive state
	#define CELL__OFF (CELL__ON - 1)
#endif



'PAYLOAD SIZE--------------------------------------------------------
'UDP and TCP Payload Size expressed in 256-byte per page.
'REMARK: do not set the payload size >4 or <1.
#ifndef CELL__PAYLOAD_SIZE
	#define CELL__PAYLOAD_SIZE 4
#endif



'PORT ASSIGNMENTS----------------------------------------------------
'SERIAL PORTS
'interchardelay
#ifndef CELL__INTERCHAR_DELAY_VAL
	#define CELL__INTERCHAR_DELAY_VAL 10
#endif

'Assign Serial-ports
#ifndef CELL__DEBUGPRINT_SER_PORT
	#define CELL__DEBUGPRINT_SER_PORT 0	'serial-port used for debugprint
#endif

#ifndef CELL__DATA_SER_PORT
	#define CELL__DATA_SER_PORT 2	'serial-port used for tx/rx
#endif

'RTS (Request To Send) serial Port Selection
#ifndef CELL__RTS_LINENUM
'	#define CELL__RTS_LINENUM PL_IO_NUM_0
	#define CELL__RTS_LINENUM CELL__DATA_SER_PORT
#endif

'CTS (Clear To Send) serial Port Selection
'NOTE: CTS LINE is always linked to an INTERRUPT LINE
#ifndef CELL__CTS_LINENUM
	#define CELL__CTS_LINENUM CELL__DATA_SER_PORT
#endif


'SHDN IO-number selection which is based on the PLATFORM_ID (***Jim will include this in CODY, thus this part can be removed later on)
#ifndef CELL__SHDN_LINENUM
	#if PLATFORM_ID = TPP2W or PLATFORM_ID = TPP2N or PLATFORM_ID = TPP2WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__SHDN_LINENUM PL_IO_NUM_11_TX1
		#elif CELL__DATA_SER_PORT = 1
			'this choice is not available
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__SHDN_LINENUM PL_IO_NUM_15_TX3
		#elif CELL__DATA_SER_PORT = 3
			'this choice is not available
		#endif
	#elif PLATFORM_ID = TPP3W  or PLATFORM_ID = TPP3N or PLATFORM_ID = TPP3WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__SHDN_LINENUM PL_IO_NUM_32
		#elif CELL__DATA_SER_PORT = 1
			#define CELL__SHDN_LINENUM PL_IO_NUM_34
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__SHDN_LINENUM PL_IO_NUM_36
		#elif CELL__DATA_SER_PORT = 3
			#define CELL__SHDN_LINENUM PL_IO_NUM_38
		#endif
	#elif PLATFORM_ID = NB1010 or PLATFORM_ID = NB1010W or PLATFORM_ID = NB1010N
		'I do NOT know the value
	#else
		#define CELL__SHDN_LINENUM PL_IO_NULL
	#endif
#endif

'PWRKEY IO-number selection which is based on the PLATFORM_ID (***Jim will include this in CODY, thus this part can be removed later on)
#ifndef CELL__PWRKEY_LINENUM
	#if PLATFORM_ID = TPP2W or PLATFORM_ID = TPP2N or PLATFORM_ID = TPP2WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__PWRKEY_LINENUM PL_IO_NUM_10_RX1
		#elif CELL__DATA_SER_PORT = 1
			'this choice is not available
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__PWRKEY_LINENUM PL_IO_NUM_14_RX3
		#elif CELL__DATA_SER_PORT = 3
			'this choice is not available
		#endif
	#elif PLATFORM_ID = TPP3W  or PLATFORM_ID = TPP3N or PLATFORM_ID = TPP3WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__PWRKEY_LINENUM PL_IO_NUM_33
		#elif CELL__DATA_SER_PORT = 1
			#define CELL__PWRKEY_LINENUM PL_IO_NUM_35
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__PWRKEY_LINENUM PL_IO_NUM_37
		#elif CELL__DATA_SER_PORT = 3
			#define CELL__PWRKEY_LINENUM PL_IO_NUM_39
		#endif
	#elif PLATFORM_ID = NB1010 or PLATFORM_ID = NB1010W or PLATFORM_ID = NB1010N
		#define CELL__PWRKEY_LINENUM PL_IO_NUM_33
	#else
		#define CELL__PWRKEY_LINENUM PL_IO_NULL
	#endif
#endif

'RESET IO-number selection which is based on the PLATFORM_ID (***Jim will include this in CODY, thus this part can be removed later on)
#ifndef CELL__RESET_LINENUM
	#if PLATFORM_ID = TPP2W or PLATFORM_ID = TPP2N or PLATFORM_ID = TPP2WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__RESET_LINENUM PL_IO_NUM_1
		#elif CELL__DATA_SER_PORT = 1
			'this choice is not available
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__RESET_LINENUM PL_IO_NUM_3
		#elif CELL__DATA_SER_PORT = 3
			'this choice is not available
		#endif
	#elif PLATFORM_ID = TPP3W  or PLATFORM_ID = TPP3N or PLATFORM_ID = TPP3WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__RESET_LINENUM PL_IO_NUM_4
		#elif CELL__DATA_SER_PORT = 1
			#define CELL__RESET_LINENUM PL_IO_NUM_5
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__RESET_LINENUM PL_IO_NUM_6
		#elif CELL__DATA_SER_PORT = 3
			#define CELL__RESET_LINENUM PL_IO_NUM_7
		#endif
	#elif PLATFORM_ID = NB1010 or PLATFORM_ID = NB1010W or PLATFORM_ID = NB1010N
		#define CELL__RESET_LINENUM PL_IO_NUM_55
	#else
'		#define CELL__RESET_LINENUM PL_IO_NULL
	#endif
#endif

'STATUS IO-number selection which is based on the PLATFORM_ID (***Jim will include this in CODY, thus this part can be removed later on)
'NOTE: for PLATFORM_ID = NB1010,NB1010W,NB1010N I do NOT know the IO number yet
#ifndef CELL__STATUS_LINENUM
	#if PLATFORM_ID = TPP2W or PLATFORM_ID = TPP2N or PLATFORM_ID = TPP2WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__STATUS_LINENUM PL_IO_NUM_17_INT1
		#elif CELL__DATA_SER_PORT = 1
			'this choice is not available
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__STATUS_LINENUM PL_IO_NUM_19_INT3
		#elif CELL__DATA_SER_PORT = 3
			'this choice is not available
		#endif
	#elif PLATFORM_ID = TPP3W  or PLATFORM_ID = TPP3N or PLATFORM_ID = TPP3WG2
		#if CELL__DATA_SER_PORT = 0
			#define CELL__STATUS_LINENUM PL_IO_NUM_20_INT4
		#elif CELL__DATA_SER_PORT = 1
			#define CELL__STATUS_LINENUM PL_IO_NUM_21_INT5
		#elif CELL__DATA_SER_PORT = 2
			#define CELL__STATUS_LINENUM PL_IO_NUM_22_INT6
		#elif CELL__DATA_SER_PORT = 3
			#define CELL__STATUS_LINENUM PL_IO_NUM_23_INT7
		#endif
	#elif PLATFORM_ID = NB1010 or PLATFORM_ID = NB1010W or PLATFORM_ID = NB1010N
		'I do NOT know the value
	#else
		#define CELL__STATUS_LINENUM PL_IO_NULL
	#endif
#endif


'CONSTANTS------------------------------------------------------
const CELL__SER_PORT_BAUDRATE = 115200
const CELL__PPP_BUFF_SIZE = CELL__PAYLOAD_SIZE
const CELL__SER_PORT_BUFF_SIZE = CELL__PAYLOAD_SIZE 

const CELL__TAB = chr(9)
const CELL__LF = chr(10)
const CELL__CR = chr(13)
const CELL__SUBSTITUTE = chr(26)	'represents a CTRL+Z
const CELL__RS = chr(30) 'record separator
const CELL__SPACE = chr(32)
const CELL__QUOTMARK = chr(34)
const CELL__DOLLAR = chr(36)
const CELL__PLUS = chr(43)
const CELL__COMMA = chr(44)
const CELL__DOT = chr(46)
const CELL__GREATERTHAN = chr(62)
const CELL__QUESTMARK = chr(63)

const CELL__CRLF = CELL__CR + CELL__LF
const CELL__CRLF_TAB = CELL__CRLF + CELL__TAB

const CELL__STATUSON_STR = "STATUS-ON"
const CELL__PWRKEYON_STR = "PWRKEY-ON"
const CELL__RESETON_STR = "RESET-ON"
const CELL__SHDNON_STR = "SHDN-ON"
const CELL__HIGH_STR = "HIGH"
const CELL__LOW_STR = "LOW"

const CELL__USERMODE = "USER-MODE"

const CELL__EMPTYSTRING = ""
const CELL__RDY = "RDY"
const CELL__NOTRDY = "NOT_RDY"
const CELL__READY = "READY"
const CELL__OK = "OK"
const CELL__NG = "NG"
const CELL__CONNECT = "CONNECT"
const CELL__CONNECT_BAUDRATE = CELL__CONNECT + CELL__SPACE + CELL__SER_PORT_BAUDRATE
const CELL__CGREG_0_1 = "CGREG: 0,1"
const CELL__CGREG_ANY = CELL__PLUS + "CGREG:"

const CELL__RDY_CRLF = CELL__RDY + CELL__CR +CELL__LF
const CELL__OK_CRLF = CELL__OK + CELL__CR +CELL__LF
const CELL__4DOT_OK = CELL__DOT + CELL__DOT + CELL__DOT + CELL__DOT+ CELL__OK
const CELL__ERROR = "ERROR"
const CELL__SIMPIN = "SIM PIN"
const CELL__SIMPUK = "SIM PUK"
const CELL__SIM7000 = "SIM7000"

const CELL__1b_LEN = 1
const CELL__2b_LEN = 2
const CELL__4b_LEN = 4
const CELL__6b_LEN = 6
const CELL__8b_LEN = 8
const CELL__16b_LEN = 16
const CELL__20b_LEN = 20
const CELL__32b_LEN = 32
const CELL__48b_LEN = 48
const CELL__64b_LEN = 64
const CELL__128b_LEN = 128
const CELL__160b_LEN = 160

const CELL__ARRAY_LEN = 4	'1D-array length with 4 pages. Each Page is 255 Bytes.

const CELL__BYTE_SIZE_MAX = &hff
const CELL__SOCK_NUM_MAX = &hf

const CELL__NUMOF_TIMES_TO_SEND_ATCMD = 30
const CELL__MODEM_RESTART_RETRY_MAX = 30
const CELL__POWER_ONOFF_RETRY_MAX = 8
const CELL__RESET_RETRY_MAX = 4
const CELL__SHDN_RETRY_MAX = 2
const CELL__ISRETRY_INPROGR_IN_IDLEMODE_RETRY_MAX = 10
const CELL__ON_SER_DATA_ARRIV_NOT_TRIGG_RETRY_MAX = 10
const CELL__AT_RETRY_MAX = 10
const CELL__AT_CMD_EXEC_RETRY_MAX = 3	'number of times retrying to execute any AT-command
const CELL__AT_CGREG_EXEC_RETRY_MAX = 255	'number of times retrying to execute `AT+CGREG?`
const CELL__SMS_RETRY_MAX = 30

'const CELL__UNIT_500MS = 0.5	'unit in seconds
const CELL__UNIT_VOLT = "V"

const CELL__PWRKEY_TIMEOUT_MIN = (2*3)	'(default: 2*2) minimum timeout before changing PWRKEY to Inactive (<span style="color: gray;">= 2*2 [500msec] = 4 [500msec] = 2 [sec]</span>)
const CELL__STATUS_TIMEOUT_MAX = (2*25)	'(default: 2*22) maximum timeout for STATUS to change to INACTIVE (<span style="color: gray;">= 2*25 [500msec] = 50 [500msec] = 25 [sec]</span>)
const CELL__AT_RETRY_TIMEOUT_MAX = (2*3)	'(default: 2*2) maximum timeout to RECEIVE reply from executed AT-commands (<span style="color: gray;">= 2*2 [500msec] = 4 [500msec] = 2 [sec]</span>)
const CELL__SIM70xx_AT_CGREG_TIMEOUT_MIN = (2*6)
const CELL__AT_CGREG_TIMEOUT_MIN = (2*3)	'(default: 2*2) minimum timeout before changing PWRKEY to Inactive (<span style="color: gray;">= 2*2 [500msec] = 4 [500msec] = 2 [sec]</span>)
const CELL__ISRETRY_INPROGR_IN_IDLEMODE_RETRY_TIMEOUT_MIN = (2*2)
const CELL__ON_SER_DATA_ARRIV_NOT_TRIGG_RETRY_TIMOUT_MIN = (2*4)

#if CELL__PPP_MODE_ISENABLED
	const CELL__PPP_RETRY_MAX = 10
	const CELL__PPP_CONN_RETRY_MAX = 3
	const CELL__PPP_ID_MAX = 255

	'For test purposes, the `CELL__PPP_CONN_STATUS_TIMEOUT_MAX` is set to a low value (e.g. 2*10 = 10 sec)
	'However, realistically this value should be set to (2*120 = 120 sec) or disabled (0 sec) to save power
'	const CELL__PPP_CONN_STATUS_TIMEOUT_MAX = (2*120)	'maximum timeout before Checking the Connection to a specified Server (<span style="color: gray;">= 2*60 [500msec] = 120 [500msec] = 60 [sec]</span>)
'	const CELL__HTTPS_CONN_TIMEOUT_MAX = (1000*10)	'maximum timeout for the modem to connect to a specific https server (<span style="color: gray;">= 1,000*10 [1,000msec] = 10,000 [1,000msec] = 10 [sec]</span>)
#endif


'AT CONSTANTS--------------------------------------------------------
'For more information regarding the SIM7000, please check the following documentation:
'	http://www.microchip.ua/simcom/LTE/SIM7000/SIM7000%20Series_AT%20Command%20Manual_V1.04.pdf
'
'For more information regarding the SIM7500, please check the following documentation:
'	https://simcom.ee/documents/SIM7500A/SIMCOM_SIM7500_ATC_EN_V0.01.pdf
'--------------------------------------------------------------------
const CELL__AT = "AT"
const CELL__AT_PLUS = "AT+"

const CELL__TRIPLEPLUS = CELL__PLUS + CELL__PLUS + CELL__PLUS
const CELL__ATO = "ATO"

const CELL__AT_GSHD = CELL__AT_PLUS + "GSHD"

const CELL__AT_AMPERSAND_E1 = "AT&E1"	'Show the CORRECT BAUDRATE after sending command AT+CGDATA
const CELL__AT_AMPERSAND_C0 = "AT&C0"	'Set DCD line is always ON
const CELL__AT_CPSMS_0 = CELL__AT_PLUS + "CPSMS" + "=" + "0"	'Disable Powersaving Mode
const CELL__AT_AMPERSAND_D0 = "AT&D0"	'Ignore the Status on the DTR

const CELL__ATE1 = "ATE1"
const CELL__AT_CGMM = CELL__AT_PLUS + "CGMM"
const CELL__AT_CBC = CELL__AT_PLUS + "CBC"
const CELL__AT_CNMP_INPUT = "38"
const CELL__AT_CNMP = CELL__AT_PLUS + "CNMP" + "=" + CELL__AT_CNMP_INPUT
const CELL__AT_IPR_INPUT = "115200"	'Local Baud Rate
const CELL__AT_IPR = CELL__AT_PLUS + "IPR" + "=" + CELL__AT_IPR_INPUT
const CELL__AT_IFC_INPUT = "2,2"	'Local FLow Control (RTS and CTS)
const CELL__AT_IFC_1 = CELL__AT_PLUS + "IFC" + "=" + CELL__AT_IFC_INPUT
const CELL__AT_IFC_Q_INPUT = CELL__QUESTMARK
const CELL__AT_IFC_Q = CELL__AT_PLUS + "IFC" + CELL__AT_IFC_Q_INPUT
const CELL__AT_CMEE_INPUT = "2"	'Report Mobile Equipment Error
const CELL__AT_CMEE = CELL__AT_PLUS + "CMEE" + "=" + CELL__AT_CMEE_INPUT
const CELL__AT_CPIN_Q = CELL__AT_PLUS + "CPIN" + CELL__QUESTMARK
const CELL__AT_CFUN_INPUT = "1"	'Functionality
const CELL__AT_CFUN = CELL__AT_PLUS + "CFUN" + "=" + CELL__AT_CFUN_INPUT
const CELL__AT_COPS_INPUT = CELL__QUESTMARK
const CELL__AT_COPS_Q = CELL__AT_PLUS + "COPS" + CELL__AT_COPS_INPUT
const CELL__AT_CGDCONT_CID_INPUT = "1"	'Context ID
const CELL__AT_CGDCONT_PDP_INPUT = "IP"	'Packet Data Protocol
#define CELL__AT_CGDCONT_INPUT ( CELL__AT_CGDCONT_CID_INPUT + "," + CELL__QUOTMARK + CELL__AT_CGDCONT_PDP_INPUT + CELL__QUOTMARK + "," + CELL__QUOTMARK + cell__apn + CELL__QUOTMARK )
#define CELL__AT_CGDCONT (CELL__AT_PLUS + "CGDCONT" + "=" + CELL__AT_CGDCONT_INPUT)
#define CELL__AT_CMNB (CELL__AT_PLUS + "CMNB" + "=" + CELL_BANDTYPE)
#define CELL__AT_CPIN (CELL__AT_PLUS + "CPIN" + "=" + cell__pin)

'#define CELL__AT_CSTT (CELL__AT_PLUS + "CSTT" + "=" + CELL__QUOTMARK + cell__apn + CELL__QUOTMARK)
'const CELL__AT_CIICR = CELL__AT_PLUS + "CIICR"

const CELL__AT_CGREG_Q = CELL__AT_PLUS + "CGREG" + CELL__QUESTMARK
const CELL__AT_CGATT_INPUT = CELL__QUESTMARK
const CELL__AT_CGATT = CELL__AT_PLUS + "CGATT" + CELL__AT_CGATT_INPUT
const CELL__AT_CGACT_INPUT = CELL__QUESTMARK
const CELL__AT_CGACT = CELL__AT_PLUS + "CGACT" + CELL__AT_CGACT_INPUT
const CELL__AT_CPSI_INPUT = CELL__QUESTMARK
const CELL__AT_CPSI = CELL__AT_PLUS + "CPSI" + CELL__AT_CPSI_INPUT
const CELL__AT_CSQ = CELL__AT_PLUS + "CSQ"
const CELL__AT_CGPADDR_INPUT = "1"
const CELL__AT_CGPADDR = CELL__AT_PLUS + "CGPADDR" + "=" + CELL__AT_CGPADDR_INPUT
const CELL__AT_CGDATA_L2P_INPUT = "PPP"
const CELL__AT_CGDATA_INPUT = CELL__QUOTMARK + CELL__AT_CGDATA_L2P_INPUT + CELL__QUOTMARK + "," + CELL__AT_CGDCONT_CID_INPUT
const CELL__AT_CGDATA = CELL__AT_PLUS + "CGDATA" + "=" + CELL__AT_CGDATA_INPUT

#if CELL__AT_USERMODE_ISENABLED
	const CELL__SMS = "SMS"
	const CELL__SMS_FULL = "SMS FULL"

	const CELL__CMTI = CELL__PLUS + "CMTI:"
	const CELL__AT_CMGR = CELL__AT_PLUS + "CMGR"
	const CELL__AT_CMGD = CELL__AT_PLUS + "CMGD"
	
	const CELL_CMGF_INPUT = "1"
	const CELL__AT_CMGF = CELL__AT_PLUS + "CMGF" + "=" + CELL_CMGF_INPUT
	const CELL__AT_CSCS_INPUT = "GSM"
	const CELL__AT_CSCS = CELL__AT_PLUS + "CSCS" + "=" + CELL__QUOTMARK + CELL__AT_CSCS_INPUT + CELL__QUOTMARK
	#define CELL__AT_CSMP (CELL__AT_PLUS + "CSMP" + "=" + cell__csmp_fo + "," + cell__csmp_vp + "," + cell__csmp_pid + "," + cell__csmp_dcs)
	const CELL__CMGS = "CMGS"
	#define CELL__AT_CMGS (CELL__AT_PLUS + CELL__CMGS + "=" + CELL__QUOTMARK + cell__phonenumber + CELL__QUOTMARK)

	#define CELL__AT_CPMS (CELL__AT_PLUS + "CPMS" + "=" + CELL__QUOTMARK + cell__cpms_mem1_stor_type + CELL__QUOTMARK + "," + CELL__QUOTMARK + cell__cpms_mem2_stor_type + CELL__QUOTMARK + "," + CELL__QUOTMARK + cell__cpms_mem3_stor_type + CELL__QUOTMARK)
	#define CELL__AT_CNMI (CELL__AT_PLUS + "CNMI" + "=" + cell__cnmi_mode  + "," + cell__cnmi_mt)
#endif


'PPP CONSTANTS-------------------------------------------------------
#if CELL__PPP_MODE_ISENABLED
	const CELL__PPP = "PPP"
	const CELL__PPP_CRC16_POLYNOMIAL = &h8408	'16-bit CRC polynomial	value which is used when creating the FCS
	const CELL__PPP_ADDR = &hFF
	const CELL__PPP_CTRL = &h03
	const CELL__PPP_XOR_X20 = &h20
	const CELL__PPP_FLAG = &h7E
	const CELL__PPP_FLAG_REPL_CHAR = &h5E
	const CELL__PPP_PARSE_MSG_START_SIGN_STR = CHR(&h7E) + CHR(&hFF)
	const CELL__PPP_PARSE_MSG_END_SIGN_STR = CHR(CELL__PPP_FLAG)
	const CELL__PPP_ESC_CHAR = &h7D
	const CELL__PPP_ESC_REPL_CHAR = &h5D
	const CELL__PPP_INIT_FCS = &hFFFF
	const CELL__PPP_GOOD_FINAL_FCS = &hF0B8	'Final Error Detecting Code used to check whether the packet is error-free (RFC 1662)


	'PPP PROTOCOL TYPE CONSTANTS-----------------------------------------
	const CELL__PPP_PROTO_IP = &h0021	'Internet Protocol
	const CELL__PPP_PROTO_IPCP = &h8021	'Internet Protocol Control Protocol
	const CELL__PPP_PROTO_LCP = &hC021	'Link Control Protocol
	const CELL__PPP_PROTO_PAP=&hC023	'Password Authentication Protocol
	const CELL__PPP_PROTO_CHAP=&hC223	'Challenge Handshake Authentication Protocol

	const CELL__PPP_PROTO_LCP_STR = chr(&hC0) + chr(&h21)
	const CELL__PPP_PROTO_PAP_STR = chr(&hc0) + chr(&h23)
	const CELL__PPP_PROTO_CHAP_STR = chr(&hC2) + chr(&h23)


	'LCP-----------------------------------------------------------------
	'-----------------------+-----------------------------------------------+-------------------+
	' Configuration Options |	Configuration Options Name			  		| Total Size (Byte) |
	'-----------------------+-----------------------------------------------+-------------------+
	' 0x01 						Maximum-Receive-Unit (MRU)							 4
	' 0x02 						Async-Control-Character-Map (ACCM)					 6
	' 0x03 						Authentication-Protocol (AUTH)				  	    >=4
	' 0x04						Quality-Protocol (QP)							
	' 0x05 						Magic-Number (MAGIC)								 6
	' 0x06 						RESERVED
	' 0x07 						Protocol-Field-Compression (PFC)					 2
	' 0x08 						Address-and-Control-Field-Compression (ACFC)		 2
	'
	'For more information, please check the following links: 
	'	- https://support.huawei.com/enterprise/en/doc/EDOC1000177807/a57612e/ppp-packet-format
	'
	'	MRU: 	
	'			The maximum size (up to 65,535) of the PPP frame. The default MRU is 1,500. 
	'			If neither peer is changing the default, this option is not negotiated.
	'		
	'			Remark:	
	'				This Configuration Option may be sent to inform the peer that the sender
	'				can receive larger packets, or to request that the peer send smaller packets.
	'         			This option is used to indicate an implementation capability.
	'				The peer is not required to maximize the use of the capacity.
	'				For example, when a MRU is indicated which is 2048 octets, the
	'				peer is not required to send any packet with 2048 octets.  The
	'				peer need not Configure-Nak to indicate that it will only send
	'				maller packets, since the implementation will always require
	'				support for at least 1500 octets.
	'				
	'			*COULD BE ACCEPTED*
	'
	'	Async-Control-Character-Map:
	'			ACCM is used on asynchronous links such as telephone lines to identify 
	'			control characters that must be escaped (replaced by a specific 
	'			two-character sequence). 
	'				For instance, you may want to avoid the XON and XOFF characters 
	'			used for software handshake, because some misconfigured modem might 
	'			choke upon receipt of an XOFF. Other candidates include Ctrl-] 
	'			(the telnet escape character). 
	'				PPP allows you to escape any of the characters with 
	'			ASCII codes 0 through 31 by specifying them in the async map.
	'
	'			*CAN BE ACCEPTED*
	'
	'	Magic-Number: 	
	'			Randomly generated number used to identify one end of a point-to-point connection. 
	'			Each side negotiates its magic number, taking note of each others magic number. 
	'			If both sides discover that the magic numbers they are negotiating are the same, 
	'			each side attempts to change its magic number. If they are not successful, 
	'			and the magic numbers remain the same, the session terminates because of the 
	'			loopback that is detected.
	'
	'			*CAN ALWAYS BE ACCEPTED*

	'CONFIGURE MRU
	'+------+	+----------------------------------+--------------------+------------- -------+
	'| Data | = | Configuration Option Type (0x01) | Data-length (0x04) | Size (0XC025) = 2048 |
	'+------+	+----------------------------------+--------------------+---------------------+
	const CELL__PPP_LCP_OPTION_MRU_STR = chr(&h01) + chr(&h04) + chr(&h08) + chr(&h00)

	'CONFIGURE ACCM
	'+------+	+----------------------------------+--------------------+-------------------------------+
	'| Data | = | Configuration Option Type (0x02) | Data-length (0x06) | Data-content (0x 00 00 00 00) |
	'+------+	+----------------------------------+--------------------+-------------------------------+
	'This is an example oof a CONFREQ without Authentication Protocol, but with only negotiation option: Async-Control-Character-Map (ACCM)
	const CELL__PPP_LCP_OPTION_ACCM_STR = chr(&h02) + chr(&h06) + chr(&h0) + chr(&h0) + chr(&h0) + chr(&h0)

	'CONFIGURE NAK DATA
	'+------+	+----------------------------------+--------------------+----------------------------------+
	'| Data | = | Configuration Option Type (0x03) | Data-length (0x04) | Authen. Protocol (0xC023) = PAP  |
	'+------+	+----------------------------------+--------------------+----------------------------------+
	const CELL__PPP_LCP_OPTION_PAP_STR = chr(&h03) + chr(&h04) + chr(&hc0) + chr(&h23)	'Authentication Protocol (<span style="color: gray;">0x0304 C023</span>) (<span style="color: gray;">note: 0xC023=PAP</span>)

	'QUALITY CONTROL
	'+------+	+----------------------------------+--------------------+---------------------------+
	'| Data | = | Configuration Option Type (0x04) | Data-length (0x04) | Quality Control  (0xC025) |
	'+------+	+----------------------------------+--------------------+---------------------------+
	const CELL__PPP_LCP_OPTION_QP_STR = chr(&h04) + chr(&h04) + chr(&hc0) + chr(&h25)	'Quality Control (<span style="color: gray;">0x0404 C025</span>)

	'MAGIC-NUMBER
	'+------+	+--------------------------------+----------------------+----------------------+
	'| Data | = | Configuration Option Type (0x05) | Data-length (0x04) | Magic-Number  (0xffffffff) |
	'+------+	+--------------------------------+----------------------+----------------------+
	const CELL__PPP_LCP_OPTION_MAGIC_DUMMY_STR = chr(&h05) + chr(&h06) + chr(&hff) + chr(&hff) + chr(&hff) + chr(&hff)	'Magic-Number which is used as dummy input arg

	'PROTOCOL FIELD COMPRESSION DATA
	'+------+	+--------------------------------+--------------------+
	'| Data | = | Configuration Option Type (0x07) | Data-length (0x02) |
	'+------+	+--------------------------------+--------------------+
	const CELL__PPP_LCP_OPTION_PFC_STR = chr(&h07) + chr(&h02)	'Protocol Field Compression (<span style="color: gray;">0x7002</span>)

	'ADDRESS AND CONTROL FIELD COMPRESSION DATA
	'+------+	+----------------------------------+--------------------+
	'| Data | = | Configuration Option Type (0x08) | Data-length (0x02) |
	'+------+	+----------------------------------+--------------------+
	const CELL__PPP_LCP_OPTION_ACFC_STR = chr(&h08) + chr(&h02)	'ADDRESS AND CONTROL FIELD COMPRESSION (<span style="color: gray;">0x0802</span>)


	'LCP DATA FIELD STRING
	'	This is an example of an LCP Data packet which is used to send to the peer.
	'	CONFREJ is expected from the peer for `CELL__PPP_LCP_OPTION_MRU_STR` and `CELL__PPP_LCP_OPTION_QP_STR`
	'	CONFNAK is expected from the peer for `CELL__PPP_LCP_OPTION_PAP_STR`
	const CELL__PPP_LCP_CONFREQ_DATA_STR = CELL__PPP_LCP_OPTION_MRU_STR + CELL__PPP_LCP_OPTION_ACCM_STR + CELL__PPP_LCP_OPTION_PAP_STR + CELL__PPP_LCP_OPTION_QP_STR



	'IPCP----------------------------------------------------------------
	'-----------------------+----------------------------+-------------------+
	' Configuration Options | Configuration Options Name | Total Size (Byte) |
	'-----------------------+----------------------------+-------------------+
	' 0x01 						IP addresses						>= 4
	' 0x02 						IP-Compression-Protocol				6
	' 0x03 						IP address						   	6
	' 0x81						PRIMARY DNS Serve Address			6
	' 0x83						SECONDARY DNS Serve Address			6

	'see document: http://www.networksorcery.com/enp/rfc/rfc1332.txt

	'This Configuration Option provides a way to negotiate the IP
	'	address to be used on the local end of the link.  It allows the
	'	sender of the Configure-Request to state which IP-address is
	'	desired, or to request that the peer provide the information.  The
	'	peer can provide this information by NAKing the option, and
	'	returning a valid IP-address.
	'
	'IP-address Configuraton Option Format looks like this:
	'+------+	+---------------------------+-------------+------------+
	'| Data | = | Configuration Option Type | Data-length | IP ADDRESS |
	'+------+	+---------------------------+-------------+------------+
	' 6 Bytes				1 Byte				1 Byte		 4 Bytes
	'
	'How does it work?
	'1. CONFREQ with a *NON-ZERO* IP-address 
	'		(e.g. 0x03 06 0A0A0A64 --> IP-address = 0x0A0A0A64 = 10.10.10.100)
	'		In this case the sender would like to inform the peer 
	'		the DESIRED IP-address they would like to use.
	'		- 	If ACCEPTED by the peer, the peer will reply with a *CONFACK*... DONE
	'		- 	If NOT ACCEPTED by the peer, the peer will send a *CONFNAK* 
	'		  	with a suggested remote IP-address. Upon receival, the sender sends a
	'			CONFACK to accept the suggested IP-address.
	'
	'2. CONFREQ with a *ZERO* IP-address
	'		(e.g. 0x03 06 00000000 --> IP-address = 0x00000000 = 0.0.0.0)
	'		In this case the sender would like to REQUEST for a VALID remote IP-address
	'		-	The peer will send a *CONFNAK* with an VALID remote IP-address.
	'			Upon receival, the sender sends a CONFACK to accept the VALID IP-address.
	'
	'REMARKS:
	'1. If the sender sends or request for an IP-address, then it means that this IP-address
	'	is the remote IP-address (on the peer's side).
	'2. If the peer sends or request for an IP-address, then it means that this IP-address is
	'	the IP-address (on the sender's side). This option will most likely not happen, since
	'	the sender is the one who would like to establish a PPP link with the ISP.


	'COMPRESSION DATA PACKET
	const CELL__PPP_IPCP_OPTION_COMPRESS_CODE = chr(&h02)+ chr(&h06)
	const CELL__PPP_IPCP_COMPRESS_DATA = chr(&h00) + chr(&h00) + chr(&h00) + chr(&h00)
	const CELL__PPP_IPCP_OPTION_COMPRESS_STR = CELL__PPP_IPCP_OPTION_COMPRESS_CODE + CELL__PPP_IPCP_COMPRESS_DATA

	'IP ADDRESS DATA PACKET
	const CELL__PPP_IPCP_OPTION_IP_CODE = chr(&h03)+ chr(&h06)
	const CELL__PPP_IPCP_IPADDR_DATA = chr(&h00) + chr(&h00) + chr(&h00) + chr(&h00)
	const CELL__PPP_IPCP_IPADDR_STR = CELL__PPP_IPCP_OPTION_IP_CODE + CELL__PPP_IPCP_IPADDR_DATA

	'IPCP DATA FIELD
	'	This is an example of an IPCP Data packet which is used to send to the peer.
	'	CONFREJ is expected from the peer for `CELL__PPP_IPCP_OPTION_COMPRESS_STR`
	const CELL__PPP_IPCP_CONFREQ_DATA_STR = CELL__PPP_IPCP_OPTION_COMPRESS_STR + CELL__PPP_IPCP_IPADDR_STR
	
	
	'ICMP Message Format------------------------------------------------
	'+-----------+--------+-------------------------------+--------------------------------+-------------------------------+-------------------------------+
	'|	Offsets	 |	Octet |				  0				  |			      1			       |		 	  2			       |			   3			   |
	'+-----------+--------+---------------+---------------+--------------------------------+-------------------------------+-------------------------------+
	'|	Octet	 |	Bit	  |	0	1	2	3 |	4	5	6	7 | 8	9	10	11	12	13	14	15 | 16	17	18	19	20	21	22	23 | 24	 25	 26	 27	 28	 29	 30	 31|
	'+-----------+--------+---------------+---------------+------------------------+-------+-------------------------------+-------------------------------+
	'|	0		 |	0	  |		Version	  |		IHL		  |			DSCP		   |  ECN  |						Total Length						   |
	'+-----------+--------+---------------+---------------+------------------------+-------+----------+----------------------------------------------------+
	'|	4		 |	32	  |							Identification						   |  Flags	  |					Fragment Offset					   |
	'+-----------+--------+-------------------------------+--------------------------------+----------+----------------------------------------------------+
	'|	8		 |	64	  |			Time To Live		  |				Protocol		   |						Header Checksum						   |
	'+-----------+--------+-------------------------------+--------------------------------+---------------------------------------------------------------+
	'|	12		 |	96	  |															Source IP Address													   |
	'+-----------+--------+--------------------------------------------------------------------------------------------------------------------------------+
	'|	16		 |	128	  |														Destination IP Address													   |
	'+-----------+--------+--------------------------------------------------------------------------------------------------------------------------------+
	'|	20		 |	160	  |																																   |
	'|	24		 |	192	  |														Options (if IHL > 5)													   |
	'|	28		 |	224	  |																																   |
	'|	32		 |	256	  |																																   |
	'+-----------+--------+--------------------------------------------------------------------------------------------------------------------------------+

	
	'Using the Above ICMP Message Format
	const CELL__ICMP_SRCIP_POSITION = 13
	const CELL__ICMP_DSTIP_POSITION = 17
	const CELL__ICMP_CODE = 0
	const CELL__ICMP_SENDER_ID = 0	'ppp sequence number

	const CELL__ICMP_VERSION_IHL = chr(&h45)	'VERSION = 4 bits, INTERNET HEADER LENGTH = 4 bits
	const CELL__ICMP_DSCP_ECN = chr(&h00)		'DSCP = 6 bits, ECN = 2 bits
	const CELL__ICMP_TOTALLENGTH = chr(&h00) + chr(&h20)	'TOTAL Length = 16 bits -> 0x0020 = 32 -> which means 32 bytes in length
	const CELL__ICMP_IDENTIFICATION = chr(&h9a) + chr(&h00)	'IDENTIFICATION = 16 bits
	const CELL__ICMP_FLAGS_FRAGMENTOFFSET = chr(&h00) + chr(&h00)	'FLAGS = 3 bits, Fragment Offset = 13 bits
	const CELL__ICMP_TTL = chr(&h20)	'Time-To-Live = 8 bits --> 0x20 = 32
	const CELL__ICMP_PROTOCOL = chr(&h01)	'PROTOCOL = 8 bits --> 0x01 = 1
	const CELL__ICMP_HEADERCHECKSUM = chr(&h00) + chr(&h00)	'HEADER CHECKSUM = 16 bits
	const CELL__ICMP_SRCIP = chr(&h00) + chr(&h00) + chr(&h00) + chr(&h00)	'SOURCE-IP = 16 bits
	const CELL__ICMP_DSTIP = chr(&h00) + chr(&h00) + chr(&h00) + chr(&h00)	'DESTINATION-IP = 16 bits
	const CELL__ICMP_OPTIONS = chr(&h08) + chr(&h00) + chr(&h30) + chr(&h39) + chr(&h02) + chr(&h00) + chr(&h01) + chr(&h00) + chr(&h61) + chr(&h62) + chr(&h63) + chr(&h64)

	const CELL__ICMP_MESSAGE_FORMAT_STR = CELL__ICMP_VERSION_IHL + CELL__ICMP_DSCP_ECN + CELL__ICMP_TOTALLENGTH + CELL__ICMP_IDENTIFICATION + CELL__ICMP_FLAGS_FRAGMENTOFFSET + CELL__ICMP_TTL + CELL__ICMP_PROTOCOL + CELL__ICMP_HEADERCHECKSUM + CELL__ICMP_SRCIP + CELL__ICMP_DSTIP + CELL__ICMP_OPTIONS
#endif



'GPS CONSTANTS-------------------------------------------------------
#if CELL__GPS_MODE_ISENABLED
	const CELL__GPGSV = "$GPGSV"
	const CELL__GPGGA = "$GPGGA"
	const CELL__CGPSNMEA_INPUT = "5" 'decimal value `5` is equivalent to the binary value `101` (in other words, bit 0 and 2 are set to `1`)
	const CELL__AT_CGPSNMEA = CELL__AT_PLUS + "CGPSNMEA" + "=" + CELL__CGPSNMEA_INPUT
	const CELL__CGPSHOR_INPUT = "50"	'GPS accuracy in meters (default = 50)
	const CELL__AT_CGPSHOR = CELL__AT_PLUS + "CGPSHOR" + "=" + CELL__CGPSHOR_INPUT
	const CELL__CGPS_INPUT = "1,1"	'1: Enable GPS, 1: Stand-alone mode
	const CELL__AT_CGPS_ENABLE= CELL__AT_PLUS + "CGPS" + "=" + CELL__CGPS_INPUT
	const CELL__CGPSINFOCFG_INPUT_START = "10" + "," + CELL__CGPSNMEA_INPUT 	'get GPS info every 10 seconds
	const CELL__AT_CGPSINFOCFG_START = CELL__AT_PLUS + "CGPSINFOCFG" + "=" + CELL__CGPSINFOCFG_INPUT_START
#endif


'ENUMERATES----------------------------------------------------------
#ifndef en_cell__status_phases
	enum en_cell__status_phases
		CELL__START_INITIATED,
		CELL__STOP_INITIATED,
		CELL__START_BUFFER_SIZE_IS_SUFFICIENT,
		CELL__START_BUFFER_SIZE_IS_INSUFFICIENT
		
	end enum
#endif


#ifndef en_cell__pwr_objects
	enum en_cell__pwr_objects
		STATUS,
		PWRKEY,
		RESET,
		SHDN
	end enum
#endif


#ifndef en_cell__op_pwr_phases
	enum en_cell__op_pwr_phases
		PHASE_PWR_DONOT_CHANGE,
		PHASE_PWR_INIT,
		PHASE_PWR_DEINIT,
		PHASE_PWR_RESET_ON,
		PHASE_PWR_RESET_WAIT,
		PHASE_PWR_RESET_RETRY,
		PHASE_PWR_RESET_OFF,
		PHASE_PWR_PWRKEY_ON,
		PHASE_PWR_PWRKEY_OFF,
		PHASE_PWR_POWERING_ONOFF,
		PHASE_PWR_POWERING_ONOFF_WAIT,
		PHASE_PWR_POWERING_ONOFF_RETRY,
		PHASE_PWR_OBJECT_STATE_CHANGED,
		PHASE_PWR_POWERING_ON,
		PHASE_PWR_POWERING_OFF,
		PHASE_PWR_SERPORT_CHK_RDY_STATE,
		PHASE_PWR_MODEM_ONOFF,
		PHASE_PWR_MODEM_ON,
		PHASE_PWR_MODEM_OFF,
		PHASE_PWR_MODEM_RESTART_RETRY,
		PHASE_PWR_MODEM_RESTART_RETRY_FAILED,
		PHASE_PWR_SHDN_OFF,
		PHASE_PWR_SHDN_WAIT,
		PHASE_PWR_SHDN_RETRY,
		PHASE_PWR_SHDN_ON,

		PHASE_PWR_IDLE

	end enum
#endif

#ifndef en_cell__op_at_phases
	enum en_cell__op_at_phases
		PHASE_AT_DONOT_CHANGE,
		PHASE_AT_INIT,
		PHASE_AT_AT,
		PHASE_AT_AMPERSAND_E1,
		PHASE_AT_AMPERSAND_C0,
		PHASE_AT_CPSMS_0,
		PHASE_AT_AMPERSAND_D0,
		PHASE_AT_CMNB,
		PHASE_AT_CGMM,
		PHASE_AT_CBC,
		PHASE_AT_CNMP,
		PHASE_AT_ATE1,
		PHASE_AT_IPR,
		PHASE_AT_IFC,
		PHASE_AT_CMEE,
		PHASE_AT_CPIN_CHECK,
		PHASE_AT_CPIN,
		PHASE_AT_CFUN,
		PHASE_AT_COPS,
		PHASE_AT_CGDCONT,
		PHASE_AT_CSTT,
		PHASE_AT_CIICR,
		PHASE_AT_CIFSR,
		PHASE_AT_CGREG,
		PHASE_AT_CGATT,
		PHASE_AT_CGACT,
		PHASE_AT_CPSI,
		PHASE_AT_CSQ,
		PHASE_AT_CGPADDR,
		PHASE_AT_CGREG_DBLCHK,
		PHASE_AT_CGDATA,
		PHASE_AT_NOTIFICATION,
		PHASE_AT_USERMODE_CMD_INPUT,
		PHASE_AT_USERMODE_GET_AND_SEND_CMD,
		PHASE_AT_USERMODE_RETRY,
		PHASE_AT_NO_SPACE_AVAILABLE,

		PHASE_AT_FREE_INPUT,
		PHASE_AT_PARSE_RETRY,
		PHASE_AT_CMD_EXEC_RETRY,
		PHASE_AT_CMD_EXEC_RETRY_EXCEEDED,
		PHASE_AT_ISRETRY_IN_PROGRESS_IN_IDLE_MODE,
		PHASE_AT_ISRETRY_IN_PROGRESS_IN_IDLE_MODE_EXCEEDED,
		PHASE_AT_ON_SER_DATA_ARRIV_NOT_TRIGG,
		PHASE_AT_ON_SER_DATA_ARRIV_NOT_TRIGG_EXCEEDED,
		PHASE_AT_USERMODE_BUFFER_FULL,
		PHASE_SMS_RCV,
		PHASE_SMS_RDY_TO_RCV,
		PHASE_SMS_EMPTY_STRING,
		PHASE_SMS_SENT,
		PHASE_SMS_FULL,
		PHASE_AT_CMD_CONTAINS_TRIPLEPLUS,
		PHASE_AT_CMD_CONTAINS_ATO,
		
		PHASE_AT_SWITCH_FROM_DATA_TO_CMD_MODE,
		PHASE_AT_SWITCH_FROM_CMD_TO_DATA_MODE,
		
		PHASE_AT_IDLE
		
	end enum
#endif

#ifndef en_cell__op_ppp_phases
	enum en_cell__op_ppp_phases
		PHASE_PPP_DONOT_CHANGE,
		PHASE_PPP_LCP_PARSE_PROCESSING,
		PHASE_PPP_LCP_NEGOTIATION,
		PHASE_PPP_LCP_SEND
		PHASE_PPP_MSG_LEN_NOTMATCH,
		PHASE_PPP_FCS_ISBAD,
		PHASE_PPP_ADDRESS_FIELD_NOTPRESENT,
		PHASE_PPP_CONTROL_FIELD_NOTPRESENT
		PHASE_PPP_LCP_NEGO_SUCCESS,
		PHASE_PPP_RETRY_ERROR,
		PHASE_PPP_LCP_DISCREQ_BY_PEER,
		PHASE_PPP_LCP_DISCREQ_FROM_SENDER,

		PHASE_PPP_PAP_NEGOTIATION,
		PHASE_PPP_PAP_NEGO_SUCCESS,
		PHASE_PPP_PAP_NEGO_FAILED,

		PHASE_PPP_IPCP_NEGOTIATION,
		PHASE_PPP_IPCP_CONNECT,
		PHASE_PPP_IPCP_RCV_IP,
		PHASE_PPP_IPCP_NEGO_SUCCESS,
		PHASE_PPP_IPCP_NEGO_FAILED,
		PHASE_PPP_IPCP_DISCREQ_BY_PEER,
		PHASE_PPP_IPCP_DISCREQ_FROM_SENDER
		PHASE_PPP_IPCP_CONNECT_STATUS,
		PHASE_PPP_IPCP_CHK_CONNECT_STATUS,
		
		PHASE_PPP_PING,
		PHASE_PPP_PING_SUCCESSFUL,
		PHASE_PPP_PING_FAILED,
		
		PHASE_PPP_LINK_ESTABLISHED,
		PHASE_PPP_CONN_TO_SERVER_SUCCESS,
		PHASE_PPP_CONN_TO_SERVER_RETRY,
		PHASE_PPP_CONN_TO_SERVER_FAILED,
		
		PHASE_PPP_TRY_TO_CONN_TO_SERVER,
		PHASE_PPP_CONN_UPTIME,
		
		PHASE_PPP_DETERMINED_BY_SYSTEM,
		
		PHASE_PPP_IDLE
		
	end enum
#endif

#ifndef en_cell__op_gps_phases
	enum en_cell__op_gps_phases
		PHASE_GPS_DONOT_CHANGE,
		PHASE_GPS_PARSE_MESSAGE,
		PHASE_GPS_CGPSNMEA,
		PHASE_GPS_CGPSHOR,
		PHASE_GPS_CGPS_ENABLE,
		PHASE_GPS_CGPSINFOCFG_START,
		PHASE_GPS_WAITFORDATA,

		PHASE_GPS_SIV,
		PHASE_GPS_POS,
		
		PHASE_GPS_IDLE
		
	end enum
#endif

#ifndef en_cell__op_parse_phases
	enum en_cell__op_parse_phases
		PHASE_PARSE_DONOT_CHANGE,
		PHASE_PARSE_AT_MESSAGE,
		PHASE_PARSE_PPP_MESSAGE,
		PHASE_PARSE_GPS_MESSAGE,
		PHASE_PARSE_SMS_MESSAGE,
		
		PHASE_PARSE_IDLE
		
	end enum
#endif


#if CELL__PPP_MODE_ISENABLED
	'LCP-----------------------------------------------------------------
	'------------+--------------------
	'Code Value		Packet Type
	'------------+--------------------
	'0x01			CONFigure-REQuest
	'0x02			CONFigure-ACK
	'0x03			CONFigure-NAK
	'0x04			CONFigure-REJect
	'0x05			Terminate-REQuest
	'0x06			Terminate-ACK
	'0x07			Code-REJect
	'0x08			Protocol-REJect
	'0x09			Echo-REQuest
	'0x0A			Echo-Reply
	'0x0B			DIScard-REQuest
	'0x0C			Reserved
	'*******************
	'*** EXPLANATION ***
	'*******************
	'See RFC1661: https://www.freesoft.org/CIE/RFC/1661/21.htm
	'
	'CONFigure-REQuest: A sender wishing to open a connection MUST transmit a CONFigure-REQuest. 
	'					The Configuration Options field is filled with any desired changes to the link defaults. 
	'					NOTE: Configuration Options SHOULD NOT be included with default values!!!
	'	Possible responses are:
	'	- CONFigure-ACK
	'	- CONFigure-NAK
	'	- CONFigure-REJ
	'	- DIScard-REQuest
	'
	'CONFigure-ACK:		If every Configuration Options received in via CONFREQ are recognizable and all values are acceptable, 
	'					then the sender MUST transmit a CONFigure-ACK. 
	'						The acknowledged Configuration Options *MUST NOT* be reordered or modified in any way.
	'					In other words, the CONFigure-ACK LCP Packet Format MUST BE IDENTICAL to the RECEIVED LCP Packet Format.
	'
	'CONFigure-NAK:		Sent when all the LCP options are recognized, but the values of some options are not acceptable. 
	'					CONFigure-NACK includes the NON-AGREEABLE Configuration option(s) and their acceptable values.
	'						Finally, an sender may be configured to request the negotiation of a *specific Configuration Option*. 
	'					If that option is NOT LISTED, then that option MAY be appended to the list of Nak'd Configuration Options, 
	'					this in order to prompt the peer to include that option in its next Configure-Request packet. 
	'					Any value fields for the option MUST indicate values acceptable to the Configure-Nak sender.
	'
	'	Response to a CONFNAK MUST be a CONFREQ:
	'		In the CONFREQ, the CONFNAK's Configuration Options and Values MUST be *INCLUDED*!!!
	'		A new *sender*'s identifier MUST be used for the CONFREQ (new identifier = old identifier + 1)
	'		Note: this identifierr is not the same as the one received via the CONFNAK.
	'	***REMARK: DO NOT expect a CONFACK as response to a CONFNAK. This will NOT happens!!!
	'
	'CONFigure-REJect: 	Sent when Configuration Options are NOT recognized or NOT acceptable for negotiation.
	'					The Options field is filled with only the unacceptable Configuration Options as shown in the CONFiguration-REQuest. 
	'						All recognizable and negotiable Configuration Options are filtered out of the CONFigure-REJect.
	'					Invalid packets are silently discarded.
	'
	'	Response to a CONFREJ MUST be a CONFREQ:
	'		In the CONFREQ, the CONFREJ's Configuration Options and Values MUST be *EXCLUDED*!!!
	'		A new *sender*'s identifier MUST be used for the CONFREQ (new identifier = old identifier + 1)
	'		Note: this identifierr is not the same as the one received via the CONFREJ.
	'	***REMARK: DO NOT expect a CONFACK as response to a CONFREJ. This will NOT happens!!!

	#ifndef en_cell__op_ppp_codes
		enum en_cell__op_ppp_codes
			PPP_CONFREQ = 1,
			PPP_CONFACK = 2,
			PPP_CONFNAK = 3,
			PPP_CONFREJ = 4,
			PPP_ECHOREQ = 9,
			PPP_DISREQ = 11
			
		end enum
	#endif

	#ifndef en_cell__op_ppp_peer_codes
		enum en_cell__op_ppp_peer_codes
			PPP_PEER_CONFREQ = 1,
			PPP_PEER_CONFACK = 2,
			PPP_PEER_CONFNAK = 3,
			PPP_PEER_CONFREJ = 4,
			PPP_PEER_DISREQ = 11
			
		end enum
	#endif

	#ifndef en_cell__op_ppp_sender_codes
		enum en_cell__op_ppp_sender_codes
			PPP_SENDER_CONFACK = 2,
			PPP_SENDER_CONFNAK = 3,
			PPP_SENDER_CONFREJ = 4,
			PPP_SENDER_DISREQ = 11
			
		end enum
	#endif

	#ifndef en_cell__op_ppp_lcp_config_options
		enum en_cell__op_ppp_lcp_config_options
			CONFIG_OPTION_MRU = 1,	'Maxinegotmum-Receive-Unit (4 Bytes)
			CONFIG_OPTION_ACCM = 2,	'Async-Control-Character-Map(6 Bytes)
			CONFIG_OPTION_AUTH = 3,	'Authentication-Protocol (5 or 6 Bytes)
			CONFIG_OPTION_MAGIC = 5,	'Magic-Number (6 Bytes)
			CONFIG_OPTION_PFC = 7,	'Protocol-Field-Compression (2 Bytes)
			CONFIG_OPTION_ACFC = 8	'Address-and-Control-Field-Compression (2 Bytes)

		end enum
	#endif

	#ifndef en_cell__op_https_servers
		enum en_cell__op_https_servers
			SERVER_GOOGLE,
			SERVER_TIBBO
		
		end enum
	#endif


	'PPP DATA IPC OPTIONS------------------------------------------------
	#ifndef en_cell__op_ppp_ipcp_config_options
		enum en_cell__op_ppp_ipcp_config_options
			CONFIG_OPTION_IP_COMPRESSION = 2,	'Compression protocol (RFC1332)
			CONFIG_OPTION_IP = 3,	'IP-Address (RFC1332)
			CONFIG_OPTION_PRI_DNS = 129,	'Primary DNS Server (RFC1877)
			CONFIG_OPTION_SEC_DNS = 131	'Secondary DNS Server (RFC1877)
		
		end enum
	#endif
#endif


'CALLBACK ENUMS------------------------------------------------------
#ifndef en_cell__pwr_callbacks
	enum en_cell__pwr_callbacks
		CALLBACK_IS_POWERING_ONOFF_FAILED,
		CALLBACK_AT_CHECK_RDY_STATE,
		CALLBACK_IS_ON_AND_RDY,
		CALLBACK_IS_OFF,
		
		CALLBACKERR_INSUFFICIENT_BUFFER_SIZE
	end enum
#endif

#ifndef en_cell__at_callbacks
	enum en_cell__at_callbacks
		CALLBACK_AT_REPLY,
		CALLBACK_AT_REPLY_ERROR,
'		CALLBACK_AT_RETRY_ERROR,
		
		CALLBACK_AT_NOTIFICATION,
		CALLBACK_AT_STORAGE_FULL,
		CALLBACK_AT_SMS_NOTIFICATION
		
	end enum
#endif

#if CELL__PPP_MODE_ISENABLED
	#ifndef en_cell__ppp_callbacks
		enum en_cell__ppp_callbacks
			CALLBACK_PPP_PARSE_MSG_NOT_FOUND
			CALLBACK_PPP_MSG_LEN_NOTMATCH,
			CALLBACK_PPP_FCS_ISBAD,
			CALLBACK_PPP_ADDRESS_FIELD_NOTPRESENT,
			CALLBACK_PPP_CONTROL_FIELD_NOTPRESENT,
			CALLBACK_PPP_PROTOTYPE_ISNOT_LCP,
			CALLBACK_PPP_LCP_SUCCESSFUL,
			CALLBACK_PPP_RETRY_ERROR,
			CALLBACKERR_PPP_LCP_DISCREQ_BY_PEER,
			CALLBACKERR_PPP_LCP_DISCREQ_FROM_SENDER,
			
			CALLBACK_PPP_PAP_SUCCESSFUL,
			CALLBACK_PPP_PAP_FAILED,
			
			CALLBACK_PPP_IPCP_NEGO_SUCCESS,
			CALLBACK_PPP_IPCP_NEGO_FAILED,
			CALLBACK_PPP_LINK_ESTABLISHED,
			CALLBACK_PPP_CONN_TO_SERVER_SUCCESS,
			CALLBACKERR_PPP_CONN_TO_SERVER_RETRY
			CALLBACKERR_PPP_CONN_TO_SERVER_FAILED,
			CALLBACKERR_PPP_IPCP_DISCREQ_BY_PEER,
			CALLBACKERR_PPP_IPCP_DISCREQ_FROM_SENDER
			
		end enum
	#endif
#endif

#if CELL__GPS_MODE_ISENABLED
	#ifndef en_cell__gps_callbacks
		enum en_cell__gps_callbacks
			CALLBACK_GPS_SIV_OK,
			CALLBACK_GPS_POS_OK
			
		end enum
	#endif
#endif


'VARIABLE DECLARATIONS-----------------------------------------------
declare cell__modem_restart_isTrigg as boolean
declare cell__modem_stop_is_already_Trigg as boolean

declare cell__modem_restart_retry_param as byte

'declare cell__at_starttime as word
declare cell__at_cmd as string
declare cell__reply as string	'Replied message

declare cell__starttime as word
declare cell__newtime as word
declare cell__elapsedtime as word

declare cell__startstate as low_high

#if CELL__PPP_MODE_ISENABLED
	declare cell__https_retry_param as byte

	declare cell__ts_daycount as dword
	declare cell__ts_hrcount as byte
	declare cell__ts_mincount as byte
	declare cell__ts_seccount as word

	declare cell__servername_ip as string(CELL__32b_LEN)
	declare cell__ppp_conn_uptime as string(CELL__64b_LEN)
	declare cell__ppp_sender_ip as string(CELL__4b_LEN)	'remote ip-address to be used by the sender
#endif

#if CELL__GPS_MODE_ISENABLED
	declare cell__gps_siv_data as string(CELL__128b_LEN)	'Satellite in View
	declare cell__gps_pos_data as string(CELL__128b_LEN)	'GPS Position
#endif

'CALLBACK DECLARATIONS-----------------------------------------------
declare sub cell__callback_powering_onoff_failed()
'<b>METHOD. </b><br><br>
'Callback to notify that the connectivity hardware has failed to power on or off.

declare sub cell__callback_get_into_rdy_state_failed()
'<b>METHOD. </b><br><br>
'Callback to notify that the modem has failed to get into the RDY state.

declare sub cell__callback_modem_restart_failed()
'<b>METHOD. </b><br><br>
'Callback to notify that modem failed to restart.

declare sub cell__callback_modem_on()
'<b>METHOD. </b><br><br>
'Callback to notify that the modem has been activated successfully and its state is Active.

declare sub cell__callback_modem_off()
'<b>METHOD. </b><br><br>
'Callback to notify that the modem has been deactivated successfully and its state is Inactive.

declare sub cell__callback_insufficient_buffer_pages()
'<b>METHOD. </b><br><br>
'Callback to notify that the buffer pages allocated for data serial port, UDP, and TCP operations are insufficient to initialize the library.

declare sub cell__callback_at_reply()
'<b>METHOD. </b><br><br>
'Callback to show the parsed AT reply.

declare sub cell__callback_at_reply_contains_error()
'<b>METHOD. </b><br><br>
'Callback to notify that AT reply contains an ERROR.

#if CELL__PPP_MODE_ISENABLED
	declare sub cell__callback_ppp_fcs_is_bad()
	'<b>METHOD. </b><br><br>
	'Callback to notify that FCS is bad.

	declare sub cell__callback_ppp_missing_address_field()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the <i>address</i> field is not present.

	declare sub cell__callback_ppp_missing_control_field()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the <i>control</i> field is not present.

	declare sub cell__callback_ppp_lcp_msg_length_not_matching()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the LCP message <i>length</i> does not match the expected result.

	declare sub cell__callback_ppp_lcp_successful()
	'<b>METHOD. </b><br><br>
	'Callback to notify that LCP negotiation was successful.

	declare sub cell__callback_ppp_lcp_disreq_from_peer()
	'<b>METHOD. </b><br><br>
	'Callback to notify that an LCP discard request was received from peer.

	declare sub cell__callback_ppp_lcp_disreq_from_sender()
	'<b>METHOD. </b><br><br>
	'Callback to notify that an LCP discard request was received from sender.

	declare sub cell__callback_ppp_retry_exceeded()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the number of PPP reconnection attempts has exceeded the maximum allowed quota.

	declare sub cell__callback_ppp_pap_successful()
	'<b>METHOD. </b><br><br>
	'Callback to notify that PAP negotiation was successful.

	declare sub cell__callback_ppp_pap_nego_failed()
	'<b>METHOD. </b><br><br>
	'Callback to notify that PAP negotiation was unsuccessful.

	declare sub cell__callback_ppp_ipcp_successful()
	'<b>METHOD. </b><br><br>
	'Callback to notify that IPCP negotiation was successful.

	declare sub cell__callback_ppp_connection_to_server_successful()
	'<b>METHOD. </b><br><br>
	'Callback to notify that connection to specified server was successful.

	declare sub cell__callback_ppp_connection_to_server_retry()
	'<b>METHOD. </b><br><br>
	'Callback to notify that system is attempting to connect to the specified server.

	declare sub cell__callback_ppp_connection_to_server_failed()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the connection to the specified server has failed.

	declare sub cell__callback_ppp_ipcp_disreq_from_peer()
	'<b>METHOD. </b><br><br>
	'Callback to notify that an IPCP discard request was received from peer.		

	declare sub cell__callback_ppp_ipcp_disreq_from_sender()
	'<b>METHOD. </b><br><br>
	'Callback to notify that an IPCP discard request was received from sender.	

	declare sub cell__callback_ppp_ping_successful()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the ping was successful.	
	
	declare sub cell__callback_ppp_ping_failed()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the ping failed.	
	
	declare sub cell__callback_ppp_link_established()
	'<b>METHOD. </b><br><br>
	'Callback to notify that a PPP link has been established.
	
	declare sub cell__callback_after_switching_from_DATA_to_CMD()
	'<b>METHOD. </b><br><br>
	'Callback to notify after switching from Data-mode or PPP-mode to Command-mode.

	declare sub cell__callback_after_switching_from_CMD_to_DATA()
	'<b>METHOD. </b><br><br>
	'Callback to notify after switching from Command-mode to Data-mode or PPP-mode.
#endif

#if CELL__GPS_MODE_ISENABLED
	declare sub cell__callback_gps_siv()
	'<b>METHOD. </b><br><br>
	'Callback to show the Satellites in View (SIV).

	declare sub cell__callback_gps_position()
	'<b>METHOD. </b><br><br>
	'Callback to show the GPS position.
#endif

#if CELL__AT_USERMODE_ISENABLED	
	declare sub cell__callback_at_notification()
	'<b>METHOD. </b><br><br>
	'Callback to notify that manual AT command mode is enabled and ready.
	
	declare sub cell__callback_at_usermode_cmd_input()
	'<b>METHOD. </b><br><br>
	'Callback that provides area for users to place their AT commands.

	declare sub cell__callback_at_usermode_sms_message_length_exceeded_error()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the to-be-sent SMS-message exceeds the maximum allowed 160 characters. <br><br>	
	
	declare sub cell__callback_at_usermode_sms_sent_notif()
	'<b>METHOD. </b><br><br>
	'Callback to notify that an SMS-message has been sent.
	
	declare sub cell__callback_at_usermode_sms_rcv_notif()
	'<b>METHOD. </b><br><br>
	'Callback to notify that an SMS-message has been received.

	declare sub cell__callback_at_usermode_sms_auto_reply()
	'<b>METHOD. </b><br><br>
	'Callback to autoreply for the received SMS-message.
	
	declare sub cell__callback_at_usermode_sms_storage_full_notif()
	'<b>METHOD. </b><br><br>
	'Callback to notify that the SMS-storage is full.
#endif

declare sub cell__callback_at_storage_full()
'<b>METHOD. </b><br><br>
'Callback to notify that AT command storage is full.

'XXXXXXXXXXXXXXXXXXX USING IO EXTENDER FOR CELL
#if CELL_IO_EXTENDER
	declare sub cell_callback_io_extender_setup()
#endif


'DECLARATIONS--------------------------------------------------------
declare function cell__start(byref pin as string(CELL__16b_LEN), byref apn as string,
								byref username as string, byref password as string) as en_cell__status_phases
'<b>METHOD. </b><br><br>
'Initializes connectivity hardware, and either enters manual AT command mode or attempts to establish and maintain a PPP connection.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>pin<font color="magenta"> - </font><i>For the <font color="dodgerblue">SIM7500</font>, you must provide the SIM card's PIN<br></i>
		'<ul>
			'<li><font color="gray"><i>If no PIN is required, then pass CELL__QUESTMARK</i></font></li>
			'<li><font color="gray"><i>If the modem is not a SIM7500, then pass CELL__EMPTYSTRING</i></font></li>
		'</ul>
	'</li>
	'<li>apn<font color="magenta"> - </font><i>Access Point Name</i></li>
	'<li>bandtype<font color="magenta"> - </font><i>Band-type (CAT-M1 and/or NB-Iot)</i></li>
	'<li>username<font color="magenta"> - </font><i>PAP username</i></li>
	'<li>password<font color="magenta"> - </font><i>PAP password</i></li>
'</ul>

declare sub cell__graceful_shutdown()
'<b>METHOD. </b><br><br>
'Powers off modem gracefully.<br><br>
'<b>REMARKS: </b><br>
'<ul>
	'<li>can be called from any mode (<font color="gray">e.g., Command-, Data-, PPP-mode</font>)
	'<li>triggers <font color="dodgerblue">cell__stop</font> to do the 'heavy' lifting.
'</ul>
declare function cell__stop(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
								next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
									next_parse_phase as en_cell__op_parse_phases) as en_cell__status_phases
'<b>METHOD. </b><br><br>
'De-initializes connectivity hardware, and powers-off modem.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>

declare function cell__buffersize_isSufficient() as boolean
'<b>METHOD. </b><br><br>
'Calculates whether the buffers allocated for the data serial port and PPP operations are within acceptable limits. One page equals 256 bytes.

declare function cell__calc_timediff_16b(tstart as word, tend as word) as word
'<b>METHOD </b><br><br>
'Calculates the elapsed time between two points of time (in 500 millisecond increments).<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>tstart<font color="magenta"> - </font><i>Start time</i></li>
	'<li>tend<font color="magenta"> - </font><i>End time</i><li>
'</ul>

declare sub cell__ltrim_crlf(byref inputdata as string)
'<b>METHOD. </b><br><br>
'Trims <font color="dodgerblue">leading</font> CR and LF.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>inputdata<font color="magenta"> - </font><i>Data to be parsed</i>
'</ul>

declare sub cell__rtrim_crlf(byref inputdata as string)
'<b>METHOD. </b><br><br>
'Trims <font color="dodgerblue">trailing</font> CR and LF.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>inputdata<font color="magenta"> - </font><i>Data to be parsed</i>
'</ul>

declare sub cell__trim_lstring(byref inputdata as string, byref lstring as string(CELL__128b_LEN))
'<b>METHOD. </b><br><br>
'Trims <font color="dodgerblue">leading</font> string as specified.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>inputdata<font color="magenta"> - </font><i>Data to be parsed</i></li>
	'<li>lstring<font color="magenta"> - </font><i>Leading string that will be removed from the inputed data</i></li>
'</ul>	

declare sub cell__substitute_char(byref inputdata as string, byref oldchar as string(CELL__1b_LEN), byref newchar as string(CELL__1b_LEN))
'<b>METHOD. </b><br><br>
'Replaces one character with another.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>inputdata<font color="magenta"> - </font><i>Data to be parsed</i></li>
	'<li>oldchar<font color="magenta"> - </font><i>Character to be substituted</i></li>
	'<li>newchar<font color="magenta"> - </font><i>Substitute character</i></i>
'</ul>

declare function cell__get_string_between_2chars( byref inputdata as string, nth_occur as byte, 
													byref firstchar as string(1), byref secondchar as string(1) ) as string(CELL__32b_LEN)
'<b>METHOD. </b><br><br>
'Gets the string between two commas.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>inputdata<font color="magenta"> - </font><i>Data to be parsed</i></li>
	'<li>nth_occur<font color="magenta"> - </font><i>N-th occurrence of the first character</i></li>
	'<li>firstchar<font color="magenta"> - </font><i>First matching character</i></li>
	'<li>secondchar<font color="magenta"> - </font><i>Second matching character</i></li>
'</ul>	


#if CELL__DEBUGPRINT_UDP_ISENABLED
	declare sub cell__debugprint_thru_udp(byref msg as string)
		'<b>METHOD. </b><br><br>
		'Prints debug messages via a specified UDP port.<br><br>
		'<b>Input parameters:</b>
		'<ul>
			'<li>msg<font color="magenta"> - </font><i>Debug message to be printed</i></li>
		'</ul>
#endif


#if CELL__DEBUGPRINT_SERPORT_ISENABLED
	declare sub cell__debugprint_thru_serport(byref msg as string)
		'<b>METHOD. </b><br><br>
		'Prints debug messages via a specified serial port.<br><br>
		'<b>Input parameters:</b>
		'<ul>
			'<li>msg<font color="magenta"> - </font><i>Debug message to be printed</i></li>
		'</ul>
#endif

declare sub cell__debugprint_status(select_phase as en_cell__status_phases, byref msg as string)
'<b>METHOD. </b><br><br>
'Prints the modem's status after it is powered on.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>select_phase<font color="magenta"> - </font><i>Specifies at which phase to display messages</i><li>
	'<li>msg<font color="magenta"> - </font><i>Additional message to be shown (if any)</i></li>
'</ul>

declare sub cell__debugprint_pwr_phase(select_phase as en_cell__op_pwr_phases, 
											byref msg as string)
'<b>METHOD. </b><br><br>
'Prints power-related debug messages.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>select_phase<font color="magenta"> - </font><i>Specifies at which phase to display messages</i></li>
	'<li>msg<font color="magenta"> - </font><i>Additional message to be shown (if any)</i></li>
'</ul>

declare sub cell__debugprint_at_phase(select_phase as en_cell__op_at_phases, byref atcmd as string, byref msg as string)
'<b>METHOD. </b><br><br>
'Prints AT-related debug messages.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>select_phase<font color="magenta"> - </font><i>Specifies at which phase to display messages</i><li>
	'<li>atcmd<font color="magenta"> - </font><i>Full AT-command (e.g., <font color="dodgerblue">AT+NAME</font>)</i></li>
	'<li>msg<font color="magenta"> - </font><i>Additional message to be shown (if any)</i></li>
'</ul>

#if CELL__PPP_MODE_ISENABLED
	declare sub cell__debugprint_ppp_phase(select_phase as en_cell__op_ppp_phases, 
									byref msg as string)
	'<b>METHOD. </b><br><br>
	'Prints PPP-related debug messages.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>select_phase<font color="magenta"> - </font><i>Specifies at which phase to display messages</i></li>
		'<li>msg<font color="magenta"> - </font><i>Additional message to be shown (if any)</i></li>
	'</ul>
#endif

#if CELL__GPS_MODE_ISENABLED
	declare sub cell__debugprint_gps_phase(select_phase as en_cell__op_gps_phases, 
									byref atcmd as string, 
										byref msg as string)
	'<b>METHOD.</b><br><br>
	'Prints GPS-related debug messages.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>select_phase<font color="magenta"> - </font><i>Specifies at which phase to display messages</i></li>
		'<li>atcmd <font color="magenta"> - </font><i>Full AT command (e.g., <font color="dodgerblue">AT+NAME</font>)</i></li>
		'<li>msg<font color="magenta"> - </font><i>Additional message to-be shown (if any)</i></li>
	'</ul>
#endif


declare sub cell__update_op_next_phases(new_pwr_phase as en_cell__op_pwr_phases, new_at_phase as en_cell__op_at_phases, 
											new_ppp_phase as en_cell__op_ppp_phases, new_gps_phase as en_cell__op_gps_phases,
												new_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Updates the operational <font color="dodgerblue">POWER</font>, 
'							<font color="dodgerblue">AT</font>, 
'								<font color="dodgerblue">PPP</font>,
'									<font color="dodgerblue">GPS</font>, and
'										<font color="dodgerblue">PARSE</font> phases.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>new_pwr_phase<font color="magenta"> - </font><i>Update POWER phase</i></li>
	'<li>new_at_phase<font color="magenta"> - </font><i>Update AT phase</i></li>
	'<li>new_ppp_phase<font color="magenta"> - </font><i>Update PPP phase</i></li>
	'<li>new_gps_phase<font color="magenta"> - </font><i>Update GPS phase</i></li>
	'<li>new_parse_phase <font color="magenta"> - </font><i>Update parse phase</i></li>
'</ul>
	
declare sub cell__init(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Initializes the connectivity hardware.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>

declare sub cell__deinit(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'De-initializes the connectivity hardware.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>

declare sub cell__init_param_var_bool()
'<b>METHOD. </b><br><br>
'Initializes parameters, variables and booleans.

declare sub cell__init_io()
'<b>METHOD. </b><br><br>
'Sets and enables I/O lines as input/output.<br>

#if CELL__AT_USERMODE_ISENABLED
	declare	sub cell__init_at_cmd_storArray()
	'<b>METHODE. </b><br><br>
	'Initializes USERMODE-related variables (Array and Index)
#endif

declare sub cell__reverse_polarity(byref pwr_object as en_cell__pwr_objects, rev_polarity as no_yes)
'<b>METHOD. </b><br><br>
'Changes the polarity of a specified power-related object.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>pwr_object<font color="magenta"> - </font><i>Object whose polarity needs to be changed</i></li>
	'<li>rev_polarity<font color="magenta"> - </font><i>Indicates whether to reverse polarity</i></li>
'</ul>

#if CELL__DEBUGPRINT_UDP_ISENABLED
	declare sub cell__init_debugprint_udp(byref primary_ip as string(CELL__16b_LEN), byref secondary_ip as string(CELL__16b_LEN), targetport as word)
	'<b>METHOD. </b><br><br>
	'Initializes UDP port for debug printing.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>primary_ip<font color="magenta"> - </font><i>Primary IP address to which debug messages are sent first</i></li>
		'<li>secondary_ip<font color="magenta"> - </font><i>Secondary IP address to which debug messages are sent if primary IP address is unreachable</i></li>
		'<li>targetport<font color="magenta"> - </font><i>UDP port being used by the target IP for cocmmunications</i></li>
	'</ul>
#endif

#if CELL__DEBUGPRINT_SERPORT_ISENABLED
declare sub cell__init_debugprint_ser()
'<b>METHOD. </b><br><br>
'Initializes a serial port for debug printing.
#endif

declare sub cell__init_ser()
'<b>METHOD. </b><br><br>
'Initializes serial-port related parameters and variables.
declare sub cell__deinit_ser()
'<b>METHOD. </b><br><br>
'De-initializes serial-port related parameters and variables.

#if CELL__PPP_MODE_ISENABLED
	declare sub cell__init_ppp()
	'<b>METHOD. </b><br><br>
	'Initializes the varables used for the PPP connection status check.<br><br>
	declare sub cell__deinit_ppp()
	'<b>METHOD. </b><br><br>
	'De-initializes PPP-related variables and parameters (including sockets).

'	declare sub cell__init_timestamps()
'	'<b>METHOD. </b><br><br>
'	'Initializes timestamps related to PPP uptime.
#endif


declare sub cell__modem_restart(next_pwr_phase as en_cell__op_pwr_phases)
'<b>METHOD. </b><br><br>
'Sets the required settings before initiating a modem-restart.
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
'</ul>

declare sub cell__reset_on(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
							next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
								next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Sets the RESET line to <font color="green">active</font>. <br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The RESET process consists of three stages:
'<ul>
	'<li><font color="goldenrod">cell__reset_on()</font></li>
	'<li>cell__reset_wait()</li>
	'<li>cell__reset_off()</li>
'</ul>

declare sub cell__reset_wait(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
								next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
									next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Waits for the connectivity hardware to turn <font color="tomato">off</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The RESET process consists of three stages:
'<ul>
	'<li>cell__reset_on()</li>
	'<li><font color="goldenrod">cell__reset_wait()</font></li>
	'<li>cell__reset_off()</li>
'</ul>

declare sub cell__reset_retry()
'<b>METHOD. </b><br><br>
'Retries to power the connectivity hardware <font color="green">on</font>/<font color="tomato">off</font> via reset.<br><br>

declare sub cell__reset_off(next_pwr_on_phase as en_cell__op_pwr_phases, next_pwr_off_phase as en_cell__op_pwr_phases, 
								next_at_phase as en_cell__op_at_phases, next_ppp_phase as en_cell__op_ppp_phases, 
									next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Sets the RESET line back to <font color="tomato">Inactive</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_on_phase<font color="magenta"> - </font><i>Next powering On phase (<font color="gray"> at which connectivity hardware should be turned On</font>)</i></li>
	'<li>next_pwr_off_phase<font color="magenta"> - </font><i>Next powering Off phase (<font color="gray">at which coonnectivbity hardware should be turned Off</font>)</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The RESET process consists of three stages:
'<ul>
	'<li>cell__reset_on()</li>
	'<li>cell__reset_wait()</li>
	'<li><font color="goldenrod">cell__reset_off()</font></li>
'</ul>

declare sub cell__shdn_off(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
							next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
								next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Powers <font color="tomato">off</font> the power regulator.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The SHDN process consists of three stages:
'<ul>
	'<li><font color="goldenrod">cell__shdn_off()</font></li>
	'<li>cell__shdn_wait()</li>
	'<li>cell__shdn_on()</li>
'</ul>

declare sub cell__shdn_wait(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
								next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
									next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Waits for the STATUS line to become <font color="tomato">inactive</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The SHDN process conists off three stages:
'<ul>
	'<li>cell__shdn_off()</li>
	'<li><font color="goldenrod">cell__shdn_wait()</font></li>
	'<li>cell__shdn_on()</li>
'</ul>

declare sub cell__shdn_retry()
'<b>METHOD. </b><br><br>
'Retries to power the connectivity hardware <font color="green">on</font>/<font color="tomato">off</font> via shutdown.<br><br>

declare sub cell__shdn_on(next_pwr_on_phase as en_cell__op_pwr_phases, next_pwr_off_phase as en_cell__op_pwr_phases, 
							next_at_phase as en_cell__op_at_phases, next_ppp_phase as en_cell__op_ppp_phases, 
								next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Powers <font color="green">on</font> the power regulator.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_on_phase<font color="magenta"> - </font><i>Next powering On phase (<font color="gray"> at which the connectivity hardware should be turned On</font>)</i></li>
	'<li>next_pwr_off_phase<font color="magenta"> - </font><i>Next powering Off phase (<font color="gray"> at which the connectivity hardware should be turned Off</font>)</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The SHDN process consists of three stages:
'<ul>
	'<li>cell__shdn_off()</li>
	'<li>cell__shdn_wait()</li>
	'<li><font color="goldenrod">cell__shdn_on()</font></li>
'</ul>

declare sub cell__pwrkey_on(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
								next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
									next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Sets power switch to <font color="green">on</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The PWRKEY process conists of three stages:
'<ul>
	'<li><font color="goldenrod">cell__pwrkey_on()</font></li>
	'<li>Minimum timeout (2 seconds)</li>
	'<li>cell__pwrkey_off()</li>
'</ul>	

declare sub cell__pwrkey_off(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
								next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
									next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Sets the power switch to <font color="tomato">off</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'<ul>
	'<li>cell__pwrkey_on()</li>
	'<li><font color="goldenrod">Minimum timeout (2 seconds)</font></li>
	'<li><font color="goldenrod">cell__pwrkey_off()</font></li>
'</ul>	

declare sub cell__pwrkey_retry()
'<b>METHOD. </b><br><br>
'Retries to power <font color="green">on</font>/<font color="tomato">off</font> the connectivity hardware via PWRKEY.<br><br>

declare sub cell__powering_onoff(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
										next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Provides notification on whether the connectivity hardware is powering <font color="green">on</font> or <font color="tomato">off</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The powering on/off process consists of two stages:
'<ul>
	'<li><font color="goldenrod">cell__powering_onoff()</font></li>
	'<li>cell__powering_onoff_wait()</li>
'</ul>	

declare sub cell__powering_onoff_wait(next_pwr_on_phase as en_cell__op_pwr_phases, next_pwr_off_phase as en_cell__op_pwr_phases, 
										next_at_phase as en_cell__op_at_phases, next_ppp_phase as en_cell__op_ppp_phases, 
											next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Waits for the STATUS line to change from <font color="green">active</font> to <font color="tomato">inactive</font> or vice-versa.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_on_phase<font color="magenta"> - </font><i>Next powering on phase (<font color="gray">at which the connectivity hardware should turn on</font>)</i></li>
	'<li>next_pwr_off_phase<font color="magenta"> - </font><i>Next powering off phase (<font color="gray"> at which the connectivity hardware should turn off</font>)</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>
'The power on/off process conists of two stages:
'<ul>
	'<li>cell__powering_onoff()</li>
	'<li><font color="goldenrod">cell__powering_onoff_wait()</font></li>
'</ul>

declare sub cell__check_rdy_state(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
										next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Checks and waits until the serial port is <font color="dodgerblue">RDY</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>

declare sub cell__modem_onoff(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
								next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
									next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Provides notification on whether the connectivity hardware is <font color="green">on</font> or <font color="tomato">off</font>.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>

declare sub cell__flush_all_data()
'<b>METHOD. </b><br><br>
'Flushes all garbage data.

declare sub cell__ser_port_flush_specified_amountOf_data(garbage_data_len as byte)
'<b>METHOD. </b><br><br>
'Flushes a specified amount of garbage data which are present in the serial-port.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>datalen<font color="magenta"> - </font><i>number of bytes to be flushed</i></li>
'</ul>
declare sub cell__ser_port_flush_all()
'<b>METHOD. </b><br><br>
'Flushes all data which are present in the serial-port.

declare sub cell__sock_release_all()
'<b>METHOD. </b><br><br>
'Releases all socks.

declare sub cell__sock_flush_all()
'<b>METHOD. </b><br><br>
'Flushes all data which are present in the sock.


declare sub cell__at_cmd_exec(byref atcmd as string, 
								next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
										next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'<font color="dodgerblue">Sends</font> AT command, and <font color="dodgerblue">gets</font> and <font color="dodgerblue">shows</font> AT reply.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>atcmd<font color="magenta"> - </font><i>Full AT command (<font color="dodgerblue">e.g., AT+NAME</font></i></li>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Set next POWER phase (<font color="gray">If not used, set to PHASE_PWR_DONOT_CHANGE</font>)</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Set next AT phase (<font color="gray">If not used, set to PHASE_AT_DONOT_CHANGE</font>)</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Set next PPP phase (<font color="gray">If not used, set to PHASE_PPP_DONOT_CHANGE</font>)</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Set next GPS phase (<font color="gray">If not used, set to PHASE_GPS_DONOT_CHANGE</font>)</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Set next parse phase (<font color="gray">If not used, set to PHASE_PARSE_DONOT_CHANGE</font>)</i></li>
'</ul>

declare sub cell__sleeptimer(sleeptime as word)
'<b>METHOD. </b><br><br>
'Waits for a specified number of seconds.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>sleeptime<font color="magenta"> - </font><i>waiting-time in seconds</i></li>
'</ul>

declare sub cell__at_send(atcmd as string)
'<b>METHOD. </b><br><br>
'Sends AT command.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>atcmd<font color="magenta"> - </font><i>Full AT command (<font color="dodgerblue">e.g. AT+CGMI</font>)</i></li>
'</ul>

declare sub cell__at_usermode_send(atcmd as string)
'<b>METHOD. </b><br><br>
'Sends AT command when in user mode.<br><br>
'<b>Input command:</b>
'<ul>
	'<li>atcmd<font color="magenta"> - </font><i>Full AT command (<font color="dodgerblue">e.g., AT+CGMI</font>)</i>
'</ul>

declare sub cell__at_parse_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
										next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Parses AT reply messages<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>

declare sub cell__at_get_cleandata(byref atreply_checkitem as string(CELL__16b_LEN))
'<b>METHOD. </b><br><br>
'Gets a clean AT reply message without leading AT command, CR, and LF.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>atreply_checkitem<font color="magenta"> - </font><i>Keyword contained in the AT-reply which is relevant when taking action</i></li>
'</ul>

declare sub cell__at_get_cleandata_filter(good_data_len as byte)
'<b>METHOD. </b><br><br>
'Retrieves only useful data and flushes all other (garbage) data.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>good_data_len<font color="magenta"> - </font><i>number of bytes to be retrieved</i></li>
'</ul>

declare sub cell__at_parse_message_retry(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
												next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Retries to send AT-command and parse AT-reply message.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
'</ul>

declare sub cell__at_get_voltage()
'<b>METHOD. </b><br><br>
'Gets the battery voltage.<br><br>

declare sub cell__at_send_multiple_commands_without_timeout(byref atcmd as string, numOf_times as byte,
																next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
																	next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
																		next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Repeatedly sends an AT command a specified number of times.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>atcmd - <i>Full AT command (e.g., <font color="dodgerblue">AT+NAME</font>)</i></li>
	'<li>numOf_times - <i>Number of times specified AT command will be sent</i></li>
	'<li>next_pwr_phase - <i>Set next POWER phase (<font color="gray">If not used, set to PHASE_PWR_DONOT_CHANGE</font>)</i></li>
	'<li>next_at_phase - <i>Set next AT phase (<font color="gray">If not used, set to PHASE_AT_DONOT_CHANGE</font>)</i></li>
	'<li>next_ppp_phase - <i>Set next PPP phase (<font color="gray">If not used, set to PHASE_PPP_DONOT_CHANGE</font>)</i></li>
	'<li>next_gps_phase - <i>Set next GPS phase (<font color="gray">If not used, set to PHASE_GPS_DONOT_CHANGE</font>)</i></li>
	'<li>next_parse_phase - <i>Set next parse phase (<font color="gray">If not used, set to PHASE_PARSE_DONOT_CHANGE</font>)</i></li>
'</ul>

#if CELL__PPP_MODE_ISENABLED
	declare sub cell__ppp_at_cgpaddr_retrieve_ip()
	'<b>METHOD. </b><br><br>
	'Gets the PPP remote IP address via the <font color="dodgerblue">AT+CGPADDR</font> command.</li>

	declare function cell__ppp_generate_fcs(byref ppp_packet_format as string(CELL__128b_LEN)) as word
	'<b>METHOD. </b><br><br>
	'Generates an FCS based on the input value. For the generation of an FCS, the <font color="dodgerblue">CRC-16-CCITT 0x8408</font> polynomial is used<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>ppp_packet_format<font color="magenta"> - </font><i>PPP Packet Format (<font color="gray">including Address, Control, Protocol, and Information fields</font>)</i></li>
	'</ul>

	declare sub cell__ppp_append_fcs(byref ppp_packet_format as string(CELL__128b_LEN), fcs as word)
	'<b>METHOD. </b><br><br>
	'Appends the generated FCS to the PPP packet format.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>ppp_packet_format<font color="magenta"> - </font><i>PPP Packet Format (<font color="gray">including Address, Control, Protocol, and Information fields</font>)</i></li>
		'<li>fcs<font color="magenta"> - </font><i>Frame Check Sequence that is to be appended to the PPP packet format</i></li>
	'</ul>

	declare sub cell__ppp_insert_escapechar(byref ppp_packet_format as string)
	'<b>METHOD. </b><br><br>
	'Inserts an escape character <font color="dodgerblue">0x7D</font> in the following situations:
	'<ul>
		'<li>chr(0x7E) is replaced as: <i>chr(0x7D) + chr(0x5E)</i></li>
		'<li>chr(0x7D) is replaced as: <i>chr(0x7D) + chr(0x5D)</i></li>
		'<li>Any <font color="tomato">char</font> with hex < 0x20 is replaced as: <i>chr(0x7D) + chr( asc(<font color="tomato">char</font>) XOR 0x20 )</i></li>
	'</ul>
	'<b>Input parameters:</b>
	'<ul>
		'<li>ppp_packet_format<font color="magenta"> - </font><i>PPP packet format (<font color="gray">including Address, Control, Protocol, and Information fields</font>)</i></li>
	'</ul>

	declare sub cell__ppp_increment_id()
	'<b>METHOD. </b><br><br>
	'Increments the identifier.<br><br>

	declare sub cell__ppp_send_data(ppp_protocol as word, ppp_code as en_cell__op_ppp_codes, ppp_sender_id as byte, byref data_packet_format as string,
										next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, 
												next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Sends a PPP packet in the following format.<br>
	'+------+------------+-----------+-----------+---------------------------+-------+------+<br>
	'| Flag |  Address   |  Control  | Protocol  | &nbsp; &nbsp; &nbsp; &nbsp; Information &nbsp; &nbsp; &nbsp; |  FCS  | Flag |<br>
	'+------+------------+-----------+-----------+---------------------------+-------+------+<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>ppp_protocol<font color="magenta"> - </font><i>Protocol type (<font color="gray">e.g., LCP: 0xC021</font>)</i></li>
		'<li>ppp_code<font color="magenta"> - </font><i>Code field (<font color="gray">e.g., CONFREQ, CONFACK, etc.</font>)</i></li>
		'<li>ppp_id<font color="magenta"> - </font><i>Sequence number or identifier field (<font color="gray">e.g., for CONFREQ usually begins with 0x01 and increments by 1</font>)</i></li>
		'<li>data_packet_format<font color="magenta"> - </font><i>Data packet (<font color="gray">e.g., CONFREQ, CONFACK, etc.</font>)</i></li>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>

	declare sub cell__ppp_ipcp_send_confreq(ppp_protocol as word, ppp_code as en_cell__op_ppp_codes, ppp_sender_id as byte, byref data_packet_format as string(CELL__128b_LEN),
												next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
													next_ppp_phase as en_cell__op_ppp_phases, 
														next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Generates and sends the IPCP CONFREQ data.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>ppp_protocol<font color="magenta"> - </font><i>Protocol type (<font color="gray">e.g., LCP: 0xC021</font>)</i></li>
		'<li>ppp_code<font color="magenta"> - </font><i>Code field (<font color="gray">e.g., CONFREQ, CONFACK, etc.</font>)</i></li>
		'<li>ppp_id<font color="magenta"> - </font><i>Sequence number or identifier field (<font color="gray">e.g., for CONFREQ usually begins with 0x01 and increments by 1</font>)</i></li>
		'<li>data_packet_format<font color="magenta"> - </font><i>Data packet (<font color="gray">e.g., CONFREQ, CONFACK, etc.</font>)</i></li>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>

	declare function cell__ppp_ping_generate_checksum(byref icmp_packet_format as string(CELL__32b_LEN), icmp_isSent as boolean) as dword
	'<b>METHOD. </b><br><br>
	'Generates 'Frame Check Sequence.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>icmp_packet_format<font color="magenta"> - </font><i>ICMP Message Format</i></li>
		'<li>icmp_isSent<font color="magenta"> - </font><i>boolean to indicate whether ICMP is <font color="green">sent</font> or <font color="tomato">received</font>)</i></li>
	'</ul>
	
	declare sub cell__ppp_ping_insert_checksum(byref icmp_packet_format as string(CELL__32b_LEN), fcs as dword)
	'<b>METHOD. </b><br><br>
	'Overwrites the Checksum with the generated Frame Check Sequence.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>icmp_packet_format<font color="magenta"> - </font><i>ICMP Message Format</i></li>
	'</ul>
	
	declare sub cell__ppp_ping_send(ppp_protocol as word, ppp_code as en_cell__op_ppp_codes, ppp_sender_id as byte, byref icmp_packet_format as string(CELL__32b_LEN),
										next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, 
												next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Sends a ping from Source IP to Destination IP.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>ppp_protocol<font color="magenta"> - </font><i>Protocol type (<font color="gray">e.g., IP: 0x0021</font>)</i></li>
		'<li>ppp_code<font color="magenta"> - </font><i>Code field (<font color="gray">e.g., 0)</i></li>
		'<li>ppp_sender_id<font color="magenta"> - </font><i>Sequence number or identifier field (<font color="gray">e.g., 0</font>)</i></li>
		'<li>icmp_packet_format<font color="magenta"> - </font><i>ICMP Message Format</i></li>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>
	
	declare sub cell__ppp_substitute_data(byref sender_data as string(CELL__128b_LEN), 
									byref peer_data as string(CELL__128b_LEN), 
										code as en_cell__op_ppp_codes)
	'<b>METHOD. </b><br><br>
	'Replaces one data value (<font color="gray">e.g., CHAP: 0x0304 C223</font>) with another (<font color="gray">e.g., PAP: 0x0304 C023</font>).<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>ppp_sender_data<font color="magenta"> - </font><i>Sender's data packet (<font color="gray">config options + data length + data content</font>)</i></li>
		'<li>ppp_peer_data<font color="magenta"> - </font><i>Peer's data (<font color="gray">config options + data length + data content</font>)</i></li>
		'<li>ppp_code<font color="magenta"> - </font><i>Code value (<font color="gray">e.g., CONFREQ, CONFNAK, CONFREJ, etc.</font>)</i></li>
	'</ul
	
	declare sub cell__ppp_parse_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
												next_ppp_phase as en_cell__op_ppp_phases,
													next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Parses and processes a message received from peer.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>

	declare function cell__ppp_parse_message_func() as string(CELL__128b_LEN)
	'<b>METHOD. </b><br><br>
	'Parses a received PPP message and outputs <font color="dodgerblue">cell__reply</font>. Parsing process is as follows:
	'<ul>
		'<li>Strips off prepended and appended <font color="dodgerblue">flags</font> characters</li>
		'<li>Strips off <font color="dodgerblue">ESC</font> characters</li>
		'<li>Replaces <font color="tomato">0x5E</font> with <font color="green">0x7E</font></li>
		'<li>Replaces <font color="tomato">0x5D</font> with <font color="green">0x7D</font></li>
		'<li><font color="dodgerblue">XORs</font> characters other than those mentioned above</li>
		'<li>Generates and checks the FCS of replied PPP message</li>
		'<li>Strips off <font color="dodgerblue">FCS</font></li>
		'<li>Checks whether <font color="dodgerblue">address</font> characters (<font color="gray">0xFF</font>) or <font color="dodgerblue">control</font> characters (<font color"gray">0x03</font>) are present in the replied PPP message</li>
		'<li>Strips off <font color="dodgerblue">address</font> and <font color="dodgerblue">control</font> fields</li>
	'</ul>

	declare sub cell__ppp_parse_message__retry()
	'<b>METHOD. </b><br><br>
	'Retries to parse a received message.
	
	declare sub cell__ppp_proc_parsed_lcp_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
													next_ppp_phase as en_cell__op_ppp_phases,
														next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Processes received LCP parse messages.<br><br>
	'<b>Input args:</b>
	'<ul>
		'<li>next_pwr_phase: <i>next POWER phase</i>
		'<li>next_at_phase: <i>next AT phase</i>
		'<li>next_ppp_phase: <i>next PPP phase</i>
		'<li>next_gps_phase: <i>next GPS phase</i>
		'<li>next_parse_phase: <i>next parse phase</i>
	'</ul>

	declare function cell__ppp_proc_parsed_lcp_confreq_message_result(byref parsed_message as string, byref confrej_str as string) as en_cell__op_ppp_sender_codes
	'<b>METHOD. </b><br><br>
	'Processes a parsed LCP CONFREQ message.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>parsed_message<font color="magenta"> - </font><i>Parsed message to be analyzed</i></li>
		'<li>confrej_str<font color="magenta"> - </font><i>Collected CONFREJ data (<font color="gray">Note: This is an output parameter</font>)</i></li>
	'</ul>
	
	declare sub cell__ppp_proc_parsed_lcp_message_confack_handler(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
																	next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
																		next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Handles the processes upon a CONFACK.<br><br>
	'<b>Input args:</b>
	'<ul>
		'<li>next_pwr_phase: <i>next POWER phase</i>
		'<li>next_at_phase: <i>next AT phase</i>
		'<li>next_ppp_phase: <i>next PPP phase</i>
		'<li>next_gps_phase: <i>next GPS phase</i>
		'<li>next_parse_phase: <i>next parse phase</i>
	'</ul>
	'<b>Remarks:</b><br><br>
	'It is possible to fast send & receive by enabling boolean <span style="color: dodgerblue;">CELL__PPP_FAST_LOAD</span>.<br><br>
	
	declare sub cell__ppp_proc_parsed_pap_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
												next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Processes received PAP parse messages.<br><br>
	'<b>Input args:</b>
	'<ul>
		'<li>next_pwr_phase: <i>next POWER phase</i>
		'<li>next_at_phase: <i>next AT phase</i>
		'<li>next_ppp_phase: <i>next PPP phase</i>
		'<li>next_gps_phase: <i>next GPS phase</i>
		'<li>next_parse_phase: <i>next parse phase</i>
	'</ul>
	
	declare sub cell__ppp_proc_parsed_ipcp_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
													next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
														next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Processes received IPCP parse messages.<br><br>
	'<b>Input args:</b>
	'<ul>
		'<li>next_pwr_phase: <i>next POWER phase</i>
		'<li>next_at_phase: <i>next AT phase</i>
		'<li>next_ppp_phase: <i>next PPP phase</i>
		'<li>next_gps_phase: <i>next GPS phase</i>
		'<li>next_parse_phase: <i>next parse phase</i>
	'</ul>

	declare function cell__ppp_proc_parsed_ipcp_confreq_message_result(byref parsed_message as string(CELL__128b_LEN), 
															code as en_cell__op_ppp_codes, 
																byref confrej_str as string) as en_cell__op_ppp_sender_codes
	'<b>METHOD. </b><br><br>
	'Processes a parsed IPCP CONFREQ message.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>parsed_message<font color="magenta"> - </font><i>Parsed message to be analyzed</i></li>
		'<li>confrej_str<font color="magenta"> - </font><i>Collected CONFREJ data (<font color="gray">Note: This is an output parameter</font>)</i></li>
	'</ul>
	
	declare sub cell__ppp_proc_parsed_ipcp_message_confack_handler(ppp_peer_data as string, next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
																	next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
																		next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Handles the processes upon a CONFACK.<br><br>
	'<b>Input args:</b>
	'<ul>
		'<li>next_pwr_phase: <i>next POWER phase</i>
		'<li>next_at_phase: <i>next AT phase</i>
		'<li>next_ppp_phase: <i>next PPP phase</i>
		'<li>next_gps_phase: <i>next GPS phase</i>
		'<li>next_parse_phase: <i>next parse phase</i>
	'</ul>
	'<b>Remarks:</b><br><br>
	'It is possible to fast send & receive by enabling boolean <span style="color: dodgerblue;">CELL__PPP_FAST_LOAD</span>.<br><br>>

	declare sub cell__ppp_proc_parsed_ping_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
													next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
														next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Processes a parsed ICMP message.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>

	declare sub cell_ppp_enable()
	'<b>METHOD. </b><br><br>
	'Enables PPP and sets all phases to IDLE-mode.
	
	declare sub cell__ppp_link_to_tower()
	'<b>METHOD. </b><br><br>
	'Links to the Tower and sends a call-back.
	

	declare sub cell__ppp_connection_status(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
										next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD </b><br><br>
	'Checks the PPP connection by trying to connect to a specific server.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>

'	declare sub cell__combine_uptime_and_lost_conn(byref uptime as string, lost_conn as word)
	'<b>METHOD. </b><br><br>
	'Combines the PPP connection uptime and number of failed connections.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>uptime<font color="magenta"> - </font><i>PPP connection uptime in {days, hr, min, sec}</i></li>
		'<li>lost_conn<font color="magenta"> - </font><i>Number of failed connection attempts to a server</i></li>
	'</ul>

	declare sub cell__ppp_check_connection_status(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
												next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Connects to a specified server.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>
#endif


#if CELL__GPS_MODE_ISENABLED
	declare sub cell__gps_parse_message()
	'<b>METHOD. </b><br><br>
	'Gets and shows AT reply.

	declare sub cell__gps_get_position(byref inputdata as string)
	'<b>METHOD. </b><br><br>
	'Extracts the latitude and longitude from the data.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>inputdata<font color="magenta"> - </font><i>Data to be parsed</i></li>
	'</ul>	
#endif



declare sub cell__at_usermode_cmd_input(byref atcmd as string)
'<b>METHOD. </b><br><br>
'Gather AT command input.
	
declare sub cell__at_usermode_get_cmd_fifo()
'<b>METHOD. </b><br><br>
'Gets the oldest AT command first.

declare sub cell__at_usermode_go_into_idle(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
												next_parse_phase as en_cell__op_parse_phases)
'<b>METHOD. </b><br><br>
'Initializes AT manual command mode-related variables and parameters.<br><br>
'<b>Input parameters:</b>
'<ul>
	'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
	'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
	'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
	'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
	'<li>next_parse_phase<font color="magenta"> - </font><i>Next Parse phase</i></li>
'</ul>

#if CELL__AT_USERMODE_ISENABLED
	declare sub cell__at_notification(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
										next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
											next_parse_phase as en_cell__op_parse_phases)
	'<b>METHOD. </b><br><br>
	'Notifies that AT manual command mode is enabled.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>next_pwr_phase<font color="magenta"> - </font><i>Next POWER phase</i></li>
		'<li>next_at_phase<font color="magenta"> - </font><i>Next AT phase</i></li>
		'<li>next_ppp_phase<font color="magenta"> - </font><i>Next PPP phase</i></li>
		'<li>next_gps_phase<font color="magenta"> - </font><i>Next GPS phase</i></li>
		'<li>next_parse_phase<font color="magenta"> - </font><i>Next parse phase</i></li>
	'</ul>
	declare sub cell__at_usermode_sms_send(byref phonenumber as string(CELL__16b_LEN), byref sms_message_total as string, 
											byref csmp_fo as string(CELL__16b_LEN), byref csmp_vp as string(CELL__16b_LEN), 
												byref csmp_pid as string(CELL__16b_LEN), byref csmp_dcs as string(CELL__16b_LEN))
	'<b>METHOD. </b><br><br>
	'Sends SMS messages to a specified phone-number.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>phonenumber<font color="magenta"> - </font><i>phone-number to sent the SMS-message to</i></li>
		'<li>sms_message_total<font color="magenta"> - </font><i>SMS-message to-be sent (max. 255 chars long)</i></li>
		'<li>csmp_fo<font color="magenta"> - </font><i>GSM First Octet</i></li>
		'<li>csmp_vp<font color="magenta"> - </font><i>GSM Validy Period</i></li>
		'<li>csmp_pid<font color="magenta"> - </font><i>Protocol Identifier</i></li>
		'<li>csmp_dcs<font color="magenta"> - </font><i>Data Coding Scheme</i></li>
	'</ul>	
	
	declare sub cell__at_usermode_sms_receive(byref cpms_mem1_stor_type as string(CELL__2b_LEN), 
												byref cpms_mem2_stor_type as string(CELL__2b_LEN),
													byref cpms_mem3_stor_type as string(CELL__2b_LEN),
														byref cnmi_mode as string(CELL__1b_LEN),
															byref cnmi_mt as string(CELL__1b_LEN))
	'<b>METHOD. </b><br><br>
	'Receives SMS messages.<br><br>
	'<b>Input parameters:</b>
	'<ul>
		'<li>cpms_mem1_stor_type<font color="magenta"> - </font><i>Memory for Reading and Deleting messages</i></li>
		'<li>cpms_mem2_stor_type<font color="magenta"> - </font><i>Memory for Writing and Sending messages</i></li>
		'<li>cpms_mem3_stor_type<font color="magenta"> - </font><i>Memory for Receiving messages</i></li>
		'<li>cnmi_mode<font color="magenta"> - </font><i>Rule for unsolicited result codes handling</i></li>
		'<li>cnmi_mt<font color="magenta"> - </font><i>Rule for storing received SMS</i></li>
	'</ul>
	
	declare sub cell__at_usermode_sms_parse()
	'<b>METHOD. </b><br><br>
	'Parses at-reply SMS messages.<br><br>
	
#endif

declare sub cell__proc_sys_timer()
'<b>METHOD. </b><br><br>
'Checks and handles <font color="dodgerblue">processes</font> periodically.
declare sub cell__isretry_inprogr_in_idlemode()
'<b>METHOD. </b><br><br>
'Checks whether there are any retries in progress while in IDLE-mode.
declare function cell__retry_in_progress() as boolean
'<b>METHOD. </b><br><br>
'Checks whether there are any retries in progress.
declare function cell__all_phases_are_idle() as boolean
'<b>METHOD. </b><br><br>
'Checks whether all the phases are set to IDLE.
declare sub cell__on_ser_data_arriv_not_trigg()
'<b>METHOD. </b><br><br>
'Checks whether on-ser-data-arrival is NOT triggered.

declare sub cell__pwr_proc_sys_timer()
'<b>METHOD. </b><br><br>
'Checks and handles <font color="dodgerblue">power processes</font> periodically.

declare sub cell__at_proc_sys_timer()
'<b>METHOD. </b><br><br>
'Checks and handles <font color="dodgerblue">AT processes</font> periodically.

declare sub cell__ppp_proc_sys_timer()
'<b>METHOD. </b><br><br>
'Checks and handles <font color="dodgerblue">PPP processes</font> periodically.

declare sub cell__gps_proc_sys_timer()
'<b>METHOD. </b><br><br>
'Checks and handles <font color="dodgerblue">GPS processes</font> periodically.

declare sub cell__proc_on_ser_data_arrival()
'<b>METHOD. </b><br><br>
'Processes data arriving via the data serial port.
