include "global.tbh"

'CONSTANTS-----------------------------------------------------------
#if CELL__DEBUGPRINT_UDP_ISENABLED
    const CELL__UDP_TARGET_PRIMARY_IP = "192.168.1.64"
    const CELL__UDP_TARGET_SECOND_IP = "192.168.1.17"
    const CELL__UDP_TARGET_PORT = "6559"
#endif

const CELL_INIT_SIGNATURE=&h1689

'DEFINES-------------------------------------------------------------

dim cell__init_flag as word = 0
dim cell__udp_tx_socknum as byte

dim cell__modem_restart_retry_param as byte = 0	'number of modem restart after a specified number of failed attempts to execute an AT-command
dim cell__pwrkey_retry_param as byte = 0	'number of poweron retries using PWRKEY
dim cell__reset_retry_param as byte = 0	'number of reset retries using RESET
dim cell__shdn_retry_param as byte = 0	'number of shutdown retries using SHDN
dim cell__isretry_inprogr_in_idlemode_retry_param as byte = 0	'modem is in retry-mode, but all phases are set to IDLE
dim cell__on_ser_data_arriv_not_trigg_retry_param as byte = 0	'modem is in retry-mode, but all phases are set to IDLE
dim cell__at_retry_param as byte = 0	'number of AT parse message retries
dim cell__at_cmd_exec_retry_param as byte = 0	'number of AT command execution retries

dim cell__at_retry_parse_max as byte
dim cell__at_retry_exec_and_parse_max as byte

dim cell__at_cgreg_dblchk_isEnabled as boolean = false

dim cell__status_revpol as no_yes
dim cell__pwrkey_revpol as no_yes
dim cell__reset_revpol as no_yes
dim cell__shdn_revpol as no_yes
dim cell__pwr_object_state as string(CELL__32b_LEN)

dim cell__status_setto_on as low_high
dim cell__status_setto_off as low_high
dim cell__pwrkey_setto_on as low_high
dim cell__pwrkey_setto_off as low_high
dim cell__reset_setto_on as low_high
dim cell__reset_setto_off as low_high
dim cell__shdn_setto_on as low_high
dim cell__shdn_setto_off as low_high

dim cell__op_pwr_phase as en_cell__op_pwr_phases
dim cell__op_at_phase_bck as en_cell__op_at_phases
dim cell__op_at_phase as en_cell__op_at_phases
dim cell__op_ppp_phase as en_cell__op_ppp_phases
dim cell__op_ppp_phase_bck as en_cell__op_ppp_phases
dim cell__op_gps_phase as en_cell__op_gps_phases
dim cell__op_parse_phase as en_cell__op_parse_phases

dim cell__modem_init_startup as boolean = true	'variable is NOT initialized anywhere (default: true)
dim cell__attempt_to_free_buffpages_via_modem_reset as boolean = false

dim cell__modem_restart_isTrigg as boolean = false
dim cell__modem_stop_is_already_Trigg as boolean = false

dim cell__sim7000_isDetected as boolean = false

dim cell__uptime as word
dim cell__starttime as word
dim cell__newtime as word
dim cell__elapsedtime as word

dim cell__isretry_starttime as word
dim cell__isretry_newtime as word
dim cell__isretry_elapsedtime as word

dim cell__on_ser_data_starttime as word
dim cell__on_ser_data_newtime as word
dim cell__on_ser_data_elapsedtime as word

dim cell__cgreg_starttime as word
dim cell__cgreg_newtime as word
dim cell__cgreg_elapsedtime as word

dim cell__ppp_starttime as word
dim cell__ppp_newtime as word
dim cell__ppp_elapsedtime as word

'dim cell__timeout_has_exceeded as boolean

dim cell__startstate as low_high
dim cell__newstate as low_high

dim cell__ser_port_isRdy as boolean

dim cell__at_cmd as string
dim cell__at_cgpaddr_ip as string(CELL__32b_LEN)

dim cell__reply as string
dim cell__rxlen as word	'receive buffer length

dim cell__apn as string(CELL__16b_LEN)
dim cell__username as string(CELL__16b_LEN)	'PAP username
dim cell__password as string(CELL__16b_LEN)	'PAP password
dim cell__pap_credentials as string(CELL__32b_LEN)	'PAP username and password
dim cell__pin as string(CELL__16b_LEN)

#if CELL__PPP_MODE_ISENABLED
    dim cell__ppp_retry_param as byte = 0	'number of PPP parse retries
    dim cell__https_retry_param as byte = 0	'number of connection to https server retries

    dim cell__ts_daycount as dword
    dim cell__ts_hrcount as byte
    dim cell__ts_mincount as byte
    dim cell__ts_seccount as word

    dim cell__https_server as en_cell__op_https_servers
    dim cell__serverip as string(CELL__16b_LEN)
    dim cell__serverport as string(CELL__6b_LEN)
    dim cell__servername_ip as string(CELL__32b_LEN)
    dim cell__servername as string(CELL__6b_LEN)

    dim cell__ppp_conn_uptime as string(CELL__64b_LEN)
    dim cell__ppp_numof_lost_conn as word = 0	'variable is NOT initialized anywhere (default: 0)

    dim cell__ppp_sender as string(CELL__128b_LEN)	'PPP Packet Format (<span style="color: gray;">Code + Identifier + Length + Data Field</span>)
    dim cell__ppp_confrej_str as string(CELL__128b_LEN)	'rejected data
    dim cell__ppp_sender_id as byte	'Identifier used by the sender in a CONFREQ
    dim cell__ppp_pap_isRequired as boolean
    dim cell__ppp_sender_confreq_isAck as boolean
    dim cell__ppp_peer_confreq_isAck as boolean
    dim cell__ppp_peer_ip as string(CELL__4b_LEN)	'remote ip-address to be used by the peer
    dim cell__ppp_sender_ip as string(CELL__4b_LEN)	'remote ip-address to be used by the sender
	
	dim cell__ppp_ping_reply as ok_ng
	
'    dim cell__sock_id  as string(CELL__6b_LEN)
#endif

#if CELL__GPS_MODE_ISENABLED
    dim cell__gps_siv_data as string(CELL__128b_LEN)	'Satellite in View
    dim cell__gps_pos_data as string(CELL__128b_LEN)	'GPS Position
    dim cell__gps_latitude as float
    dim cell__gps_longitude as float
#endif

#if CELL__AT_USERMODE_ISENABLED
	dim cell__phonenumber as string(CELL__16b_LEN)
	dim cell__csmp_fo as string(CELL__16b_LEN)
	dim cell__csmp_vp as string(CELL__16b_LEN)
	dim cell__csmp_pid as string(CELL__16b_LEN)
	dim cell__csmp_dcs as string(CELL__16b_LEN)

	dim cell__cmgf_type as string (CELL__1b_LEN)
	dim cell__cpms_mem1_stor_type as string(CELL__2b_LEN)
	dim cell__cpms_mem2_stor_type as string(CELL__2b_LEN)
	dim cell__cpms_mem3_stor_type as string(CELL__2b_LEN)
	dim cell__cnmi_mode as string (CELL__1b_LEN)
	dim cell__cnmi_mt as string (CELL__1b_LEN)

	dim cell__parse_sms_message_phase_isON as boolean

	dim cell__sms_msg_inputmode_isOn as boolean = false
#endif

dim cell__at_cmd_storArray(CELL__ARRAY_LEN) as string	'array with 4 pages (<span style="color: gray;">1 page = 256 Bytes</span>)
dim cell__at_cmd_storArray_index as byte
dim cell__at_cmd_storArray_numof_cmds as word


'MACROS--------------------------------------------------------------
#ifndef CELL__MODEM_STATUS	
    #define CELL__MODEM_STATUS io.lineget(CELL__STATUS_LINENUM)	'get STATUS current line state
#endif

#ifndef CELL__SET_RESET_ON
    #define CELL__SET_RESET_ON io.lineset(CELL__RESET_LINENUM, cell__reset_setto_on)	'set RESET line to Active
#endif
#ifndef CELL__SET_RESET_OFF
    #define CELL__SET_RESET_OFF io.lineset(CELL__RESET_LINENUM, cell__reset_setto_off)	'set RESET line to Inactive
#endif

#ifndef CELL__SET_SHDN_ON
    #define CELL__SET_SHDN_ON io.lineset(CELL__SHDN_LINENUM, cell__shdn_setto_on)	'set SHDN line to Active
#endif
#ifndef CELL__SET_SHDN_OFF
    #define CELL__SET_SHDN_OFF io.lineset(CELL__SHDN_LINENUM, cell__shdn_setto_off)	'set SHDN line to Inactiveh
#endif

#ifndef CELL__SET_PWRKEY_ON
    #define CELL__SET_PWRKEY_ON io.lineset(CELL__PWRKEY_LINENUM, cell__pwrkey_setto_on)	'set PWRKEY line to Inactive
#endif
#ifndef CELL__SET_PWRKEY_OFF
    #define CELL__SET_PWRKEY_OFF io.lineset(CELL__PWRKEY_LINENUM, cell__pwrkey_setto_off)	'set PWRKEY line to Inactive
#endif

#ifndef CELL__PWRKEY_STATE
    #define CELL__PWRKEY_STATE io.lineget(CELL__PWRKEY_LINENUM)	'get STATUS current line state
#endif
#ifndef CELL__RESET_STATE
    #define CELL__RESET_STATE io.lineget(CELL__RESET_LINENUM)	'get STATUS current line state
#endif
#ifndef CELL__SHDN_STATE
    #define CELL__SHDN_STATE io.lineget(CELL__SHDN_LINENUM)	'get STATUS current line state
#endif

#ifndef CELL__AT_REPLIED_WITH_RDY
    #define CELL__AT_REPLIED_WITH_RDY ( instr(1, ser.getdata(255), CELL__RDY_CRLF, 1) <> 0 )	
#endif	
#ifndef CELL__AT_REPLIED_WITH_CGREG_0_1
    #define CELL__AT_REPLIED_WITH_CGREG_0_1 ( instr(1, cell__reply, CELL__CGREG_0_1, 1) <> 0 )
#endif
#ifndef CELL__AT_REPLIED_WITH_CGREG_ANY
    #define CELL__AT_REPLIED_WITH_CGREG_ANY ( instr(1, cell__reply, CELL__CGREG_ANY, 1) <> 0 )
#endif
#ifndef CELL__AT_REPLIED_WITH_SIM7000
    #define CELL__AT_REPLIED_WITH_SIM7000 ( instr(1, cell__reply, CELL__SIM7000, 1) <> 0 )
#endif

#ifndef CELL__AT_CMD_CONTAINS_CPIN
    #define CELL__AT_CMD_CONTAINS_CPIN ( instr(1, cell__at_cmd, CELL__AT_CPIN_Q, 1) <> 0 )
#endif

#ifndef CELL__AT_CMD_CONTAINS_CGREG
    #define CELL__AT_CMD_CONTAINS_CGREG ( instr(1, cell__at_cmd, CELL__AT_CGREG_Q, 1) <> 0 )
#endif

#ifndef CELL__AT_CMD_CONTAINS_CGPADDR
    #define CELL__AT_CMD_CONTAINS_CGPADDR ( instr(1, cell__at_cmd, CELL__AT_CGPADDR, 1) <> 0 )
#endif

#ifndef CELL__AT_CMD_CONTAINS_CBC
    #define CELL__AT_CMD_CONTAINS_CBC ( instr(1, cell__at_cmd, CELL__AT_CBC, 1) <> 0 )
#endif



#ifndef CELL__AT_CMD_CONTAINS_CMGS
    #define CELL__AT_CMD_CONTAINS_CMGS ( instr(1, cell__at_cmd, CELL__CMGS, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_SUBSTITUTE_CHAR
    #define CELL__AT_CMD_CONTAINS_SUBSTITUTE_CHAR ( instr(1, cell__at_cmd, CELL__SUBSTITUTE, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_CNMI
    #define CELL__AT_CMD_CONTAINS_CNMI ( instr(1, cell__at_cmd, CELL__AT_CNMI, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_CMGR
    #define CELL__AT_CMD_CONTAINS_CMGR ( instr(1, cell__at_cmd, CELL__AT_CMGR, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_CMGD
    #define CELL__AT_CMD_CONTAINS_CMGD ( instr(1, cell__at_cmd, CELL__AT_CMGD, 1) <> 0 )
#endif

#ifndef CELL__AT_CMD_CONTAINS_AT_PLUS
    #define CELL__AT_CMD_CONTAINS_AT_PLUS ( instr(1, cell__at_cmd, CELL__AT_PLUS, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_PLUS
    #define CELL__AT_CMD_CONTAINS_PLUS ( instr(1, cell__at_cmd, CELL__PLUS, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_AT
    #define CELL__AT_CMD_CONTAINS_AT ( instr(1, cell__at_cmd, CELL__AT, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_ATE1
    #define CELL__AT_CMD_CONTAINS_ATE1 ( instr(1, cell__at_cmd, CELL__ATE1, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_TRIPLEPLUS
    #define CELL__AT_CMD_CONTAINS_TRIPLEPLUS ( instr(1, cell__at_cmd, CELL__TRIPLEPLUS, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_ATO
    #define CELL__AT_CMD_CONTAINS_ATO ( instr(1, cell__at_cmd, CELL__ATO, 1) <> 0 )
#endif

#ifndef CELL__AT_CMD_CONTAINS_AT_AMPERSAND_E1
    #define CELL__AT_CMD_CONTAINS_AT_AMPERSAND_E1 ( instr(1, cell__at_cmd, CELL__AT_AMPERSAND_E1, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_AT_AMPERSAND_C0
    #define CELL__AT_CMD_CONTAINS_AT_AMPERSAND_C0 ( instr(1, cell__at_cmd, CELL__AT_AMPERSAND_C0, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_AT_CPSMS_0
    #define CELL__AT_CMD_CONTAINS_AT_CPSMS_0 ( instr(1, cell__at_cmd, CELL__AT_CPSMS_0, 1) <> 0 )
#endif
#ifndef CELL__AT_CMD_CONTAINS_AT_AMPERSAND_D0
    #define CELL__AT_CMD_CONTAINS_AT_AMPERSAND_D0 ( instr(1, cell__at_cmd, CELL__AT_AMPERSAND_D0, 1) <> 0 )
#endif

#ifndef CELL__SER_PORT_NUM_IS_CORRECT
    #define CELL__SER_PORT_NUM_IS_CORRECT (ser.num = CELL__DATA_SER_PORT)
#endif

#ifndef CELL__SIM_MODEL_IS_7000
    #define CELL__SIM_MODEL_IS_7000 ( cell__sim7000_isDetected = true )
#endif


#if CELL__DEBUG_PRINT
    declare sub cell__debugprint(byref print_data as string)
	
	
    sub cell__debugprint(byref print_data as string)
	'Print out message
        #if CELL__DEBUGPRINT_SERPORT_ISENABLED 
            cell__debugprint_thru_serport(print_data)
            #else
            #if CELL__DEBUGPRINT_UDP_ISENABLED
                cell__debugprint_thru_udp(print_data)
                #else
                sys.debugprint(print_data + CELL__CRLF)
            #endif
        #endif
    end sub
#endif


'START FUNCTION------------------------------------------------------
function cell__start(byref pin as string(CELL__16b_LEN), byref apn as string, 
						byref username as string, byref password as string) as en_cell__status_phases

	if cell__init_flag=CELL_INIT_SIGNATURE then
		#if CELL__DEBUG_PRINT=1
			cell__debugprint("library already initialized.")
		#endif
		exit function
	end if

	cell__init_flag=CELL_INIT_SIGNATURE

	'Assign values
    cell__apn = apn
    cell__username = username
    cell__password = password
    cell__pap_credentials = chr(len(cell__username)) + cell__username + chr(len(cell__password)) + cell__password
	
	'Set pin-code
    cell__pin = pin

	'Reset boolean
	cell__modem_stop_is_already_Trigg = false
	

	'Check if allocated buffer-size is sufficient
    if cell__buffersize_isSufficient() = true then	'allocated buffer-size is sufficient
		'OUTPUT
		cell__start = CELL__START_INITIATED

		'Choose next-phase = cell__op_pwr_phase
		if (cell__modem_restart_isTrigg = false) then	'for all other cases (EXCEPT for a modem-restart)
			cell__op_pwr_phase = PHASE_PWR_RESET_ON
			
		else	'a modem-restart was requested
			'REMARK: `cell__modem_restart_isTrigg = false` is also set in subroutine `cell__stop`
			cell__modem_restart_isTrigg = false	'reset boolean to false
			
			cell__op_pwr_phase = PHASE_PWR_PWRKEY_ON
			
		end if
	
		'Initialize Modem
		'Go to next-phase (e.g., PHASE_PWR_PWRKEY_ON)
		cell__init(cell__op_pwr_phase, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
		
    else	'allocated buffer-size is NOT sufficient
		'OUTPUT
		cell__start = CELL__START_BUFFER_SIZE_IS_INSUFFICIENT

		'Insufficient buffer-pages detected, then:
		'1. Attempt to free-up buffer-pages via a RESET
		'2. If a RESET did NOT solve the issue, then go into IDLE-mode
		'REMARK: `cell__attempt_to_free_buffpages_via_modem_reset = false` is set in subroutine `cell__stop`
		if (cell__attempt_to_free_buffpages_via_modem_reset = false) then
			'Set boolean to true
			cell__attempt_to_free_buffpages_via_modem_reset = true
			
			'Initialize Modem
			'Go to next-phase (e.g., PHASE_PWR_RESET_ON)
			cell__init(PHASE_PWR_RESET_ON, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
			
		else	'Try to free-up Buffer-Pages via a Modem Reset (only do this once)
			'Set all next-phases to IDLE
			cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
			
		end if

		'CALLBACK
		cell__callback_insufficient_buffer_pages()
    end if
end function
function cell__stop(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases) as en_cell__status_phases

	if cell__init_flag<>CELL_INIT_SIGNATURE then
		exit function
	end if
	cell__init_flag=0
	'PRINT
	cell__debugprint_status(CELL__STOP_INITIATED, CELL__EMPTYSTRING)

	'Reset input parameters
    cell__apn = CELL__EMPTYSTRING
    cell__username = CELL__EMPTYSTRING
    cell__password = CELL__EMPTYSTRING
    cell__pap_credentials CELL__EMPTYSTRING
    cell__pin = CELL__EMPTYSTRING
	
	'Reset boolean
	cell__modem_restart_isTrigg = false
	cell__attempt_to_free_buffpages_via_modem_reset = false
	
	'Initialize Modem	
	cell__init(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
	
	'De-initalize Modem
	cell__deinit(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
	
	'PLEASE NOTE:
	'Once the modem is Powered Off, ALL phases are set to IDLE in subroutine `cell__modem_onoff`
	
end function

function cell__buffersize_isSufficient() as boolean
	'Define variables
    dim required_buffpages as byte
	dim free_buffpages as byte
	dim select_phase as en_cell__status_phases
	dim buffpages_required_vs_free as string

	'REQUIRED buffer-pages for this project
	required_buffpages = ( CELL__PPP_BUFF_SIZE + ((CELL__SER_PORT_BUFF_SIZE*2) + 2) )
	
	'FREE buffer-pages
	free_buffpages = sys.freebuffpages


	'Check if there are enough FREE buffer-pages for this project 
    if required_buffpages > free_buffpages then	'NOT enough FREE buffer-pages
		'Set phase
		select_phase=CELL__START_BUFFER_SIZE_IS_INSUFFICIENT
		
		'Set text
		buffpages_required_vs_free = str(required_buffpages) + ">" + str(free_buffpages)
		
		'Set boolean
		cell__buffersize_isSufficient = false
    else	'ENOUGH FREE buffer-pages
		'Set phase
		select_phase=CELL__START_BUFFER_SIZE_IS_SUFFICIENT
		
		'Set text
		buffpages_required_vs_free = str(required_buffpages) + "<" + str(free_buffpages)
	
		'Set boolean
		cell__buffersize_isSufficient = true
    end if


	'PRINT
	cell__debugprint_status(select_phase, buffpages_required_vs_free)
end function

function cell__calc_timediff_16b(tstart as word, tend as word) as word
    const WORD_SIZE_MAX = &hffff '16-bits: (2^16)-1 = 65535

    if tend >= tstart then
        cell__calc_timediff_16b = tend - tstart
	else	'tend < tstart
        cell__calc_timediff_16b = tend + (WORD_SIZE_MAX - tstart)
    end if
end function

sub cell__ltrim_crlf(byref inputdata as string)
    dim i as byte	'indexOf string
    dim c as byte	'count number of CR and LF
    dim onechar as string(CELL__1b_LEN)	'it's just one character
	
	'Find all leading CR and LF
	i = 0
    c = 0
    while i < len(inputdata)
		i = i + 1	'increment index	
	
        onechar = mid(inputdata, i, 1)	'Take one character from "inputdata" from LEFT to RIGHT
		
        if onechar = CELL__CR OR onechar = CELL__LF then	'onechar is CR or LF
			c = c + 1	'increment counter
        else	'as soon as onechar is NOT CR or LF
			exit while
        end if
    wend
	
    inputdata = right(inputdata, len(inputdata) - c )	'trim leading CRLF
end sub

sub cell__rtrim_crlf(byref inputdata as string)
    dim i as byte	'indexOf string
    dim c as byte	'count number of CR and LF
    dim onechar as string(CELL__1b_LEN)	'it's just one character
	
	'Find Trailing CR and LF
	i = 0
    c = 0
    while i < len(inputdata)
        onechar = mid(inputdata, (len(inputdata) - i), 1)	'Take one character from "inputdata" from RIGHT TO LEFT
		
        if onechar = CELL__CR OR onechar = CELL__LF OR onechar = CELL__DOLLAR then	'onechar is CR or LF or $
			c = c + 1	'increment counter
        else	'as soon as onechar is NOT CR or LF or $
			exit while
        end if
		
		i = i + 1	'increment index
    wend
	
    inputdata = left(inputdata, len(inputdata) - c )	'trim trailing CRLF
end sub

sub cell__trim_lstring(byref inputdata as string, byref lstring as string(CELL__128b_LEN))
	'check if `lstring` is found in the `inputdata`
    if (instr(1, inputdata, lstring, 1) <> 0) then
		'outputtext = right( inputdata, (length of inputdata - (length of lstring + position of lstring in inputdata - 1) ) )
        inputdata = right( inputdata, ( len(inputdata) - ( len(lstring) + instr(1, inputdata, lstring, 1) - 1 ) ) )	'trim leading AT-command
    end if
end sub

sub cell__substitute_char(byref inputdata as string, byref oldchar as string(CELL__1b_LEN), byref newchar as string(CELL__1b_LEN))
    dim i as byte	'indexOf string
    dim onechar as string(CELL__1b_LEN)	'a character of 1 bit in length
	
	'Find CR and LF
	i = 0
    while i < len(inputdata)
		i = i + 1	'increment index
		
        onechar = mid(inputdata, i, 1)	'Take one character from "inputdata"
		
        if onechar = oldchar then	'match is found
			inputdata = left( inputdata, (i-1) ) + newchar + right( inputdata, len(inputdata)-i )	'compose new `inputdata` with `newchar`
        end if
    wend
end sub

function cell__get_string_between_2chars( byref inputdata as string, nth_occur as byte, 
											byref firstchar as string(1), byref secondchar as string(1) ) as string(CELL__32b_LEN)
	'Define variables
    dim pos1, pos2 as byte

	'Find position of the string between 2 commas
    pos1 = instr( 1, inputdata, firstchar, nth_occur )	'Find position at the Nth-occurrence
    pos2 = instr( (pos1 + 1) , inputdata, secondchar, 1 )	'Find the next position after the Nth-occurrence
	
	'OUTPUT
    cell__get_string_between_2chars = mid( inputdata, (pos1+1), (pos2-pos1-1) )	
end function


'PRINT SUBROUTINES---------------------------------------------------
#if CELL__DEBUGPRINT_UDP_ISENABLED
    sub cell__debugprint_thru_udp(byref msg as string)
		'Set socket-number
        sock.num = cell__udp_tx_socknum

		'Set message to be sent
        sock.setdata(msg)
		
		'Send message
        sock.send
	
		'Wait until the tx-buffer is empty
        while sock.txlen > 0
			'DO NOOTHING (just )
        wend
    end sub
#endif

#if CELL__DEBUGPRINT_SERPORT_ISENABLED
    sub cell__debugprint_thru_serport(byref msg as string)
		'Set serial-port to be used to print debug messages (use IO-Ninja to show the print out messages)
		ser.num = CELL__DEBUGPRINT_SER_PORT

		'Set data to be sent out
		ser.setdata(msg + "\r\n")
		
		'Send data via the assigned serial-port
		ser.send()
		
		'Loop until tx-buffer is empty (this is a timeout)
		while ser.txlen > 0
			'DO NOTHING HERE
		wend
		
		'Set serial-port back to the DATA SERIAL PORT (this is the port used for at-commands, ppp-commands, etc.)
		ser.num = CELL__DATA_SER_PORT
    end sub
#endif

sub cell__debugprint_status(select_phase as en_cell__status_phases, byref msg as string)
	dim phasemsg as string
	dim header as string(CELL__64b_LEN)
	dim body as string
	dim state as string(CELL__4b_LEN)

	'Get current modem-state
	if CELL__MODEM_STATUS = cell__status_setto_on then
		state = "ON"
	else
		state = "OFF"
	end if

	select case select_phase
		case CELL__START_BUFFER_SIZE_IS_SUFFICIENT:
			header = "MODEM(" + state + "):-:BUFFERSIZE>:"
			body = "[SUFFICIENT MEM] REQUIRED?FREE: "
			
		case CELL__START_BUFFER_SIZE_IS_INSUFFICIENT:
			header = "MODEM(" + state + "):-:BUFFERSIZE>:"
			body = "[*WARNING*-INSUFFICIENT MEM] REQUIRED?FREE: "

		case CELL__STOP_INITIATED:
			header = "MODEM(" + state + "):-:STATUS>:"
			body = "POWERING-OFF MODEM <INITIATED>"

	end select
	
	
	'Finalize Phase Message
	if msg <> CELL__EMPTYSTRING then	'Add additional message to header
		phasemsg = header + CELL__CRLF_TAB + body + CELL__SPACE + "(" + msg + ")"
	else
		phasemsg = header + CELL__CRLF_TAB + body
	end if
	
	#if CELL__DEBUG_PRINT
		cell__debugprint(phasemsg)
	#endif
end sub

#if CELL__DEBUGPRINT_PWR_ISENABLED
    sub cell__debugprint_pwr_phase(select_phase as en_cell__op_pwr_phases, byref msg as string)
        dim phasemsg as string
        dim header as string(CELL__128b_LEN)
        dim body as string
		dim body_additional as string = CELL__EMPTYSTRING
        dim state as string(CELL__4b_LEN)

		'Get current modem-state
		if CELL__MODEM_STATUS = cell__status_setto_on then
			state = "ON"
		else
			state = "OFF"
		end if

		'Header
        header = "MODEM(" + state + "):-:PHASE>"

		'Body
        select case select_phase
            case PHASE_PWR_INIT: 
				body = "MODEM INIT... DONE"
            case PHASE_PWR_DEINIT: 
				body = "MODEM DE-INIT... DONE"
            case PHASE_PWR_RESET_ON:
				body = "MODEM RESET... ON"
            case PHASE_PWR_RESET_WAIT:
				body = "MODEM RESET... WAIT"
            case PHASE_PWR_RESET_RETRY:
				body = "MODEM RESET... RETRY"
				body_additional =  str(cell__reset_retry_param) + " out of "+ str(CELL__RESET_RETRY_MAX)
            case PHASE_PWR_RESET_OFF:
				body = "MODEM RESET... OFF"
            case PHASE_PWR_PWRKEY_ON: 
				body = "POWER SWITCH... PRESSED"
            case PHASE_PWR_PWRKEY_OFF: 
				body = "POWER SWITCH... RELEASED"
            case PHASE_PWR_POWERING_ON:
				body = "MODEM POWERING ON... PLEASE WAIT"
            case PHASE_PWR_MODEM_ON:
				body = "MODEM IS [ON]"
            case PHASE_PWR_POWERING_OFF:
				body = "MODEM POWERING OFF... PLEASE WAIT"
            case PHASE_PWR_POWERING_ONOFF_RETRY:
				body = "MODEM POWERING ON/OFF... RETRY"
				body_additional =  str(cell__pwrkey_retry_param) + " out of " + str(CELL__POWER_ONOFF_RETRY_MAX)
            case PHASE_PWR_OBJECT_STATE_CHANGED:			
				body = "CHANGED POLARITY TO:"
            case PHASE_PWR_SERPORT_CHK_RDY_STATE:
				body = "SERIAL PORT..."
            case PHASE_PWR_MODEM_OFF:
				body = "MODEM IS [OFF]"
			case PHASE_PWR_MODEM_RESTART_RETRY:
				body = "MODEM [RESTART]... RETRY"
				body_additional =  str(cell__modem_restart_retry_param) + " out of " + str(CELL__MODEM_RESTART_RETRY_MAX)
			case PHASE_PWR_MODEM_RESTART_RETRY_FAILED:
				body = "MODEM [RESTART]... FAILED"
            case PHASE_PWR_SHDN_OFF:
				body = "SHUTDOWN_SWITCH... PRESSED"
            case PHASE_PWR_SHDN_WAIT:
				body = "SHUTDOWN... WAIT"
            case PHASE_PWR_SHDN_RETRY:
				body = "SHUTDOWN... RETRY"
				body_additional =  str(cell__shdn_retry_param) + " out of " + str(CELL__SHDN_RETRY_MAX)
            case PHASE_PWR_SHDN_ON:
				body = "SHUTDOWN_SWITCH... RELEASED"
			case PHASE_PWR_IDLE:
				body = "GOING INTO IDLE-MODE..."
			
        end select
		
		'Finalize Phase Message
        if ( body <> CELL__EMPTYSTRING AND body_additional <> CELL__EMPTYSTRING AND msg = CELL__EMPTYSTRING ) then
			phasemsg = header + CELL__CRLF_TAB + body + CELL__SPACE + "<" + body_additional + ">"
        else if ( body <> CELL__EMPTYSTRING AND body_additional = CELL__EMPTYSTRING AND msg <> CELL__EMPTYSTRING ) then
			phasemsg = header + CELL__CRLF_TAB + body + CELL__SPACE + "<" + msg + ">"
		else
			phasemsg = header + CELL__CRLF_TAB + body
        end if

		'PRINT
        #if CELL__DEBUG_PRINT
            cell__debugprint(phasemsg)
        #endif
    end sub
#endif

#if CELL__DEBUGPRINT_AT_ISENABLED
    sub cell__debugprint_at_phase(select_phase as en_cell__op_at_phases, byref atcmd as string, byref msg as string)

        dim phasemsg as string
        dim header as string(CELL__128b_LEN)
        dim body as string
        dim state as string(CELL__4b_LEN)

		'Get current modem-state
        if CELL__MODEM_STATUS = cell__status_setto_on then
            state = "ON"
		else
            state = "OFF"
        end if

		'Header
        header = "MODEM(" + state + "):-:[" + atcmd + "]>"
		
		'Body
        select case select_phase
			case PHASE_AT_FREE_INPUT:
				body = CELL__EMPTYSTRING
			
            case PHASE_AT_PARSE_RETRY: 
				body = "RETRYING TO *PARSE*: <" + str(cell__at_retry_param) + " out of " + str(cell__at_retry_parse_max) + ">"

			case PHASE_AT_CMD_EXEC_RETRY:
				body = "RETRYING TO *EXECUTE & PARSE* COMMAND: <" + str(cell__at_cmd_exec_retry_param) + " out of " + str(cell__at_retry_exec_and_parse_max) + ">"

			case PHASE_AT_CMD_EXEC_RETRY_EXCEEDED:
				body = "RETRYING TO *EXECUTE & PARSE* COMMAND <EXCEEDED>"

			case PHASE_AT_ISRETRY_IN_PROGRESS_IN_IDLE_MODE:
				body = "RETRY IN-PROGRESS WHILE IN IDLE-MODE: <" + str(cell__isretry_inprogr_in_idlemode_retry_param) + " out of " + str(CELL__ISRETRY_INPROGR_IN_IDLEMODE_RETRY_MAX) + ">"
			
			case PHASE_AT_ISRETRY_IN_PROGRESS_IN_IDLE_MODE_EXCEEDED:
				body = "RETRY IN-PROGRESS WHILE IN IDLE-MODE <EXCEEDED>"
				
			case PHASE_AT_ON_SER_DATA_ARRIV_NOT_TRIGG:
				body = "ON-SER-DATA-ARRIVAL *NOT* TRIGGERED: <" + str(cell__on_ser_data_arriv_not_trigg_retry_param) + " out of " + str(CELL__ON_SER_DATA_ARRIV_NOT_TRIGG_RETRY_MAX) + ">"
			
			case PHASE_AT_ON_SER_DATA_ARRIV_NOT_TRIGG_EXCEEDED:
				body = "ON-SER-DATA-ARRIVAL *NOT* TRIGGERED <EXCEEDED>"
			
			case PHASE_AT_USERMODE_BUFFER_FULL:
				body = "ERROR: BUFFER IS FULL; UNABLE TO STORE MORE AT-COMMANDS <IN BUFFER:" + str(cell__at_cmd_storArray_numof_cmds) + ">"
				
			case PHASE_SMS_RCV:
				body = "NEW MESSSAGE RECEIVED"
			
			case PHASE_SMS_RDY_TO_RCV:
				body = "<RDY> TO RECEIVE NEW MESSAGES"
				
			case PHASE_SMS_EMPTY_STRING:
				body = "EMPTY STRING MESSAGE"
				
			case PHASE_SMS_SENT:
				body = "MESSAGE SENT SUCCESSFULLY"

			case PHASE_SMS_FULL:
				body = "SMS STORAGE IS <FULL>"
				
			case PHASE_AT_CMD_CONTAINS_TRIPLEPLUS:
				body = "SWITCHED BACK TO <CMD>-MODE"
				
			case PHASE_AT_CMD_CONTAINS_ATO:
				body = "SWITCHED BACK TO <DATA>-MODE"

        end select		
		
		
		'Finalize Phase Message
        phasemsg = header + CELL__CRLF_TAB + msg		'Finalize Phase Message
        if ( body <> CELL__EMPTYSTRING ) then
			phasemsg = header + CELL__CRLF_TAB + body + CELL__SPACE + msg
			
		else
			phasemsg = header + CELL__CRLF_TAB + msg
		
        end if
		
		
		'PRINT
        #if CELL__DEBUG_PRINT
            cell__debugprint(phasemsg)
        #endif
    end sub
#endif
	
#if CELL__DEBUG_PRINT
    sub cell__debugprint_ppp_phase(select_phase as en_cell__op_ppp_phases, 
        byref msg as string)
        dim phasemsg as string
        dim header as string(CELL__128b_LEN)
        dim body as string
        dim state as string(CELL__4b_LEN)

		'Get current modem-state
        if CELL__MODEM_STATUS = cell__status_setto_on then
            state = "ON"
		else
            state = "OFF"
        end if

		'Header
        header = "MODEM(" + state + "):-:PPP>:"

        select case select_phase
            case PHASE_PPP_MSG_LEN_NOTMATCH:
				body = "[LCP] PACKET LENGTH DOES NOT MATCH"
            case PHASE_PPP_FCS_ISBAD:
				body = "[FCS] IS NOT A GOOD FINAL VALUE (0xF0B8)"
            case PHASE_PPP_ADDRESS_FIELD_NOTPRESENT:
				body = "[ADDRESS] FIELD NOT PRESENT"
            case PHASE_PPP_CONTROL_FIELD_NOTPRESENT:
				body = "[CONTROL] FIELD NOT PRESENT"
            case PHASE_PPP_LCP_NEGO_SUCCESS:
				body = "[LCP] NEGOTIATION... SUCCESSFUL"
            case PHASE_PPP_RETRY_ERROR
				body =  "MAXIMUM PPP-RETRY EXCEEEDED"
            case PHASE_PPP_LCP_DISCREQ_BY_PEER:
				body = "[LCP] REQUEST DISCARDED BY PEER"
            case PHASE_PPP_LCP_DISCREQ_FROM_SENDER:
				body = "[LCP] REQUEST DISCARDED BY SENDER"
				
            case PHASE_PPP_PAP_NEGO_SUCCESS:
				body = "[PAP] NEGOTIATION... SUCCESSFUL"
            case PHASE_PPP_PAP_NEGO_FAILED:
				body = "[PAP] NEGOTIATION...FAILED"

            case PHASE_PPP_IPCP_RCV_IP: 
				body = "[IPCP] RECEIVED REMOTE IP:"
            case PHASE_PPP_IPCP_NEGO_SUCCESS:
				body = "[IPCP] NEGOTIATION... SUCCESSFUL"
            case PHASE_PPP_IPCP_NEGO_FAILED:
				body = "[IPCP] NEGOTIATION... FAILED"
            case PHASE_PPP_IPCP_DISCREQ_BY_PEER:
				body = "[IPCP] REQUEST DISCARDED BY PEER"
            case PHASE_PPP_IPCP_DISCREQ_FROM_SENDER:
				body = "[IPCP] REQUEST DISCARDED BY SENDER"
				
            case PHASE_PPP_PING_SUCCESSFUL:
				body = "[IP] PING... SUCCESSFUL"
            case PHASE_PPP_PING_FAILED:
				body = "[IP] PING... FAILED"
            case PHASE_PPP_LINK_ESTABLISHED:
				body = "[PPP] LINKED TO TOWER"
            case PHASE_PPP_PING:
				'For now not in use.
            case PHASE_PPP_CONN_TO_SERVER_SUCCESS:
				body = "[PPP] -CONNECTED- TO SERVER"
            case PHASE_PPP_CONN_TO_SERVER_RETRY:
				body = "[PPP] -RETRY- CONNECT TO SERVER"
            case PHASE_PPP_CONN_TO_SERVER_FAILED:
				body = "[PPP] -FAILED- TO CONNECT TO SERVER(S)"
            case PHASE_PPP_TRY_TO_CONN_TO_SERVER:
				body = "[PPP] -TRY- TO CONNECT TO SECONDARY SERVER"
            case PHASE_PPP_CONN_UPTIME:
				body = "[PPP] -CONNECTION UPTIME-"

        end select
		
		'Finalize Phase Message
        if msg <> CELL__EMPTYSTRING then	'Add additional message to msg
			phasemsg = header + CELL__CRLF_TAB + body + " <" + msg + ">"
        else
			phasemsg = header + CELL__CRLF_TAB + body
        end if

		'Print
        cell__debugprint(phasemsg)
    end sub
#endif


#if CELL__DEBUG_PRINT	
    sub cell__debugprint_gps_phase(select_phase as en_cell__op_gps_phases, 
										byref atcmd as string, byref msg as string)
	
        'Define variables
		dim phasemsg as string
        dim header as string(CELL__128b_LEN)
        dim body as string
        dim state as string(CELL__4b_LEN)

		'Get current modem-state
        if CELL__MODEM_STATUS = cell__status_setto_on then
            state = "ON"
		else
            state = "OFF"
        end if

		'Header
        header = "MODEM(" + state + "):-:[" + atcmd + "]>"

		'Body
        select case select_phase
            case PHASE_GPS_SIV:
				body = "NUMBER OF SIV:"
            case PHASE_GPS_POS:
				body = "MY GPS POSITION:"
				
        end select
		
		'Finalize Phase Message
        phasemsg = header + CELL__CRLF_TAB + body + CELL__SPACE + msg
        
		'Print
		#if CELL__DEBUG_PRINT
            cell__debugprint(phasemsg)
        #endif
    end sub
#endif

'DEVICE STATE SUBROUTINES--------------------------------------------
sub cell__update_op_next_phases(new_pwr_phase as en_cell__op_pwr_phases, new_at_phase as en_cell__op_at_phases, 
									new_ppp_phase as en_cell__op_ppp_phases, new_gps_phase as en_cell__op_gps_phases,
										new_parse_phase as en_cell__op_parse_phases)
										
	'THEN: Update the operational next-phases
    if (new_pwr_phase <> PHASE_PWR_DONOT_CHANGE) then
        cell__op_pwr_phase = new_pwr_phase
    end if
	
    if (new_at_phase <> PHASE_AT_DONOT_CHANGE) then
		cell__op_at_phase_bck = cell__op_at_phase	'backup current-phase before update
        cell__op_at_phase = new_at_phase
    end if
	
    if (new_ppp_phase <> PHASE_PPP_DONOT_CHANGE) then
		cell__op_ppp_phase_bck = cell__op_ppp_phase	'backup current-phase before update
        cell__op_ppp_phase = new_ppp_phase
    end if
	
    if (new_gps_phase <> PHASE_GPS_DONOT_CHANGE) then
        cell__op_gps_phase = new_gps_phase
    end if
	
    if (new_parse_phase <> PHASE_PARSE_DONOT_CHANGE) then
        cell__op_parse_phase = new_parse_phase
    end if
end sub


'***POWER SUBROUTINES---------------------------------------------------------
sub cell__graceful_shutdown()
	'REMARKS regarding `AT+GSHD`
	'1. This command is NOT a SIMCOM command
	'2. This command is used to trigger `cell__stop` via subroutine `cell__at_cmd_exec`... 
	'	... which is INDIRECTLY called via `cell__at_cmd_exec`
	cell__at_usermode_cmd_input(CELL__AT_GSHD)
end sub

sub cell__init(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
				next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
					next_parse_phase as en_cell__op_parse_phases)
	'Initialization
    #if CELL__DEBUGPRINT_UDP_ISENABLED
        cell__init_debugprint_udp(CELL__UDP_TARGET_PRIMARY_IP, CELL__UDP_TARGET_SECOND_IP, CELL__UDP_TARGET_PORT)
    #endif
	
    #if CELL__DEBUGPRINT_SERPORT_ISENABLED
        cell__init_debugprint_ser()	'initialize serial-port for debugprint
    #endif

	'A modem-restart was triggered from subroutine `cell__proc_sys_timer_unwanted_idle_mode`
	'In this case do NOT reset the retry-parameters
	if (cell__retry_in_progress = false) then
		cell__modem_restart_retry_param = 0	'this parameter should only be initialized if NO RETRY is in progress
	
		cell__init_param_var_bool()	'parameters, variables, booleans
	end if
	
    cell__init_io()	'IO-lines

    cell__init_ser()	'Serial-port

    #if CELL__PPP_MODE_ISENABLED
        cell__init_ppp()	'PPP-channel

'        cell__init_https_conn_variables()	'reset starttime, retry parameter, default server related to ppp-connection status check

'        cell__init_timestamps()	'reset timestamps	
    #endif


	'UPDATE start-state
	'	This is important because it will be used later on 
    cell__startstate = io.lineget(CELL__STATUS_LINENUM)


	'PRINT
    #if CELL__DEBUGPRINT_PWR_ISENABLED
        cell__debugprint_pwr_phase(PHASE_PWR_INIT, CELL__EMPTYSTRING)
    #endif

	'Set next phase to transit to (e.g. cell__reset_on)
    cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

end sub
sub cell__deinit(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
				next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
					next_parse_phase as en_cell__op_parse_phases)
	
			
	#if CELL__AT_USERMODE_ISENABLED
		cell__sms_msg_inputmode_isOn = false
	#endif
	
	
	'De-initialize serial Port
	cell__deinit_ser()
	
	'De-initialize PPP-port
	#if CELL__PPP_MODE_ISENABLED
		cell__deinit_ppp()	'this includes Releasing All Sockets
	#endif
	
	'PRINT
    #if CELL__DEBUGPRINT_PWR_ISENABLED
        cell__debugprint_pwr_phase(PHASE_PWR_DEINIT, CELL__EMPTYSTRING)
    #endif

	'Set next phase to transit to (e.g. cell__reset_on)
    cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
end sub

sub cell__init_param_var_bool()
	'Counters
    cell__pwrkey_retry_param = 0	'PWRKEY on/off 
    cell__reset_retry_param = 0	'RESET
    cell__shdn_retry_param = 0	'SHDN
	cell__at_retry_param = 0	'Reset PARSE retry-counter
	
	
	
	cell__at_cmd_exec_retry_param = 0	'AT CMD EXEC RETRY
	cell__isretry_inprogr_in_idlemode_retry_param = 0
	cell__on_ser_data_arriv_not_trigg_retry_param = 0

	'Varables
	cell__at_cmd = CELL__EMPTYSTRING

end sub

sub cell__init_io()
    if cell__modem_init_startup = true then	'only execute this once (during initial modem startup)
		if CELL__MODEM_STATUS =  CELL__OFF then	'polarity does not have to be reversed
			cell__reverse_polarity(STATUS, NO)
			cell__reverse_polarity(PWRKEY, NO)
			cell__reverse_polarity(RESET, NO)
			cell__reverse_polarity(SHDN, NO)
				
		else	'reverse polarity
			cell__reverse_polarity(STATUS, YES)
			cell__reverse_polarity(PWRKEY, YES)
			cell__reverse_polarity(RESET, YES)
			cell__reverse_polarity(SHDN, YES)
				
		end if
    end if

	'SHDN line
    io.num = CELL__SHDN_LINENUM
    io.enabled = YES	'output

	'Initial SHDN state should be Active
	'If false, then set to Active
    if CELL__SHDN_STATE = cell__shdn_setto_off then
        CELL__SET_SHDN_ON	'then set SHDN line to Active (by default)
    end if

	'PWRKEY line
    io.num = CELL__PWRKEY_LINENUM
    io.enabled = YES	'output

	'RESET line
    io.num = CELL__RESET_LINENUM
    io.enabled = YES	'output

	'STATUS line
    io.num = CELL__STATUS_LINENUM
    io.enabled = NO	'input
end sub

sub cell__init_at_cmd_storArray()
	'Initialize Array
	cell__at_cmd_storArray_index = 0	'start index
	while cell__at_cmd_storArray_index < CELL__ARRAY_LEN
		cell__at_cmd_storArray(cell__at_cmd_storArray_index) = CELL__EMPTYSTRING	'initialize Array's designated row
		
		cell__at_cmd_storArray_index = cell__at_cmd_storArray_index + 1	'increment index by 1
	wend

	'Initialize Array-index
	cell__at_cmd_storArray_index = 0
	cell__at_cmd_storArray_numof_cmds = 0
end sub

#if CELL__AUTO_POLARITY_ADJUST_ISENABLED
    sub cell__reverse_polarity(byref pwr_object as en_cell__pwr_objects, rev_polarity as no_yes)
    	'Define varables
        dim pwr_object_str as string(CELL__16b_LEN)
        dim state_ison_str as string(CELL__4b_LEN)

        select case pwr_object 
            case STATUS:
				if rev_polarity = NO then
					cell__status_setto_on = CELL__ON
					cell__status_setto_off = CELL__OFF
						
					state_ison_str = CELL__HIGH_STR	'update debugprint string
				else
					cell__status_setto_on = CELL__OFF
					cell__status_setto_off = CELL__ON
						
					state_ison_str = CELL__LOW_STR	'update debugprint string
				end if
					
					'update variables
				pwr_object_str = CELL__STATUSON_STR	'update debugprint string
				cell__status_revpol = rev_polarity
				
            case PWRKEY:
				if rev_polarity = NO then
					cell__pwrkey_setto_on = CELL__ON
					cell__pwrkey_setto_off = CELL__OFF
						
					state_ison_str = CELL__HIGH_STR	'update debugprint string
				else
					cell__pwrkey_setto_on = CELL__OFF
					cell__pwrkey_setto_off = CELL__ON
						
					state_ison_str = CELL__LOW_STR	'update debugprint string
				end if

					'update variables
				pwr_object_str = CELL__PWRKEYON_STR	'update debugprint string
				cell__pwrkey_revpol = rev_polarity
				
            case RESET:
				if rev_polarity = NO then
					cell__reset_setto_on = CELL__ON
					cell__reset_setto_off = CELL__OFF
						
					state_ison_str = CELL__HIGH_STR	'update debugprint string
				else
					cell__reset_setto_on = CELL__OFF
					cell__reset_setto_off = CELL__ON
						
					state_ison_str = CELL__LOW_STR	'update debugprint string
				end if
					
					'update variables
				pwr_object_str = CELL__RESETON_STR	'update debugprint string
				cell__reset_revpol = rev_polarity
				
            case SHDN:
				if rev_polarity = NO then
					cell__shdn_setto_on = CELL__ON
					cell__shdn_setto_off = CELL__OFF
						
					state_ison_str = CELL__HIGH_STR	'update debugprint string
				else
					cell__shdn_setto_on = CELL__OFF
					cell__shdn_setto_off = CELL__ON
						
					state_ison_str = CELL__LOW_STR	'update debugprint string
				end if
					
					'update variables
				pwr_object_str = CELL__SHDNON_STR	'update debugprint string
				cell__shdn_revpol = rev_polarity
				
        end select
		
        cell__pwr_object_state = pwr_object_str + " = " + state_ison_str	'compose debug message
        
		#if CELL__DEBUGPRINT_PWR_ISENABLED		
            cell__debugprint_pwr_phase(PHASE_PWR_OBJECT_STATE_CHANGED, cell__pwr_object_state)	'PRINT
        #endif
    end sub
#endif

#if CELL__DEBUGPRINT_UDP_ISENABLED
    sub cell__init_debugprint_udp(byref primary_ip as string(CELL__16b_LEN), byref secondary_ip as string(CELL__16b_LEN), targetport as word)
   		'Define variables
        dim time_out as dword=sys.timercountms + 10000	'time-out for the connection to the `targetip` and `targetport`	
        dim targetip as string(CELL__16b_LEN) = primary_ip	'initial value
		
        START_HANDLER:
		'Set Socket for UDP connection
        cell__udp_tx_socknum = sock_get("UDP_TX")
        sock.num = cell__udp_tx_socknum
        sock.protocol = PL_SOCK_PROTOCOL_UDP
        sock.inconmode = PL_SOCK_INCONMODE_NONE
        sock.allowedinterfaces = "NET,WLN"
        sock.txbuffrq(1)
        sock.rxbuffrq(1)
        sys.buffalloc()
        sock.targetinterface = PL_SOCK_INTERFACE_NET
        sock.targetip = targetip
        sock.targetport = targetport

        sock.num = cell__udp_tx_socknum
        sock.connect()	'make the connection to the `targetip`
		
		'Wait until the connection to the `targetip` has been established
        while sock.statesimple <> PL_SSTS_EST and sys.timercountms < time_out
			'DO NOTHING
        wend
		
		'Show message if connection to `targetip` could not be established
        if sock.statesimple = PL_SSTS_EST then
            sys.debugprint("[UDP-debugprint] connected to " + targetip + ":" + str(targetport) + "\r\n")
		else
            sys.debugprint("[UDP-debugprint] could NOT connect to " + targetip + ":" + str(targetport) + "\r\n")

            if targetip = primary_ip then
                targetip = secondary_ip	'set targetip to secocndary ip

                sys.debugprint("[UDP-debugprint] try to connect to " + targetip + ":" + str(targetport) + "\r\n")
			
                GOTO START_HANDLER
			else
                sys.debugprint("[UDP-debugprint] please change TARGET-IP or switch off UDP-debug" + "\r\n")
                sys.debugprint("[UDP-debugprint] exit now..." + "\r\n")
            end if
        end if
    end sub
#endif

#if CELL__DEBUGPRINT_SERPORT_ISENABLED
    sub cell__init_debugprint_ser()
        ser.num = CELL__DEBUGPRINT_SER_PORT
        ser.enabled = NO
		
        ser.interface = PL_SER_SI_FULLDUPLEX
        ser.flowcontrol = PL_SER_FC_DISABLED
        ser.baudrate = PL_SER_BAUD_9600	'9600 baud
        ser.esctype = PL_SER_ET_DISABLED
        ser.interchardelay = 0
        ser.txbuffrq(1)
        ser.rxbuffrq(1)
        sys.buffalloc()
		
        ser.enabled = YES
    end sub
#endif

sub cell__init_ser()
    ser.num = CELL__DATA_SER_PORT	'assign serial-port number
	
	'First: DISABLE the assigned serial-port
	'	This is required in order to configure the serial-port.
    ser.enabled = NO
	
    ser.interchardelay = CELL__INTERCHAR_DELAY_VAL	'set the intercharacter delay value (e.g. 10 ms)

    ser.rxbuffrq(CELL__SER_PORT_BUFF_SIZE)	'set rx buffer-size (1 page = 256 bytes)
    ser.txbuffrq(CELL__SER_PORT_BUFF_SIZE)	'set tx buffer-size (1 page = 256 bytes)
    sys.buffalloc	'very important: allocate the rx and tx buffer-size
	
    ser.rxclear	'clear rx-buffer
	
    ser.txclear	'clear tx-buffer    
	ser.baudrate = PL_SER_BAUD_115200	'set baudrate to 115200
    ser.flowcontrol = PL_SER_FC_DISABLED	'disable flow-control
    ser.rtsmap = CELL__RTS_LINENUM	'set RTS line (which is the same as the Serial Port number)
    ser.ctsmap = CELL__CTS_LINENUM	'set CTS line (which is the same as the Serial Port number)
	
	'Lastly: ENABLE the assigned serial-port
    ser.enabled = YES

	'Map RTS-line
    io.num = ser.rtsmap
    io.enabled = YES	'Enable IO-line
	
end sub
sub cell__deinit_ser()
	'Disable Serial-port 
	ser.num = CELL__DATA_SER_PORT
	ser.enabled = NO

	'Release Buffer-Pages
	ser.rxbuffrq(0)
	ser.txbuffrq(0)
	sys.buffalloc
end sub


#if CELL__PPP_MODE_ISENABLED
    sub cell__init_ppp()
		'Counters
        cell__ppp_retry_param = 0 'PPP

		'Booleans (yes/no)
        cell__ppp_pap_isRequired = true
        cell__ppp_sender_confreq_isAck = false
        cell__ppp_sender_confreq_isAck = false
		
		'Identifiers (=sequence-number)
        cell__ppp_sender_id = 0
		
		'IP addresses
        cell__ppp_sender_ip = chr(&h00) + chr(&h00) + chr(&h00) + chr(&h00)
        cell__ppp_peer_ip = chr(&h00) + chr(&h00) + chr(&h00) + chr(&h00)

		'Set PPP-portnumber
        ppp.portnum = CELL__DATA_SER_PORT	'link PPP-port to a serial-port
		
		'First: DISABLE the PPP-port
		'	This is required in order to configure the PPP-port.
        ppp.enabled = NO
		
        ppp.buffrq(CELL__PPP_BUFF_SIZE)	'set ppp buffer-size
        sys.buffalloc	'very important: allocate the ppp buffer-size
		
		'***REMARK: the PPP-port will be enabled later on in subroutine `cell__ppp_link_to_tower()`
    end sub
	sub cell__deinit_ppp()
		'FLUSH the (garbage) SOCKET data
		cell__sock_flush_all()
	
		'Disable Port
		ppp.enabled = NO
		
		'Release Buffer-Pages
		ppp.buffrq(0)
		
	end sub

'    sub cell__init_https_conn_variables()
'        cell__starttime = sys.timercount	'***IMPORTANT: update start-timecounter
			
'        cell__https_retry_param = 0 	'reset retry paramter	(DO NOT include this parameter in subroutine `cell__init_param_var_bool()`)
							
'        cell__https_server = SERVER_GOOGLE	'set to default server
'    end sub

'    sub cell__init_timestamps()
'        cell__ts_daycount = 0	'day counter
'        cell__ts_hrcount = 0	'hour counter
'        cell__ts_mincount = 0	'minute counter
'        cell__ts_seccount = 0	'second counter
'    end sub
#endif


sub cell__modem_restart(next_pwr_phase as en_cell__op_pwr_phases)
	if (cell__modem_restart_retry_param < CELL__MODEM_RESTART_RETRY_MAX) then	
		'Set boolean to true (IMPORTANT)
		'	If this boolean is not set to true, 
		'	then the Modem will NOT power On after a power Off)
		cell__modem_restart_isTrigg = true
		
		'INCREMENT
		cell__modem_restart_retry_param = cell__modem_restart_retry_param + 1
		
		'PRINT
		cell__debugprint_pwr_phase(PHASE_PWR_MODEM_RESTART_RETRY, CELL__EMPTYSTRING)
		
		'Set next phase to transit to (e.g., PHASE_PWR_PWRKEY_ON).
		'...This is necessary to POWER-OFF the modem FIRST!!!
		'...Once the modem is OFF, subroutine `cell__start` will be triggered.
		'ALL other phases should be set to IDLE
		'De-initalize Modem
		cell__deinit(next_pwr_phase, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
		
	else
		'Set boolean to false
		cell__modem_restart_isTrigg = false
	
		'Initialize parameters, variables and booleans
		cell__init_param_var_bool()

'		'Clean Array and initialize Array-index
		#if CELL__AT_USERMODE_ISENABLED
			cell__init_at_cmd_storArray()
		#endif


		'PRINT
		cell__debugprint_pwr_phase(PHASE_PWR_MODEM_RESTART_RETRY_FAILED, CELL__EMPTYSTRING)
		cell__debugprint_pwr_phase(PHASE_PWR_IDLE, CELL__EMPTYSTRING)

		'FIRST: cell__init
		'SECOND: cell__deinit
		'REMARK: If required to SHUTDOWN modem, then set `next_pwr_phase=PHASE_PWR_PWRKEY_ON`
		cell__stop( PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
		
		'CALLBACK
		cell__callback_modem_restart_failed()
		
	end if
end sub

sub cell__reset_on(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
					next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
						next_parse_phase as en_cell__op_parse_phases)
						
    CELL__SET_RESET_ON	'set the RESET line to Active

	cell__starttime = sys.timercount	'***IMPORTANT: update start-timecounter
			
	
	'Update startstate
	'	This is important because it will be used later on 
    cell__startstate = io.lineget(CELL__STATUS_LINENUM)
	
    #if CELL__DEBUGPRINT_PWR_ISENABLED
        cell__debugprint_pwr_phase(PHASE_PWR_RESET_ON, CELL__EMPTYSTRING)	'PRINT
    #endif
	
	'Set next phase to transit to (e.g. PHASE_PWR_RESET_WAIT)
    cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

end sub

sub cell__reset_wait(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)

    cell__newtime = sys.timercount	'update new timercounter
    cell__elapsedtime = cell__calc_timediff_16b(cell__starttime, cell__newtime)	'calculate the elapsed time
	
    if cell__elapsedtime <= CELL__STATUS_TIMEOUT_MAX then	'maximum timeout for the modem to turn OFF
		if CELL__MODEM_STATUS = cell__status_setto_off then	'modem is OFF
			'Set next phase to transit to (e.g. PHASE_PWR_RESET_OFF)
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		end if
    else	'timeout has EXCEEDED; modem did NOT turn OFF
		cell__reset_retry()	'move on to the RESET retry process
		
    end if
end sub

sub cell__reset_retry()
    if cell__reset_retry_param < CELL__RESET_RETRY_MAX then	'number of retries has NOT exceeded yet
		cell__reset_retry_param = cell__reset_retry_param + 1	'increment counter (cell__reset_retry_param starts with 0)
		
		#if CELL__DEBUGPRINT_PWR_ISENABLED	
			cell__debugprint_pwr_phase(PHASE_PWR_RESET_RETRY, CELL__EMPTYSTRING)	'PRINT
		#endif		
		
		'Set next phase to transit to (e.g. PHASE_PWR_RESET_ON)
		cell__update_op_next_phases(PHASE_PWR_RESET_ON, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
		
    else	'maximum number of retries has been EXCEEDED
		cell__shdn_retry()	'move on to the SHDN retry process
		
    end if
end sub

sub cell__reset_off(next_pwr_on_phase as en_cell__op_pwr_phases, next_pwr_off_phase as en_cell__op_pwr_phases, 
						next_at_phase as en_cell__op_at_phases, next_ppp_phase as en_cell__op_ppp_phases, 
							next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
						
    CELL__SET_RESET_OFF	'set the RESET line to Inactive
	
    #if CELL__DEBUGPRINT_PWR_ISENABLED
        cell__debugprint_pwr_phase(PHASE_PWR_RESET_OFF, CELL__EMPTYSTRING)	'PRINT
    #endif
	
'	cell__starttime = sys.timercount	'***IMPORTANT: update start-timecounter
			
	'Depending on the current state of the modem (OFF or ON), the modem will transit to:
	'	- PHASE_PWR_PWRKEY_ON (modem is OFF and needs to be turned ON)
	'	- PHASE_PWR_MODEM_ONOFF (modem is ON and needs to be turned OFF)
    if cell__startstate = cell__status_setto_off then	'modem is OFF and needs to be turned ON
		'Set next phase to transit to (e.g. PHASE_PWR_PWRKEY_ON)
		cell__update_op_next_phases(next_pwr_on_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		
    else	'modem is ON and needs to be turned OFF
		'Set next phase to transit to (e.g. PHASE_PWR_POWERING_ONOFF)
		cell__update_op_next_phases(next_pwr_off_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		
    end if
end sub

sub cell__shdn_off(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)
						
    CELL__SET_SHDN_OFF	'set SHDN to Inactive

	cell__starttime = sys.timercount	'***IMPORTANT: update start-timecounter
			
    
	#if CELL__DEBUGPRINT_PWR_ISENABLED
        cell__debugprint_pwr_phase(PHASE_PWR_SHDN_OFF, CELL__EMPTYSTRING)	'PRINT
    #endif
	
	'Set next phase to transit to (e.g. PHASE_PWR_SHDN_WAIT)
    cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

end sub

sub cell__shdn_wait(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)
						
    cell__newtime = sys.timercount	'update new timercounter
    cell__elapsedtime = cell__calc_timediff_16b(cell__starttime, cell__newtime)	'calculate the elapsed time

    if cell__elapsedtime <= CELL__STATUS_TIMEOUT_MAX then	'maximum timeout for the modem to turn OFF
		if CELL__MODEM_STATUS = cell__status_setto_off then	'modem is OFF
			'Set next phase to transit to (e.g. PHASE_PWR_SHDN_ON)
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		end if
    else	'timeout has EXCEEDED; modem did NOT turn OFF
		cell__shdn_retry()	'move on to SHDN retry process
    end if
end sub

sub cell__shdn_retry()
    if cell__shdn_retry_param < CELL__SHDN_RETRY_MAX then	'number of retries has NOT exceeded yet
		CELL__SET_RESET_OFF	'set RESET line back to Inactive (IMPORTANT)

		cell__shdn_retry_param = cell__shdn_retry_param + 1	'increment counter (cell__shdn_retry_param starts with 0)
		
		#if CELL__DEBUGPRINT_PWR_ISENABLED		
			cell__debugprint_pwr_phase(PHASE_PWR_SHDN_RETRY, CELL__EMPTYSTRING)	'PRINT
		#endif
		
		'Set next phase to transit to (e.g. PHASE_PWR_SHDN_OFF)
		cell__update_op_next_phases(PHASE_PWR_SHDN_OFF, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

	else	'maximum number of retries has been EXCEEDED
		cell__modem_restart(PHASE_PWR_PWRKEY_ON)	'initiate a modem-restart			

    end if
end sub

sub cell__shdn_on(next_pwr_on_phase as en_cell__op_pwr_phases, next_pwr_off_phase as en_cell__op_pwr_phases, 
					next_at_phase as en_cell__op_at_phases, next_ppp_phase as en_cell__op_ppp_phases, 
						next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)

    CELL__SET_SHDN_ON	'set SHDN to Active
  
	#if CELL__DEBUGPRINT_PWR_ISENABLED
        cell__debugprint_pwr_phase(PHASE_PWR_SHDN_ON, CELL__EMPTYSTRING)	'PRINT
    #endif
	
	'Depending on the current state of the modem (OFF or ON), the modem will transit to:
	'	- PHASE_PWR_PWRKEY_ON (modem is OFF and needs to be turned ON)
	'	- PHASE_PWR_MODEM_ONOFF (modem is ON and needs to be turned OFF)
    if cell__startstate = cell__status_setto_off then	'modem is OFF and needs to be turned ON
		'Set next phase to transit to (e.g. PHASE_PWR_PWRKEY_ON)
		cell__update_op_next_phases(next_pwr_on_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		
    else	'modem is ON and needs to be turned OFF
		'Set next phase to transit to (e.g. PHASE_PWR_MODEM_ONOFF)
		cell__update_op_next_phases(next_pwr_off_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		
    end if
end sub

sub cell__pwrkey_on(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)

    CELL__SET_PWRKEY_ON	'set PWRKEY to Active (which means press the power button)

	cell__starttime = sys.timercount	'***IMPORTANT: update start-timecounter
	
	#if CELL__DEBUGPRINT_PWR_ISENABLED
        cell__debugprint_pwr_phase(PHASE_PWR_PWRKEY_ON, CELL__EMPTYSTRING)	'PRINT
    #endif
	
	'Set next phase to transit to (e.g. PHASE_PWR_PWRKEY_OFF)
    cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

end sub

sub cell__pwrkey_off(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)

    cell__newtime = sys.timercount	'update new timercounter
    cell__elapsedtime = cell__calc_timediff_16b(cell__starttime, cell__newtime)	'calculate the elapsed time

	'Now wait for at least 2 seconds before continue. This timeout is necessary to allow the modem to turn OFF
    if cell__elapsedtime > CELL__PWRKEY_TIMEOUT_MIN then	'wait for at least 2 seconds
		CELL__SET_PWRKEY_OFF	'set PWRKEY to Iactive (which means release the power button)
		
		#if CELL__DEBUGPRINT_PWR_ISENABLED
			cell__debugprint_pwr_phase(PHASE_PWR_PWRKEY_OFF, CELL__EMPTYSTRING)	'PRINT
		#endif

		'Set next phase to transit to (e.g. PHASE_PWR_POWERING_ONOFF)
		cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
    end if
end sub

sub cell__pwrkey_retry()
    if cell__pwrkey_retry_param < CELL__POWER_ONOFF_RETRY_MAX then	'number of PWRKEY retries has NOT exceeded yet
		#if CELL__AUTO_POLARITY_ADJUST_ISENABLED
			if cell__modem_init_startup = true then	'only execute this once (during initial modem startup)
				'REMARK: each time when subroutine `cell__reverse_polarity` is executed    ,...
				'... parameter `cell__shdn_revpol, cell__reset_revpol, or cell__pwrkey_revpol` is updated
				select case cell__pwrkey_retry_param
					case 0:
						cell__reverse_polarity( RESET, (1 - cell__reset_revpol) )	'try #1: inverse RESET state (0 x 0)
					case 1: 
						cell__reverse_polarity( SHDN, (1 - cell__shdn_revpol) )	'try #2: inverse SHDN state (0 x x)
					case 2: 
						cell__reverse_polarity( PWRKEY, (1 - cell__pwrkey_revpol) )	'try #3: inverse PWRKEY state (x x x)
					case 3:  
						cell__reverse_polarity( RESET, (1 - cell__reset_revpol) )	'try #4: set RESET state back to value right after triggering subroutine "cell__init_io()" (x 0 x)
					case 4:
						cell__reverse_polarity( SHDN, (1 - cell__shdn_revpol) )	'try #5: set SHDN state back to value right after triggering subroutine "cell__init_io()" (x 0 0)
					case 5:
						cell__reverse_polarity( PWRKEY, (1 - cell__pwrkey_revpol) )	'try #6: set PWRKEY state back to value v after triggering subroutine "cell__init_io()" (0 0 0)
						cell__reverse_polarity( SHDN, (1 - cell__shdn_revpol) )	'try #7: inverse SHDN state (0 0 x)
					case 6:
						cell__reverse_polarity( SHDN, (1 - cell__shdn_revpol) )	'try #8: set SHDN state back to value of right after triggering subroutine "cell__init_io()" (0 0 0)
						cell__reverse_polarity( PWRKEY, (1 - cell__pwrkey_revpol) )	'try #10: inverse PWRKEY state (x 0 0)
						cell__reverse_polarity( RESET, (1 - cell__reset_revpol) )	'try #10: inverse RESET state (x x 0)
					case 7:
						cell__reverse_polarity( PWRKEY, (1 - cell__pwrkey_revpol) )	'try #6: set PWRKEY state back to value of right after triggering subroutine "cell__init_io()" (0 x 0)	
						cell__reverse_polarity( RESET, (1 - cell__reset_revpol) )	'try #5: set RESET state back to value of right after triggering subroutine "cell__init_io()" (0 0 0)
						'REMARK: the PWRKEY, RESET, and SHDN states are back to the value of right after triggering subroutine "cell__init_io()" (0 0 0)
				end select
			
				'Initial SHDN state should be Active
				'If false, then set to Active
				if CELL__SHDN_STATE = cell__shdn_setto_off  then
					CELL__SET_SHDN_ON	'then set SHDN line to Active
				end if

				'Set next phase to transit to (e.g. PHASE_PWR_RESET_ON)
				cell__update_op_next_phases(PHASE_PWR_RESET_ON, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
					
			else	'cell__modem_init_startup = false
				'Set next phase to transit to (e.g. PHASE_PWR_PWRKEY_ON)
				cell__update_op_next_phases(PHASE_PWR_PWRKEY_ON, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
					
			end if
		#else
			'Set next phase to transit to (e.g. PHASE_PWR_PWRKEY_ON)
			cell__update_op_next_phases(PHASE_PWR_PWRKEY_ON, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

		#endif
			
		cell__pwrkey_retry_param = cell__pwrkey_retry_param + 1	'increment counter (cell__pwrkey_retry_param starts with 0)
		
		#if CELL__DEBUGPRINT_PWR_ISENABLED	
			cell__debugprint_pwr_phase(PHASE_PWR_POWERING_ONOFF_RETRY, CELL__EMPTYSTRING)	'PRINT
		#endif
	else	'number of PWRKEY retries has been EXCEEDED
			cell__reset_retry()	'move on to the RESET retry process
			
		'***REMARK: should number of RESET retries also EXCEED, then it will move on to SHDN retry process
    end if
end sub

sub cell__powering_onoff(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
							next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
								next_parse_phase as en_cell__op_parse_phases)

	cell__starttime = sys.timercount	'***IMPORTANT: update start-timecounter

	if (cell__modem_restart_isTrigg = true) then	'modem restart was requested
		#if CELL__DEBUGPRINT_PWR_ISENABLED
			'Show message that Modem is Powering Off
			cell__debugprint_pwr_phase(PHASE_PWR_POWERING_OFF, CELL__EMPTYSTRING)	'PRINT
		#endif				
	else
		if CELL__MODEM_STATUS = cell__status_setto_off then	'modem is OFF and needs to be Powered ON
			#if CELL__DEBUGPRINT_PWR_ISENABLED
				cell__debugprint_pwr_phase(PHASE_PWR_POWERING_ON, CELL__EMPTYSTRING)	'PRINT
			#endif			
		else	'modem is ON and needs to be Powered OFF
			#if CELL__DEBUGPRINT_PWR_ISENABLED
				cell__debugprint_pwr_phase(PHASE_PWR_POWERING_OFF, CELL__EMPTYSTRING)	'PRINT
			#endif			
		end if
	end if
	
	'Set next phase to transit to (e.g. PHASE_PWR_POWERING_ONOFF_WAIT)
    cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

end sub

sub cell__powering_onoff_wait(next_pwr_on_phase as en_cell__op_pwr_phases, next_pwr_off_phase as en_cell__op_pwr_phases, 
								next_at_phase as en_cell__op_at_phases, next_ppp_phase as en_cell__op_ppp_phases, 
									next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
								
	cell__newtime = sys.timercount	'update new timercounter
    cell__elapsedtime = cell__calc_timediff_16b(cell__starttime, cell__newtime)	'calculate the elapsed time

    if cell__elapsedtime <= CELL__STATUS_TIMEOUT_MAX then	'maximum timeout for the modem to turn ON/OFF
		cell__newstate = io.lineget(CELL__STATUS_LINENUM)	'update the modem state

		if cell__newstate <> cell__startstate then	'check periodically whether the modem state has changed
			if CELL__MODEM_STATUS = cell__status_setto_on then	'Modem has turned ON
				'***IMPORTANT: update start-timecounter
				cell__starttime = sys.timercount
							
				'Set next phase to transit to (e.g. PHASE_PWR_SERPORT_CHK_RDY_STATE)
				cell__update_op_next_phases(next_pwr_on_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
						
			else	'Modem has turned OFF
				'Set next phase to transit to (e.g. PHASE_PWR_MODEM_ONOFF)
				cell__update_op_next_phases(next_pwr_off_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

			end if
		end if
	else	'timeout has EXCEEDED		
		cell__pwrkey_retry()	''move on to the PWRKEY retry process
			
		'***REMARK: should number of PWRKEY retries EXCEED, then it will move on to RESET retry process
    end if
end sub

sub cell__check_rdy_state(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
							next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
								next_parse_phase as en_cell__op_parse_phases)

    cell__newtime = sys.timercount	'update new timercounter
    cell__elapsedtime = cell__calc_timediff_16b(cell__starttime, cell__newtime)	'calculate the elapsed time

    if cell__elapsedtime <= CELL__STATUS_TIMEOUT_MAX then	'maximum timeout for the Serial-port to become RDY
		if CELL__AT_REPLIED_WITH_RDY then	'serial-port is RDY
			cell__ser_port_isRdy = true	'set boolean to true
			#if CELL__DEBUGPRINT_PWR_ISENABLED		
				cell__debugprint_pwr_phase(PHASE_PWR_SERPORT_CHK_RDY_STATE, CELL__RDY)	'PRINT
			#endif
		
			'Set next phase to transit to (e.g. PHASE_PWR_MODEM_ONOFF)
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		end if	
	else	'timeout has EXCEEDED, serial-port is NOT RDY
		cell__ser_port_isRdy = false	'set boolean to false
		
		'Set next phase to transit to (e.g. PHASE_PWR_MODEM_ONOFF)
		cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		
    end if
end sub

sub cell__modem_onoff(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
						next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
							next_parse_phase as en_cell__op_parse_phases)
    
	
	'IMPORTANT: set boolean to false (this will prevent this section from triggering again)
	cell__modem_init_startup = false	
	
	if CELL__MODEM_STATUS = cell__status_setto_on then	'Modem is ON
		#if CELL__DEBUGPRINT_PWR_ISENABLED
			cell__debugprint_pwr_phase(PHASE_PWR_MODEM_ON, CELL__EMPTYSTRING)	'PRINT message that Modem is On
		#endif
	
		'Update startstate
		'REMARK: this is important because it will be used later on 
		cell__startstate = io.lineget(CELL__STATUS_LINENUM)

		cell__starttime = sys.timercount	'***IMPORTANT: update start-timecounter

		cell__init_param_var_bool()	'initialize parameters, variables and booleans

		'Set next phase to transit to (e.g., PHASE_AT_INIT)
		cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

		'CALLBACK
		cell__callback_modem_on()
		
	else	'Modem is OFF
		#if CELL__DEBUGPRINT_PWR_ISENABLED
			cell__debugprint_pwr_phase(PHASE_PWR_MODEM_OFF, CELL__EMPTYSTRING)	'PRINT message that Modem is Off
		#endif

		'Possible scenarios:
		'1. cell__modem_restart_isTrigg = true: go to next-phase = PHASE_PWR_MODEM_RESTART_RETRY
		'2. for all other cases: set all phases to IDLE
		if (cell__modem_restart_isTrigg = true) then	'modem restart was requested
			cell__update_op_next_phases(PHASE_PWR_MODEM_RESTART_RETRY, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
		else
			cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
		end if

		'CALLBACK
		cell__callback_modem_off()
		
    end if	
end sub


'***AT SUBROUTINES------------------------------------------------------
sub cell__flush_all_data()
	'MANDATORY: Wait for 1 second	
	'REMARK: 
	'When switching from DATA to COMMAND-mode or vice versa...
	'... Garbage Data may be left behind.
	'For example, if you are in the PPP-mode and you have opened an HTTP-socket to transfer some data. 
	'    When switching back to the COMMAND-mode, most likely, HTTP SOCKET data may be found mixed with the serial-port data.
	'In order to remove this GARBAGE HTTP data:
	'1: wait for a few seconds (tests show that waiting for at least 3 seconds gives the best result)
'	if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS OR CELL__AT_CMD_CONTAINS_ATO) then	'a triple-plus command was sent
'		cell__sleeptimer(3000)
'	end if
	
	'2: FLUSH the (garbage) SERIAL-PORT data
	cell__ser_port_flush_all()
	
end sub
sub cell__ser_port_flush_specified_amountOf_data(garbage_datalen as byte)
	ser.getdata(garbage_datalen)	'flush a specified amount of garbage data
end sub
sub cell__ser_port_flush_all()
	'Define Macros
	#define SERPORT_CONTAINS_DATA ( len(ser.peekdata(255)) <> 0 )
	
	while true
		if ( SERPORT_CONTAINS_DATA ) then	'serial-port contains data
			ser.getdata(255)
		else	'serial-port does NOT contain data
			EXIT WHILE	'exit while-loop
		end if
	wend
end sub

sub cell__sock_release_all()
	'Define variables
	dim s as byte
	
	for s=0 to CELL__SOCK_NUM_MAX
		sock_release(s)
	next s
end sub
sub cell__sock_flush_all()
	'Define variables
	dim s as byte

	'Define Macros
	#define SOCK_CONTAINS_DATA ( len(sock.peekdata(255)) <> 0 )
	
	for s=0 to CELL__SOCK_NUM_MAX
		sock.num=s
		
		while true
			if ( SOCK_CONTAINS_DATA ) then	'serial-port contains data
				sock.getdata(255)
			else	'serial-port does NOT contain data
				EXIT WHILE	'exit while-loop
			end if
		wend
	next s
end sub

sub cell__at_cmd_exec(byref atcmd as string, 
						next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
							next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
								next_parse_phase as en_cell__op_parse_phases)

	'Define variables
	dim at_cgreg_timeout_500ms_max as byte

	'Update variable
    cell__at_cmd = atcmd

	'--------------------------------------------------------------------
	'Check if AT-command `AT+CQREQ?` was executed?
	if (CELL__AT_CMD_CONTAINS_CGREG) then	'answer=yes
		if cell__at_cmd_exec_retry_param > 0 then	'currently at-retry in progress
			'Choose the appropriate maximum timeot
			'REMARK: 
			'	Timeout `at_cgreg_timeout_500ms_max` should be higher for the SIM70xx than for the SIM7500
			if CELL__SIM_MODEL_IS_7000 then
				at_cgreg_timeout_500ms_max = CELL__SIM70xx_AT_CGREG_TIMEOUT_MIN
			else
				at_cgreg_timeout_500ms_max = CELL__AT_CGREG_TIMEOUT_MIN
			end if

			'Wait for a specified amount of time `at_cgreg_timeout_500ms_max` before continuing...
			cell__cgreg_newtime  = sys.timercount	'update new timercounter
			cell__cgreg_elapsedtime = cell__calc_timediff_16b(cell__cgreg_starttime , cell__cgreg_newtime)	'calculate the elapsed time

			'Wait for a specified amount of time `CELL__AT_CGREG_TIMEOUT_MAX` before continuing...
			if cell__cgreg_elapsedtime  <= at_cgreg_timeout_500ms_max then
				EXIT SUB	'do not do anything but EXIT SUBroutine for now...
			end if
		end if
	end if
	'--------------------------------------------------------------------

	'Execute AT-command
    if cell__op_at_phase = PHASE_AT_USERMODE_GET_AND_SEND_CMD then	'AT-command which is sent when in AT-Usermode
		if (atcmd = CELL__AT_GSHD) then	'a graceful shutdown was requested
			cell__stop(PHASE_PWR_PWRKEY_ON, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)	'shutdown modem gracefully
			
			EXIT SUB	'exit subroutine immediately
			
		else	'for all other commands
			cell__at_usermode_send(cell__at_cmd)	'execute AT-command
			
		end if
    else	'AT-command which is sent when in all other modes except for AT-Usermode
		cell__at_send(atcmd)	'execute AT-command
    
	end if

	'***IMPORTANT: update start-timecounter
	cell__starttime = sys.timercount
	cell__isretry_starttime = sys.timercount
	cell__on_ser_data_starttime = sys.timercount
	
	'Reset variable
    cell__reply = CELL__EMPTYSTRING
	
	'Set next phase to transit to (e.g. PHASE_AT_PARSE_MESSAGE)
	cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
end sub

sub cell__sleeptimer(sleeptime as word)
	'Define variables
	dim starttime_ms as dword
	dim currenttime_ms as dword
	dim timeout_ms_max as dword

	'Define Macros
	#define CURRENTTIME_MS (sys.timercountms)

	'Set values
	starttime_ms = sys.timercountms
	timeout_ms_max = starttime_ms + sleeptime	
	
	'Start sleep-timer
	while (CURRENTTIME_MS <= timeout_ms_max)
'		DOEVENTS
	wend
end sub

sub cell__at_send(atcmd as string)
	'Handle the AT-command format
	if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS) then	'trippleplus `+++` command will be sent
		'MANDATORY: sleep for at least 1 second BEFORE sending `+++`
		'***IMPORTANT: when sending a trippleplus `+++` command, do NOT use CRLF!!!
		cell__sleeptimer(1000)
		
		atcmd = atcmd	'do not modify the original AT-command input
		
	else	'no +++ command was sent
		if ( CELL__AT_CMD_CONTAINS_AT OR CELL__AT_CMD_CONTAINS_ATE1 OR CELL__AT_CMD_CONTAINS_ATO ) then	'input arg `atcmd` is `AT, ATE1, ATO` (which is a complete AT-command)
			atcmd = atcmd
		
		else if ( CELL__AT_CMD_CONTAINS_AT_AMPERSAND_E1 OR CELL__AT_CMD_CONTAINS_AT_AMPERSAND_C0 OR CELL__AT_CMD_CONTAINS_AT_CPSMS_0  OR CELL__AT_CMD_CONTAINS_AT_AMPERSAND_D0) then
			atcmd = atcmd
		
		else if ( CELL__AT_CMD_CONTAINS_AT_PLUS ) then	'input arg `atcmd` is a complete AT-command (e.g. AT+CGDATA)
			atcmd = atcmd
			
		else if ( CELL__AT_CMD_CONTAINS_PLUS ) then	'input arg `atcmd` is a partial AT-command containing the AT-name without `AT` but prepended with a plus `+` (e.g. +CGDATA)
			atcmd = CELL__AT + atcmd
			
		else	'input arg `atcmd` is a partial AT-command containing the AT-name only without `AT+` (e.g. CGDATA)
			atcmd = CELL__AT_PLUS + atcmd
			
		end if

		atcmd = atcmd + CELL__CRLF	'append \r\n
		
	end if
	

	'Send AT-command
	ser.num = CELL__DATA_SER_PORT	'set serial-port
    ser.setdata(atcmd) 	'set AT-command
    ser.send	'send AT-command
	
	
	'MANDATORY: sleep for at least 1 second AFTER sending `+++`
	if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS) then	'+++ command was sent
		cell__sleeptimer(1000)
	end if
end sub

sub cell__at_usermode_send(atcmd as string)
	'SMS RELATED
	#if CELL__AT_USERMODE_ISENABLED
		if (cell__sms_msg_inputmode_isOn = true) then
			atcmd = atcmd	'send the original input command
			
			GOTO SET_AND_SEND_HANDLER
		end if
	#endif
	
	'ALL OTHER AT-COMMANDS (NOT RELATED TO SMS)
	if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS) then	'trippleplus `+++` command will be sent
		'Sleep (Mandatory BEFORE sending triple plus `+++`)
		'***NOTE: when sending a trippleplus `+++` command, do NOT use CRLF!!!
		cell__sleeptimer(1000)
		
		atcmd = atcmd
		
	else	'no +++ command was sent
		atcmd = atcmd + CELL__CRLF	'append \r\n
		
	end if

SET_AND_SEND_HANDLER:
	'Set and Send AT-command
	ser.num = CELL__DATA_SER_PORT	'set serial-port
	ser.setdata(atcmd) 	'set AT-command
	ser.send	'send AT-command
	
	
	if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS) then	'+++ command was sent
		cell__sleeptimer(1000)	'sleep (Mandatory AFTER sending triple plus `+++`)
	end if
end sub

sub cell__at_parse_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
							next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
								next_parse_phase as en_cell__op_parse_phases)



'---Define variable
	dim atreply_checkitem as string(CELL__16b_LEN) = CELL__EMPTYSTRING

'---Parse AT-reply Messsage
    cell__at_get_cleandata(atreply_checkitem)
	
'---Handle the parsed AT-reply message
    if ( atreply_checkitem = CELL__SIMPIN or atreply_checkitem = CELL__SIMPUK ) then	'AT replied with an error `SIM PIN` or `SIM PUK`
		#if CELL__DEBUGPRINT_AT_ISENABLED
			cell__debugprint_at_phase(PHASE_AT_FREE_INPUT, cell__at_cmd, cell__reply)	'PRINT `AT-command` + `AT-reply`
		#endif
		
		'Initialize parameters, variables and booleans
		cell__init_param_var_bool()
		
		'Set next phase to transit to (e.g. PHASE_AT_CPIN)
		'***IMPORTANT: set all other phases to IDLE		
		cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_CPIN, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

		'CALLBACK
		cell__callback_at_reply_contains_error()
		
		'EXIT SUBROUTINE
		EXIT SUB
		
    else if ( atreply_checkitem = CELL__OK or atreply_checkitem = CELL__CONNECT_BAUDRATE or atreply_checkitem = CELL__CONNECT or atreply_checkitem = CELL__GREATERTHAN ) then	'AT replied with `OK` or `CONNECT`
		'Sim7000 Handler
		if (CELL__AT_REPLIED_WITH_SIM7000) then	'SIM7000 detected
			cell__sim7000_isDetected = true	'change boolean to true
		end if

		'Get Voltage
		if (CELL__AT_CMD_CONTAINS_CBC) then	'read the voltage value of the powersupply/battery
			cell__at_get_voltage()	'get the voltage
		end if	
		
		'Debug print
		#if CELL__DEBUGPRINT_AT_ISENABLED
			cell__debugprint_at_phase(PHASE_AT_FREE_INPUT, cell__at_cmd, cell__reply)	'PRINT `AT-command` + `AT-reply`
		#endif


		'CALLBACK
		cell__callback_at_reply()


'-------Special attention to certain AT-commands:
		if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS) then	'Triple PLUS `+++` was executed
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_AT_CMD_CONTAINS_TRIPLEPLUS, cell__at_cmd, CELL__EMPTYSTRING)	'PRINT
			#endif

			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'Set next-phase to transit to
			'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
			
			'CALLBACK
			#if CELL__PPP_MODE_ISENABLED
				cell__callback_after_switching_from_DATA_to_CMD()
			#endif

		else if (CELL__AT_CMD_CONTAINS_ATO) then	'Triple PLUS `+++` was executed
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_AT_CMD_CONTAINS_ATO, cell__at_cmd, CELL__EMPTYSTRING)	'PRINT		
			#endif

			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'Set next-phase to transit to
			'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
			
			'CALLBACK
			#if CELL__PPP_MODE_ISENABLED			
				cell__callback_after_switching_from_CMD_to_DATA()
			#endif

		else if (CELL__AT_CMD_CONTAINS_CGREG) then	'AT+CGREG command was executed
			'REMARK: it is preferable for CGREG to have the value `CGREG: 0,1`.
			'But should this NOT be the case, ...
			'...for example the value is `CGREG: 0,2` instead of `CGREG: 0,1`,...
			'...then it is still possible to have a successful:
			'1. LCP NEGO
			'2. PAP NEGO
			'3. IPCP NEGO
			'4. PING
			'5. PPP CONNECTION
			if NOT CELL__AT_REPLIED_WITH_CGREG_0_1 then	'match was NOT found
				'Retry executing & parsing AT+CGREG? for a specified number of times...
				'... by running `cell__at_parse_message_retry`
				cell__at_parse_message_retry(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
			else	'match was found
				'In case `CGREG: 0,1` has been replied, then set boolean to back to false
				if (cell__at_cgreg_dblchk_isEnabled = true) then
					cell__at_cgreg_dblchk_isEnabled = false	'reset boolean
				end if
			end if

#if CELL__AT_USERMODE_ISENABLED

		else if (CELL__AT_CMD_CONTAINS_CMGS) then	'AT+CMGS command was executed (this indicates the beginning of the SMS-message mode)
			cell__sms_msg_inputmode_isOn = true

			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'Set next-phase to transit to
			'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
			
		else if (CELL__AT_CMD_CONTAINS_SUBSTITUTE_CHAR) then	'char(26) was executed (this indicates the end of the SMS-message mode
			cell__sms_msg_inputmode_isOn = false
			
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_SMS_SENT, CELL__SMS, CELL__EMPTYSTRING)
			#endif
			
'???-------->CALLBACK
			'NOTE: not sure if this callback can be moved all the way to end of this section.
			'		Right now can not test it yet due to no available SIM-card with SMS
			cell__callback_at_usermode_sms_sent_notif()

			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'Depending on whether the current-phase, set the next phase to...
			'...`PHASE_PARSE_SMS_MESSAGE` or `PHASE_PARSE_IDLE`.
			'REMARK:
			'1. after execution of AT+CMGS: current-phase = `PHASE_PARSE_IDLE`
			'2. after execution of AT+CNMI: current-phase = `PHASE_PARSE_SMS_MESSAGE`
			'	Let's assume that `auto-reply` has been configured, in case...
			'...an SMS-message has been received, an auto-reply would be sent to the sender,...
			'...AFTER THAT the next-phase should be set back to `PHASE_PARSE_SMS_MESSAGE`
			if (cell__parse_sms_message_phase_isON = true) then	'this part belongs to `AT+CNMI`
				#if CELL__DEBUGPRINT_AT_ISENABLED
					cell__debugprint_at_phase(PHASE_SMS_RDY_TO_RCV, CELL__SMS, CELL__EMPTYSTRING)	'PRINT
				#endif

				'Set next-phase to PHASE_PARSE_SMS_MESSAGE
				cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_SMS_MESSAGE)
				
			else	 'this part belongs to the `AUTOREPLY`
				'Set next-phase to transit to
				'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
				'REMARK: next-phase is NOT set to PHASE_PARSE_SMS_MESSAGE due to a possible SEND-RECEIVE SMS LOOP
				cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
				
			end if

		else if (CELL__AT_CMD_CONTAINS_CNMI) then
			cell__parse_sms_message_phase_isON = true	'IMPORTANT: set to true!!!
		
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_SMS_RDY_TO_RCV, CELL__SMS, CELL__EMPTYSTRING)	'PRINT		
			#endif

			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'IMPORTANT: set next-phase to `PHASE_PARSE_SMS_MESSAGE`
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_SMS_MESSAGE)
			
		else if (CELL__AT_CMD_CONTAINS_CMGR) then
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_SMS_RDY_TO_RCV, CELL__SMS, CELL__EMPTYSTRING)	'PRINT		
			#endif

'???-------->CALLBACK
			'NOTE: not sure if this callback can be moved all the way to end of this section.
			'		Right now can not test it yet due to no available SIM-card with SMS
			'AUTO-REPLY after reading sms-message
			cell__callback_at_usermode_sms_auto_reply()	'CALLBACK

			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'IMPORTANT: set next-phase to `PHASE_PARSE_SMS_MESSAGE`
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_SMS_MESSAGE)
			
		else if (CELL__AT_CMD_CONTAINS_CMGD) then
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_SMS_RDY_TO_RCV, CELL__SMS, CELL__EMPTYSTRING)	'PRINT		
			#endif
			
			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'IMPORTANT: set next-phase to `PHASE_PARSE_SMS_MESSAGE`
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_SMS_MESSAGE)
			
#endif
		else
			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'Set next-phase to transit to
			'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
			cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
			
		end if

'-------Enable Fast-Load (if needed)
		'Note:	if `CELL__AT_USERMODE_ISENABLED` then FAST LOAD MUST be DISABLED. 
		'		The reason for this is to prevent recursive warnings.
		#if CELL__AT_USERMODE_ISENABLED=0
			#if CELL__AT_FAST_LOAD_ISENABLED
				cell__at_proc_sys_timer()
			#endif
		#endif

#if CELL__AT_USERMODE_ISENABLED
	else if (atreply_checkitem = CELL__SMS) then
		#if CELL__DEBUGPRINT_AT_ISENABLED
			'Note: `cell__at_cmd` contains the SMS-message itself!
			cell__debugprint_at_phase(PHASE_AT_FREE_INPUT, CELL__SMS, cell__at_cmd)
		#endif

		'Initialize parameters, variables and booleans
		cell__init_param_var_bool()
		
		'Set next phase to transit to
		'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
		cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
#endif

    else if ( atreply_checkitem = CELL__ERROR) then
		'Debug print
		#if CELL__DEBUGPRINT_AT_ISENABLED
			cell__debugprint_at_phase(PHASE_AT_FREE_INPUT, cell__at_cmd, cell__reply)	'PRINT `AT-command` + `AT-reply`
		#endif
		
		'ERROR handler
		'1. an error occured because PIN-code was not correct...
		'...In that case put modem in IDLE-mode.
		'2. for all other cases, restart modem...
		'...However, if `cell__modem_restart_retry_param` has exceeded `CELL__MODEM_RESTART_RETRY_MAX`, then...
		'...put modem in IDLE-mode.
		'REMARK: if `CELL__MODEM_RESTART_RETRY_MAX = CEL__INF`, then modem will keep on restarting.
		if (CELL__AT_CMD_CONTAINS_CPIN) then	
			'Initialize parameters, variables and booleans
			cell__init_param_var_bool()
			
			'Set all next-phases to IDLE
			cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

			'CALLBACK
			cell__callback_at_reply_contains_error()	

		else
			cell__modem_restart(PHASE_PWR_PWRKEY_ON)	'initiate a modem-restart
			
		end if

		
		'EXIT SUBROUTINE
		EXIT SUB
		
	else	'NO MATCH was found
		cell__newtime = sys.timercount	'update new timercounter
		cell__elapsedtime = cell__calc_timediff_16b(cell__starttime, cell__newtime)	'calculate the elapsed time

		if cell__elapsedtime > CELL__AT_RETRY_TIMEOUT_MAX then	'maximum timeout has been EXCEEDED
			'Timeout has Exceeded, proceed...
			'Set next-phase to transit to
			'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
			cell__at_parse_message_retry(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
		end if
		
		'EXIT SUBROUTINE
		EXIT SUB
		
    end if
end sub

sub cell__at_get_cleandata(byref atreply_checkitem as string(CELL__16b_LEN))
	'Define variables
    dim atcmd_part, atreply_part as byte
	dim atreply_lead_crlf_startpos as byte
	dim atreply_trail_crlf_startpos as byte
    dim atreply_checkitem_num as byte
	dim good_datalen as byte
	
'--------------------------------------------------------------------
	'BEFORE CONTINUING: check if a triple `+++` was sent
	if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS) then
		atcmd_part = 1
		
		GOTO ATREPLY_CHECKITEM_HANDLER
	end if
'--------------------------------------------------------------------


	#if CELL__AT_USERMODE_ISENABLED	'currently in AT-Usermode
		'IMPORTANT: check if `cell__at_cmd` contains `CMGS`
		'Remark:
		'	1. AT+CMGS="0123456789" is sent --> expected AT-reply is a `GREATER THAN sign` (without leading AT+CMGS command)
		'	2. Once a `GREATHER THAN sign` has been received,...
		'	   ... type the SMS-message which you want to send --> expected AT-reply is the SMS-message itself
		'	3. Once you are ready, send a `SUBSTITUTE sign (chr(26))` --> expected AT-reply is `+CMGS:<seq-num>\r\nOK` 
		if (CELL__AT_CMD_CONTAINS_CMGS) then	'SMS-message mode is OFF; cell__at_cmd contains `CMGS`
			atcmd_part = 1
			
			GOTO ATREPLY_CHECKITEM_HANDLER
		else 
			'SMS-message mode is On (which means whether an `SMS-message` OR `chr(26)` was sent)
			if (cell__sms_msg_inputmode_isOn = true) then
				if NOT (CELL__AT_CMD_CONTAINS_SUBSTITUTE_CHAR) then	'an SMS-message was input
					atreply_checkitem = CELL__SMS

					good_datalen=len(cell__at_cmd)	'set data-length to be retrieved

					GOTO GETDATA_HANDLER

				else	'char(26) was sent
					atcmd_part = 1
					
					GOTO ATREPLY_CHECKITEM_HANDLER
				end if
			end if
		end if
	#endif


ATCMD_CHECKITEM_HANDLER:
	atcmd_part = instr(1, ser.peekdata(255), cell__at_cmd, 1)


ATREPLY_CHECKITEM_HANDLER:
	'Check if a match can be found for one of the `atreply_checkitem`s
    if atcmd_part > 0 then	'match was found
		if (atreply_checkitem = CELL__EMPTYSTRING) then	'atreply_checkitem is NOT preset with value `CELL__SMS`
			'Find LEADING CRLF
			atreply_lead_crlf_startpos = instr(atcmd_part, ser.peekdata(255), CELL__CRLF, 1)
			
			'initial counter value
			atreply_checkitem_num = 1
			
			'Cycle thru each checkitem and find a match (if any)
			while true
				select case atreply_checkitem_num
					case 1:
						atreply_checkitem = CELL__OK
					case 2:
						if ( CELL__SIM_MODEL_IS_7000 ) then	'SIM7000 detected
							atreply_checkitem = CELL__CONNECT
						else
							atreply_checkitem = CELL__CONNECT_BAUDRATE
						end if						
					case 3:
						atreply_checkitem = CELL__GREATERTHAN
					case 4:
						atreply_checkitem = CELL__SIMPIN
					case 5:
						atreply_checkitem = CELL__SIMPUK
					case 6:
						atreply_checkitem = CELL__ERROR
					case 7:
						atreply_checkitem = CELL__EMPTYSTRING
						
						EXIT SUB
					
				end select

				'Find a match for the current `atreply_checkitem`
				atreply_part = instr(atcmd_part, ser.peekdata(255), atreply_checkitem, 1)
				
				if atreply_part > 0 then	'match was found
					'FLUSH DATA
'					if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS) then
'						if (atreply_part > 1) then	'this would mean that there are LEADING TRASH DATA
'							ser.getdata(atreply_part-1)	'FLUSH TRASH DATA
'						end if
'					end if

					if (atreply_lead_crlf_startpos > 0) then	'leading CRLF was found
						if (atreply_lead_crlf_startpos < atreply_part) then	'CRLF precedes `atreply_checkitem`
							cell__ser_port_flush_specified_amountOf_data(atreply_lead_crlf_startpos + 1)	'FLUSH LEADING TRASH-DATA
							
						else	'`atreply_checkitem` preceeds CRLF
							cell__ser_port_flush_specified_amountOf_data(atreply_part - 1)	'FLUSH LEADING TRASH-DATA
							
						end if
					else	'leading CRLF was NOT found
						if (atreply_part > 1) then	'start position of `atreply_checkitem` is greater than `1`
							cell__ser_port_flush_specified_amountOf_data(atreply_part - 1)	'FLUSH LEADING TRASH-DATA
							
						end if
					end if
				
					EXIT WHILE
				else	'match was NOT found				
					if (atreply_checkitem = CELL__EMPTYSTRING) then	'this is the last `atreply_checkitem`
						EXIT SUB
						
					else
						atreply_checkitem_num = atreply_checkitem_num + 1	'increment index
						
					end if
				end if			
			wend
		
		end if
		
    else	'match was NOT found
		EXIT SUB
		
    end if
	
	
TRAIL_CRLF_HANDLER:
	'Since LEADING GARBAGAE DATA have been flushed previously, the data start-position=1.
	'REMARK: to know the trailing CRLF is important since this marks the "END of the GOOD DATA"
	atreply_trail_crlf_startpos = instr(1, ser.peekdata(255), CELL__CRLF, 1)
	good_datalen = atreply_trail_crlf_startpos - 1
	
	
	'A match was found earlier...
	'...Now get all the data which is currently in the buffer
GETDATA_HANDLER:    
	cell__at_get_cleandata_filter(good_datalen)
	
	

end sub
sub cell__at_get_cleandata_filter(good_datalen as byte)
	if (CELL__AT_CMD_CONTAINS_TRIPLEPLUS OR CELL__AT_CMD_CONTAINS_ATO) then	'a triple-plus command was sent
		cell__reply = ser.getdata(good_datalen)	'basically only get the 'OK' reply
		
		cell__flush_all_data()	'FLUSH ALL OTHER (GARBAGE) DATA
		
	else	'for all other AT-commands
		cell__reply = ser.getdata(255)
		
	end if

    cell__trim_lstring(cell__reply, cell__at_cmd)	'strip off leading AT-command (if any)

    cell__ltrim_crlf(cell__reply)	'strip off LEFT \r\n (if any)
	
    cell__rtrim_crlf(cell__reply)	'strip off RIGHT \r\n (if any)
	
    cell__substitute_char(cell__reply, CELL__CR, CELL__DOT)	'replace \r with .
	
    cell__substitute_char(cell__reply, CELL__LF, CELL__DOT)	'replace \n with .
end sub

sub cell__at_parse_message_retry(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
										next_parse_phase as en_cell__op_parse_phases)
	
	'Choose the maximum retry value
	#if CELL__AT_USERMODE_ISENABLED	
		if (cell__sms_msg_inputmode_isOn = true) then
			cell__at_retry_parse_max = CELL__SMS_RETRY_MAX
		else
			cell__at_retry_parse_max = CELL__AT_RETRY_MAX
		end if
	#else
		cell__at_retry_parse_max = CELL__AT_RETRY_MAX
	#endif
	
	'INCREMENT
	cell__at_retry_param = cell__at_retry_param + 1
	
    if cell__at_retry_param <= cell__at_retry_parse_max then	'max. number of (PARSE) retries not exceeded yet
		'***IMPORTANT: update start-timecounter
        cell__starttime = sys.timercount

		if ( CELL__AT_CMD_CONTAINS_CGREG OR CELL__AT_CMD_CONTAINS_TRIPLEPLUS OR CELL__AT_CMD_CONTAINS_ATO ) then
			GOTO EXEC_AND_RETRY_HANDLER
		else
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_AT_PARSE_RETRY, cell__at_cmd, CELL__EMPTYSTRING)
			#endif
		end if
		

		'Enable Fast-Load (if needed)
		'Note:	if `CELL__AT_USERMODE_ISENABLED` then FAST LOAD MUST be DISABLED. 
		'		The reason for this is to prevent recursive warnings.
		#if CELL__AT_USERMODE_ISENABLED=0
			#if CELL__AT_FAST_LOAD_ISENABLED
				cell__at_proc_sys_timer()
			#endif
		#endif
		
	else	'max. number of (PARSE) retries EXCEEDED

EXEC_AND_RETRY_HANDLER:

		if ( CELL__AT_CMD_CONTAINS_CGREG OR CELL__AT_CMD_CONTAINS_TRIPLEPLUS OR CELL__AT_CMD_CONTAINS_ATO ) then
			cell__at_retry_exec_and_parse_max = CELL__AT_CGREG_EXEC_RETRY_MAX
		else
			cell__at_retry_exec_and_parse_max = CELL__AT_CMD_EXEC_RETRY_MAX
		end if

		'INCREMENT
		'Remark: parameter is resetted in `cell__init_param_var_bool`
		cell__at_cmd_exec_retry_param = cell__at_cmd_exec_retry_param + 1
	
		'Check if counter `cell__at_cmd_exec_retry_param` is still within the acceptable threshold
		if (cell__at_cmd_exec_retry_param <= cell__at_retry_exec_and_parse_max) then	'max. number of EXEC & PARSE retries not exceeded yet
			'Reset PARSE retry-counter
			cell__at_retry_param = 0
		
			'PRINT
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_AT_CMD_EXEC_RETRY, cell__at_cmd, CELL__EMPTYSTRING)
			#endif
		
			if ( CELL__AT_CMD_CONTAINS_CGREG ) then	'AT+CGREG? was executed
				'REMARK: it is preferable for CGREG to have the value `CGREG: 0,1`.
				'But should this NOT be the case, ...
				'...for example the value is `CGREG: 0,2` instead of `CGREG: 0,1`,...
				'...then it is still possible to have a successful:
				'1. LCP NEGO
				'2. PAP NEGO
				'3. IPCP NEGO
				'4. PING
				'5. PPP CONNECTION
				'MANDATORY: Set next phase to transit...
				'***IMPORTANT: make sure to set `cell__op_parse_phase` to `PHASE_PARSE_IDLE`
				'***IMPORTANT: update start-timecounter
				cell__cgreg_starttime = sys.timercount

				#if CELL__AT_USERMODE_ISENABLED
					'Set next-phase to `PHASE_AT_USERMODE_RETRY`
					cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_USERMODE_RETRY, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
				#else
					cell__update_op_next_phases(PHASE_PWR_IDLE, cell__op_at_phase_bck, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
				#endif

			else if ( CELL__AT_CMD_CONTAINS_TRIPLEPLUS OR CELL__AT_CMD_CONTAINS_ATO ) then	'AT+CGREG? OR triple-plus +++ was executed
				cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_USERMODE_RETRY, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
			
			else
				cell__update_op_next_phases(PHASE_PWR_IDLE, cell__op_at_phase_bck, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
			
			end if
			
		else	'max. number of EXEC & PARSE retries EXCEEDED
			if (CELL__AT_CMD_CONTAINS_CGREG) then
				if (cell__at_cgreg_dblchk_isEnabled = true) then	'
					cell__at_cgreg_dblchk_isEnabled = false
					
					EXIT SUB
				end if
			end if
			
			
			'PRINT
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_AT_CMD_EXEC_RETRY_EXCEEDED, cell__at_cmd, CELL__EMPTYSTRING)
			#endif
		
			'RESTART MODEM
			cell__modem_restart(PHASE_PWR_PWRKEY_ON)	
			
		end if
	end if
end sub

sub cell__at_send_multiple_commands_without_timeout(byref atcmd as string, numOf_times as byte,
														next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
															next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
																next_parse_phase as en_cell__op_parse_phases)
	
	'Define and initialize parameter
    dim n as byte = 1

	'Send AT-command: AT a specified number of times
    while n < numOf_times
        cell__at_send(atcmd)	'send AT-command
		
        cell__flush_all_data()	'FLUSHDATA
		
        n = n + 1	'increment by 1
    wend

	'Set next phase to transit to
    cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
end sub

sub cell__at_get_voltage()
	'Define variables
    dim leading_data as string(CELL__2b_LEN)
    dim trailing_data as string(CELL__4b_LEN)

    if NOT CELL__SIM_MODEL_IS_7000 then	'if the SIM-model is NOT SIM7000
    EXIT SUB	'exit this subroutine
    end if
	
    cell__reply = cell__get_string_between_2chars(cell__reply, 2, CELL__COMMA, CELL__DOT)	'get the voltage which should be between the 2nd and 3rd comma

    trailing_data = right(cell__reply, 3)	'get the trailing part of `cell__reply`, which is 3 Bytes in length
    leading_data = left(cell__reply, len(cell__reply) - len(trailing_data))	'get the leading part of the `cell__reply`

    cell__reply = leading_data + CELL__DOT + trailing_data + CELL__UNIT_VOLT	'append `V`

end sub

sub cell__at_ifc(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
					next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
						next_parse_phase as en_cell__op_parse_phases)

    if (ser.flowcontrol <> PL_SER_FC_RTSCTS) then	'serial-port's flow-control is disabled
		ser.rxclear()	'clear rx-buffer
		ser.txclear()	'clear tx-buffer

		cell__at_cmd_exec(CELL__AT_IFC_1,
							next_pwr_phase, next_at_phase,
								next_ppp_phase, next_gps_phase,
									next_parse_phase)	'enable local data flow-control
									
		io.num = ser.rtsmap	'set RTS
		io.enabled = YES	'enable RTS
		ser.enabled = NO	'disable serial-port
		ser.flowcontrol = PL_SER_FC_RTSCTS	'enable serial-port's flow-control
		ser.enabled = YES	'enable serial-port

    else	'serial-port's flow-control is enabled
		cell__at_cmd_exec(CELL__AT_IFC_Q,
							next_pwr_phase, next_at_phase,
								next_ppp_phase, next_gps_phase,
									next_parse_phase)	'check local data flow-control current setting

    end if
end sub


'***PPP SUBROUTINES-----------------------------------------------------
#if CELL__PPP_MODE_ISENABLED
'---PPP PARSE
    sub cell__ppp_at_cgpaddr_retrieve_ip()
		'Define variables
        dim data_lpos as byte
        dim data_rpos as byte
		
        data_lpos = instr(1, cell__at_cgpaddr_ip, CELL__COMMA, 1)	'find the position of the 1st comma in `cell__at_cgpaddr_ip` value
		
        if data_lpos > 0 then	'comma was found
			data_rpos = instr(1, cell__at_cgpaddr_ip, CELL__4DOT_OK, 1)	'get the position of `....OK`
			
			if data_rpos > 0 then	'`....OK` was found
				cell__at_cgpaddr_ip = mid(cell__at_cgpaddr_ip, (data_lpos + 1), (data_rpos-data_lpos-1))	'strip off everything except for the IP-address
			else	'`....OK` was NOT found
				cell__at_cgpaddr_ip = CELL__EMPTYSTRING
			end if
		else	'comma was NOT found
			cell__at_cgpaddr_ip = CELL__EMPTYSTRING
        end if
    end sub

'---PPP SEND
    function cell__ppp_generate_fcs(byref ppp_packet_format as string(CELL__128b_LEN)) as word
		'Define variables
        dim p as word
        dim i as byte
        dim ppp_packet_format_item as byte
		
		'Initial value
        cell__ppp_generate_fcs = CELL__PPP_INIT_FCS
		
		'Generate the FCS for the given PPP Packet Format
        for p = 1 to len(ppp_packet_format)	'cycle through each character of the PPP Packet Format
            ppp_packet_format_item = asc(mid(ppp_packet_format, p, 1))	'for each index p, get one character and convert to ASCII
			
            cell__ppp_generate_fcs = (cell__ppp_generate_fcs XOR ppp_packet_format_item)	'exclusive-OR `cell__ppp_generate_fcs` with `ppp_packet_format_item`
			
            for i = 0 to 7	'cycle 8 times and process the current character of the PPP Packet Format
                if (cell__ppp_generate_fcs AND &h01) = &h01 then	'LSB is set to `1`
					cell__ppp_generate_fcs = (cell__ppp_generate_fcs SHR 1)	'FIRST: shift right by 1
					cell__ppp_generate_fcs = (cell__ppp_generate_fcs XOR CELL__PPP_CRC16_POLYNOMIAL)	'THEN: XOR with `CRC16_POLYNOMIAL`
                else	'LSB is set to `0`
					cell__ppp_generate_fcs = (cell__ppp_generate_fcs SHR 1)	'shift right by 1
                end if
            next i
        next p
    end function

    sub cell__ppp_append_fcs(byref ppp_packet_format as string(CELL__128b_LEN), fcs as word)
		'Step 1: get the BIT-REVERSE value of the FCS
		'For Example: 
		'	current value: 	0x36A5
		'	new value:		0xA536
        fcs = ( (fcs SHL 8) OR ((fcs SHR 8) AND &hff) )
		
		'Step 2: exclusive-OR FCS with 0xFFFF
        fcs = fcs XOR &hffff
		
		
		'Step 3: append the REVERSED FCS to the PPP Packet Format
		'For example:
		'(before) ppp_ppp_packet_format = 0xFF3C021100A260000
		'
		'fcs = 0xA536
		'	(fcs SHR 8) = A5 = LEFT 8-bit part of `fcs`
		'	(fcs AND &hff) = 36: RIGHT 8-bit part of `fcs`
		'
		'(after) ppp_ppp_packet_format + fcs = 0xFF3C021100A260000A536
        ppp_packet_format = ppp_packet_format + chr(fcs SHR 8) + chr(fcs AND &hff)
    end sub

    sub cell__ppp_insert_escapechar(byref ppp_packet_format as string)
		'Define variables
        dim p as word
        dim ppp_packet_format_item as byte

        for p = 1 to len(ppp_packet_format)	'cycle through each character of the PPP Packet Format
            ppp_packet_format_item = asc(mid(ppp_packet_format, p, 1))	'for each index p, get one character and convert to ASCII
			
			'Insert an Escape Character in the following situations:
            select case ppp_packet_format_item	
                case CELL__PPP_FLAG:	'character is a FLAG: 0x7E
					ppp_packet_format = left( ppp_packet_format, p-1 ) + chr(CELL__PPP_ESC_CHAR) + chr(&h5E) + right( ppp_packet_format, len(ppp_packet_format)-p ) 
						
					p = p + 1	'IMPORTANT: skip this newly added char and go to the next one
                case CELL__PPP_ESC_CHAR:	'character is an Escape Character: 0x7D
					ppp_packet_format = left( ppp_packet_format, p-1 ) + chr(CELL__PPP_ESC_CHAR) + chr(&h5D) + right( ppp_packet_format, len(ppp_packet_format)-p ) 
						
					p = p + 1	'IMPORTANT: skip this newly added char and go to the next one
                case else:
					if ppp_packet_format_item < &h20 then	'any other character with a hex-value < 0x20
						ppp_packet_format_item = (ppp_packet_format_item XOR &h20)	'first Exclusive-OR with 0x20
							
								'Insert an Escape Character and the XOR'ed `ppp_packet_format_item`
						ppp_packet_format = left( ppp_packet_format, p-1 ) 
												+ chr(CELL__PPP_ESC_CHAR) 
													+ chr(ppp_packet_format_item) 
														+ right( ppp_packet_format, len(ppp_packet_format)-p )

						p = p + 1	'IMPORTANT: skip this newly added char and go to the next one
					end if
            end select
        next p
    end sub

    sub cell__ppp_increment_id()
        if cell__ppp_sender_id < CELL__PPP_ID_MAX then	'current ID is less than 255
			cell__ppp_sender_id = cell__ppp_sender_id + 1	'increment ID by 1
        else	'current ID is 255
			cell__ppp_sender_id = 0	'set ID to 0
        end if
    end sub

    sub cell__ppp_send_data(ppp_protocol as word, ppp_code as en_cell__op_ppp_codes, ppp_sender_id as byte, byref data_packet_format as string,
								next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, 
										next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
								

		'Define variables
        dim ppp_packet_format as string(CELL__128b_LEN)
        dim ppp_length as word
        dim fcs as word

		
		'Initialization
		if (cell__op_ppp_phase_bck = PHASE_PPP_LCP_NEGOTIATION) then
			'Initialize parameters once when sending the 1st of the PPP-sequence
			cell__init_ppp()
		end if
		

		'Generate <Protocol> + <Information> Fields:
		'Note: <Information> = <Code> + <Identifier> + <Length> + <Data>
		'+----------+----------------------------------------------------+   +----------+------+------------+--------+------------+
		'| Protocol |				 Information 						 | = | Protocol | Code | Identifier | Length | Data field |
		'+----------+----------------------------------------------------+   +----------+------+------------+--------+------------+
		'																		2Bytes	  1Byte     1Byte	   2Bytes	  xBytes
		'----------------+---------------------------------------------
		'Protocol values |	Protocol Type
		'----------------+---------------------------------------------
		'0021 				Internet Protocol
		'002b 				Novell IPX
		'002d				Van Jacobson Compressed TCP/IP
		'002f 				Van Jacobson Uncompressed TCP/IP
		'8021 				Internet Protocol Control Protocol
		'802b 				Novell IPX Control Protocol
		'8031 				Bridging NC
		'C021 				Link Control Protocol
		'C023 				Password Authentication Protocol
		'C223 				Challenge Handshake Authentication Protocol

		'Compose <Protocol> + <Information Field>
        if ppp_protocol  = CELL__PPP_PROTO_IP then
			'For IP Protocol, the <Code>, <Identifier>, and <Length> are excluded
            ppp_packet_format = chr(ppp_protocol SHR 8) + chr(ppp_protocol AND &hff) + data_packet_format
		else
			'EXPLANATION for: ppp_packet_format = chr(ppp_protocol SHR 8) + chr(ppp_protocol AND &hff) 
			'										+ chr(ppp_code) 
			'											+ chr(ppp_sender_id) 
			'												+ chr(ppp_length SHR 8) + chr(ppp_length AND &hff) 
			'													+ data_packet_format
			'ppp_protocol (e.g. LCP = 0xC021) (2 Bytes)
			'0xC0 = (ppp_protocol SHR 8)
			'0x21 = (ppp_protocol AND &hff)
			'
			'Information Field = LCP Packet Format
			'	+------------------------------------------+   +------+------------+--------+-------------+
			'	|				Information				   | = | Code | Identifier | Length | Data Packet |
			'	+------------------------------------------+   +------+------------+--------+-------------+
			'	ppp_code (1 byte):
			'	Here is a short list of Code Field:
			'		Configure-REQ:		0x01 = 1
			'		Configure-ACK:		0x02 = 2
			'		Configure-NAK:		0x03 = 3
			'		Configure-REJECT:	0x04 = 4
			'		Echo-REQ:			0x09 = 9
			'		Reserved:			0x0C = 12
			'	ppp_id (1 byte) = Identifier
			'	LCP Packet Format Length (2 Bytes = Length of (Code field + Identifier field + Length field + Data field)
			'	
			'	data_packet_format = data packet containing:
			'		Data-type: Configuration Option Type
			'		Data-length: Total length of data packet field (=Type, Length, and Data)
			'		Data-content: Contents of Configuration Option
			'
			'For more information, please check the following links: 
			'	- https://support.huawei.com/enterprise/en/doc/EDOC1000177807/a57612e/ppp-packet-format
			'	- https://tools.ietf.org/pdf/rfc1172.pdf
			'
			'Remark:
			'	Protocol: 2 Bytes. When converting from Word to String, Protocol has to be splitted up into 2 parts (8-bits each).
			'	The result is therefore: chr(ppp_protocol SHR 8) + chr(ppp_protocol AND &hff)
			'	PPP_length: 2 Bytes. When converting from Word to String, Protocol has to be splitted up into 2 parts (8-bits each).
			'	The result is therefore: chr(ppp_length SHR 8) + chr(ppp_length AND &hff)
            ppp_length = CELL__4b_LEN + len(data_packet_format)	'protocol (2 bytes) is NOT is included in the length
			
            ppp_packet_format = chr(ppp_protocol SHR 8) + chr(ppp_protocol AND &hff)
									+ chr(ppp_code) 
										+ chr(ppp_sender_id) 
											+ chr(ppp_length SHR 8) + chr(ppp_length AND &hff) 
												+ data_packet_format
        end if	


		'Update variable `cell__ppp_sender`
        if ppp_code = PPP_CONFREQ then 
            cell__ppp_sender = ppp_packet_format
        end if


		'Append <Address> + <Control> to the current `ppp_packet_format`:
		'+---------+---------+----------+------------------------------------------+
		'| Address | Control | Protocol |				Information				   |
		'+---------+---------+----------+------------------------------------------+
        ppp_packet_format = chr(&hFF) + chr(&h03) + ppp_packet_format


		'Generate <FCS> (Frame Check Sequence) field:
        fcs = cell__ppp_generate_fcs(ppp_packet_format)	'generate and append FCS to `ppp_packet_format`


		'Append FCS to the current `PPP Packet Format`:
		'+---------+---------+----------+------------------------------------------+-----+ 
		'| Address | Control | Protocol |				Information				   | FCS |
		'+---------+---------+----------+------------------------------------------+-----+
        cell__ppp_append_fcs(ppp_packet_format, fcs)
		
		
		'Finally Insert Escape Character wherever needed
        cell__ppp_insert_escapechar(ppp_packet_format)	


		'Prepend and Append `Flags` to the current `PPP Packet Format`:
		'+------+---------+---------+----------+------------------------------------------+-----+------+ 
		'| Flag | Address | Control | Protocol |				Information				  | FCS | Flag |
		'+------+---------+---------+----------+------------------------------------------+-----+------+ 
        ppp_packet_format = chr(CELL__PPP_FLAG) + ppp_packet_format + chr(CELL__PPP_FLAG)


		'Set data and send
        ser.setdata(ppp_packet_format)
        ser.send
		
		
		'INCREMENT
        if ppp_protocol = CELL__PPP_PROTO_IP or ppp_code = PPP_CONFREQ then
            cell__ppp_increment_id()
        end if


		'Set next phase to transit to (e.g. PHASE_PARSE_PPP_MESSAGE)
        cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
    end sub

    sub cell__ppp_ipcp_send_confreq(ppp_protocol as word, ppp_code as en_cell__op_ppp_codes, ppp_sender_id as byte, byref data_packet_format as string(CELL__128b_LEN),
										next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, 
												next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
		'Define variables
        dim newdata_packet_format as string(CELL__128b_LEN)
		
        if cell__at_cgpaddr_ip <> CELL__EMPTYSTRING then	'not an EMPTY value
			'Compose the new data packet format
			newdata_packet_format = CELL__PPP_IPCP_OPTION_IP_CODE + cell__at_cgpaddr_ip
		
			'Substitute the data packet field of `data_packet_format` with this `newdata_packet_format`
			cell__ppp_substitute_data(data_packet_format, newdata_packet_format, PPP_CONFNAK)
        end if

		'Send IPCP CONFREQ
        cell__ppp_send_data(ppp_protocol, ppp_code, ppp_sender_id, data_packet_format,
								next_pwr_phase, next_at_phase, 
									next_ppp_phase, 
										next_gps_phase, next_parse_phase)
    end sub

	function cell__ppp_ping_generate_checksum(byref icmp_packet_format as string(CELL__32b_LEN), icmp_isSent as boolean) as dword

		'Define variables
		dim index as byte
		dim lindex, rindex as byte
		dim index_max as byte
		dim checksum_perhex_first as word	'Left side of 'Checksum (per double-Hex (16-bit))
		dim checksum_perhex_second as word	'Right side of 'Checksum (per double-Hex (16-bit))
		dim checksum_perhex_total as word	'Complete 'Checksum (per double-Hex (16-bit))
		dim icmp_checksum_block_len as byte

		'Get Maximum of Index
		'The block, which is used to generate the `Checksum`,...
		'...comprises of the first 20 bytes of string `icmp_packet_format`
		'Since we will be lookinig at a DOUBLE-Hex (and NOT a SINGLE-Hex)...
		'...the maximum index should be HALVEd
		index_max = CELL__20b_LEN/2 - 1
		
		
		'Generate Checksum
		cell__ppp_ping_generate_checksum = 0
		
		for index = 0 to index_max
			'Get Left Index
			lindex = index*2 + 1
			
			'Get Right Index
			rindex = index*2 + 2
		
			'Get Checksum based on `lindex` and `rindex`
			checksum_perhex_first = asc(mid(icmp_packet_format, lindex, 1))
			checksum_perhex_second = asc(mid(icmp_packet_format, rindex, 1))
			checksum_perhex_total = (checksum_perhex_first SHL 8) + (checksum_perhex_second AND &hFF)

			'Add `checksum_perhex_total` to the total `cell__ppp_ping_generate_checksum`
			cell__ppp_ping_generate_checksum = cell__ppp_ping_generate_checksum + checksum_perhex_total
			
		next index
		

		'Checks if Checksum `cell__ppp_ping_generate_checksum` exceeds 16-bit value (=65535)
		'If that's the case then modify `cell__ppp_ping_generate_checksum` to become a value within 16-bit
		if (cell__ppp_ping_generate_checksum  > 65535) then
			cell__ppp_ping_generate_checksum = (cell__ppp_ping_generate_checksum AND &hFFFF) + (cell__ppp_ping_generate_checksum SHR 16)
		end if
		
		'Substract `cell__ppp_ping_generate_checksum` from 0xFFFF
		'REMARK: ONLY do this when *SENDING* IMCP
		if (icmp_isSent = true) then
			cell__ppp_ping_generate_checksum = (&hFFFF - cell__ppp_ping_generate_checksum)
		end if

	end function
	sub cell__ppp_ping_insert_checksum(byref icmp_packet_format as string(CELL__32b_LEN), checksum as dword)

		'Define variables
		dim checksum_perhex_left as word	'Left side of Checksum (per Hex)
		dim checksum_perhex_right as word	'Right side of Checksum (per Hex)
		dim checksum_perhex_left_str as string(CELL__8b_LEN)
		dim checksum_perhex_right_str as string(CELL__8b_LEN)
		
		'Get Left and Right Hex values
		checksum_perhex_left = (checksum SHR 8)
		checksum_perhex_left_str = chr(checksum_perhex_left)
		
		checksum_perhex_right = (checksum AND &hFF)
		checksum_perhex_right_str = chr(checksum_perhex_right)
		
		'Overwrite Left Hex value into the `CELL__ICMP_HEADERCHECKSUM` at position = 11
		insert(icmp_packet_format,11, checksum_perhex_left_str)
		
		'Overwrite Right Hex value into `CELL__ICMP_HEADERCHECKSUM` at position = 12
		insert(icmp_packet_format,12, checksum_perhex_right_str)
		
	end sub
	sub cell__ppp_ping_send(ppp_protocol as word, ppp_code as en_cell__op_ppp_codes, ppp_sender_id as byte, byref icmp_packet_format as string(CELL__32b_LEN),
								next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, 
										next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)

		'Define variables
		dim checksum as dword
		
		'Overwrite the Source-IP and Destination-IP of `icmp_packet_format` with
		insert(icmp_packet_format, CELL__ICMP_SRCIP_POSITION, cell__ppp_sender_ip)
		insert(icmp_packet_format, CELL__ICMP_DSTIP_POSITION, ddval(CELL__PING_IP))	
		
		'Get the Frame Check Sequence
		'Make sure to set parameter `icmp_isSent` to `true`, because ICMP is going to be sent
		checksum = cell__ppp_ping_generate_checksum(icmp_packet_format, true)

		'Overwrite the `CELL__ICMP_HEADERCHECKSUM` at position=11 and position=12 with the Left and Right Hex Value of `checksum`
		cell__ppp_ping_insert_checksum(icmp_packet_format, checksum)


		'Send ICMP Message Format
        cell__ppp_send_data(ppp_protocol, ppp_code, ppp_sender_id, icmp_packet_format,
								next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		
	end sub

'---PPP PARSE
    sub cell__ppp_substitute_data(byref sender_data as string(CELL__128b_LEN), 
        byref peer_data as string(CELL__128b_LEN), 
        code as en_cell__op_ppp_codes)
		'+------+   +---------------+--------------+--------------+
		'| data | = | config option |  data-length | data-content |
		'+------+   +---------------+--------------+--------------+
		'				1 Byte		   1 Byte		x Byte

		'Define variables
        dim sender_data_item as string(CELL__128b_LEN)
        dim sender_config_option_type as string(1)	'sender's configuration option type
        dim sender_config_option_pos as byte 	'sender's configuration option position
        dim sender_datalen as byte	'sender's data-length

        dim peer_data_item as string(CELL__128b_LEN)
        dim peer_config_option_type as string(1)		'peer's configuration option type
        dim peer_config_option_pos as byte	'peer's configuration option position
        dim peer_datalen as byte	'peer's data-length

		'Set initial values
        peer_config_option_pos = 1
        peer_datalen = 1

		'Cycle through `peer_data` and handle one data config option at a time
        while peer_config_option_pos < len(peer_data)
            peer_datalen = asc(mid(peer_data, (peer_config_option_pos + 1), 1))	'Get data-length
            peer_config_option_type = mid(peer_data, peer_config_option_pos, 1)	'Get configuration option type
            peer_data_item = mid(peer_data, peer_config_option_pos, peer_datalen)	'Get ONE data packet
		
			'reinitialize *Sender*'s value
            sender_config_option_pos = 1
            sender_datalen = 1
			
			'Cycle through `sender_data` and handle one data config option at a time
            while sender_config_option_pos < len(sender_data)
                sender_datalen = asc(mid(sender_data, (sender_config_option_pos + 1), 1))	'Get data-length
                sender_config_option_type = mid(sender_data, sender_config_option_pos, 1)	'Get configuration option type
			
				'Compare the Decimal value of `peer_config_option_type` with `sender_config_option_type`
                if asc(peer_config_option_type) = asc(sender_config_option_type) then	'match was found
                EXIT WHILE
                end if
			
				'Calculate the next `sender_config_option_pos`
                sender_config_option_pos = sender_config_option_pos + sender_datalen
            wend
			
			'Revise `peer_data_item` if needed (depending on the `code` and/or `configuration option`)
            if code = PPP_CONFREJ then
                sender_data_item = CELL__EMPTYSTRING	'because of the CONFREJ, data config option has to be EXCLUDED from the `sender_data`
            else if code = PPP_CONFREQ then
                if peer_config_option_type = chr(CONFIG_OPTION_MAGIC) then	'config option type is MAGIC NUMBER
					'sender_this_data (4 bytes) = peer_this_data (first 2 Bytes) + 4 Bytes of random string data
					sender_data_item = left( peer_data_item, CELL__2b_LEN ) + random(CELL__4b_LEN)	'generate a random MAGIC NUMBER for `sender_data`
                else	'for all other config option types
					sender_data_item = peer_data_item
				end if
            else	'for all other code values
				sender_data_item = peer_data_item
            end if
		
			'Depending on the position of the config option type, insert `sender_data_item` into `sender_data` at the right position.
            if sender_config_option_pos < 0 then	'prepend `sender_data_item`
				sender_data = sender_data_item + sender_data
				
            else if sender_config_option_pos > len(sender_data) then	'append `sender_data_item`
				sender_data = sender_data + sender_data_item 
				
            else	'insert `sender_data_item`
				sender_data = left( sender_data, (sender_config_option_pos - 1) ) 
								+ sender_data_item 
									+ right( sender_data, (len(sender_data) - (sender_config_option_pos + sender_datalen - 1)) )				
            end if

			'Calculate the next `peer_config_option_pos`
            peer_config_option_pos = peer_config_option_pos + peer_datalen
        wend
    end sub

    sub cell__ppp_parse_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases,
										next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
									
		'Parse the received message
        cell__reply = cell__ppp_parse_message_func()

        if cell__reply = CELL__EMPTYSTRING then	'parsed message is EMPTY
			cell__ppp_parse_message__retry()	'retry parsing the received message again
        end if

		'Define variables
        dim ppp_protocoltype_lhex as word = asc(left(cell__reply, 1))*256
        dim ppp_protocoltype_rhex as word = asc(mid(cell__reply, 2, 1))
        dim ppp_protocoltype as word = ppp_protocoltype_lhex + ppp_protocoltype_rhex


		'The type of PPP Negotiation depends on the protocol-type.
		'Note: for information regarding PPP negotiation, see link:
		'	   https://www.cisco.com/c/en/us/support/docs/wan/point-to-point-protocol-ppp/25440-debug-ppp-negotiation.html#pppnegs
        select case ppp_protocoltype
            case CELL__PPP_PROTO_LCP:
				cell__ppp_proc_parsed_lcp_message(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
			
            case CELL__PPP_PROTO_PAP:
				cell__ppp_proc_parsed_pap_message(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

            case CELL__PPP_PROTO_IPCP:
				cell__ppp_proc_parsed_ipcp_message(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
				
            case CELL__PPP_PROTO_IP:
				cell__ppp_proc_parsed_ping_message(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
				
            case else:
			
        end select
    end sub
    function cell__ppp_parse_message_func() as string(CELL__128b_LEN)
		'Define variables
        dim p as byte
        dim ppp_rcvd_msg as string
        dim ppp_rcvd_msg_item as byte
        dim fcs as word
        dim rx_lpos as byte
        dim rx_rpos as byte
		
		'Define Macros
        #define FINAL_FCS_ISGOOD ( fcs = CELL__PPP_GOOD_FINAL_FCS )
        #define ADDRESS_FIELD_ISPRESENT ( asc( left(cell__reply, len(1)) ) = CELL__PPP_ADDR )
        #define CONTROL_FIELD_ISPRESENT ( asc( mid(cell__reply, 2, 1) ) = CELL__PPP_CTRL )

        #define PACKET_LENGTH_REGIST_LHEX ( asc(mid(cell__reply, 5, 1))*256 )	'Left Hex-value
        #define PACKET_LENGTH_REGIST_RHEX ( asc(mid(cell__reply, 6, 1)) )	'Right Hex-value
        #define PACKET_LENGTH_REGIST (PACKET_LENGTH_REGIST_LHEX + PACKET_LENGTH_REGIST_RHEX)	'Total calculated length
        #define PACKET_LENGTH_COUNTED ( len(cell__reply)-2 )	'Exclude Protocol field, thus 2 Bytes


		'Initial value
        cell__reply = CELL__EMPTYSTRING

		'-------------------------------------------------------------------
		'Step 1: get the complete received PPP message by checking for the:
		'1. prepended string: chr(&h7E) + chr(&hFF) + chr(&h7D) + chr(&h23) (2 Bytes in length)
		'2. appended Flag: chr(&h7E) (4 bits in length)
		'-------------------------------------------------------------------
		'Find the position of the prepended string (see 1.1)
        rx_lpos = instr(1, ser.peekdata(255), CELL__PPP_PARSE_MSG_START_SIGN_STR, 1)
		
        if rx_lpos > 0 then	'prepended string were found
			ser.getdata(rx_lpos - 1)	'Strip off all leading characters before `rx_lpos`
				
			'Find the position of the appended Flag (see 1.2)
			'Start position is 3 because the prepended string is 2 Bytes in Length
			rx_rpos = instr(3, ser.peekdata(255), CELL__PPP_PARSE_MSG_END_SIGN_STR, 1)
				
			if rx_rpos > 0 then	'appended Flag was found
				cell__rxlen = rx_rpos	'update global variable
			else	'appended Flag was NOT found yet
				exit function
			end if
		else	'prepended strings were NOT found yet
				exit function
        end if

		'Get the received data
        ppp_rcvd_msg = ser.getdata(cell__rxlen)	'get PPP message from rx-buffer and flush rx-buffer afterwards


		'-------------------------------------------------------------------
		'Step 2:
		'Strip off prepended and appended flags 0x7E
		'Strip off escape characters
		'Replace 0x5E with 0x7E
		'Replace 0x5D with 0x7D
		'XOR characters other than the ones mentioned in the above
		'-------------------------------------------------------------------
        for p=1 to len(ppp_rcvd_msg)	'cycle through each character of `ppp_rcvd_msg`
            ppp_rcvd_msg_item = asc(mid(ppp_rcvd_msg, p, 1))	'for each index p, get one char and convert to ASCII
			
            if (ppp_rcvd_msg_item = CELL__PPP_ESC_CHAR) then	'escape character `0x7D` was found
				'Skip the escape character `0x7D` by incrementing index by 1
				p = p + 1
					
					'Get the next character
				ppp_rcvd_msg_item = asc(mid(ppp_rcvd_msg, p, 1))
				
				'Depending on the situation, process the `ppp_rcvd_msg_item`
				select case ppp_rcvd_msg_item
					case CELL__PPP_FLAG_REPL_CHAR:
						ppp_rcvd_msg_item = CELL__PPP_FLAG	'replace 0x5E with 0x7E and add to `cell__reply`
							
					case CELL__PPP_ESC_REPL_CHAR:
						ppp_rcvd_msg_item = CELL__PPP_ESC_CHAR	'replace 0x5D with 0x7D and add to `cell__reply`
							
					case else:	'in case `ppp_rcvd_msg_item` is none of the above mentioned cases
						ppp_rcvd_msg_item = (ppp_rcvd_msg_item XOR CELL__PPP_XOR_X20)	'XOR `ppp_rcvd_msg_item` with 0x20
						
				end select
            else if (ppp_rcvd_msg_item = CELL__PPP_FLAG) then	'flag `0x7E` was found
				'In this case, just skip this character and go to the next one
				
				goto NEXT_FOR_HANDLER
				
            else	'for all other cases, do nothing (but do add this character to `cell__reply`)
				ppp_rcvd_msg_item = ppp_rcvd_msg_item
				
            end if
			
			'add `ppp_rcvd_msg_item` to `cell__reply`
            cell__reply = cell__reply + chr(ppp_rcvd_msg_item)	
			
NEXT_FOR_HANDLER:
        next p
		

		'Step 3A: Generate FCS
        fcs = cell__ppp_generate_fcs(cell__reply)


		'Step 3B: Check if FCS is a GOOD FINAL FCS VALUE (0xF0B8)
        if NOT FINAL_FCS_ISGOOD then	'FCS is NOT a GOOD FINAL VALUE (0xF0B8)
			cell__reply = CELL__EMPTYSTRING	'set variable as empty string
			
			#if CELL__DEBUG_PRINT		
				cell__debugprint_ppp_phase(PHASE_PPP_FCS_ISBAD, CELL__EMPTYSTRING)	'PRINT failed message
			#endif			
				
			'Set all next-phases to IDLE
			cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

			'CALLBACK
			cell__callback_ppp_fcs_is_bad()
			
			exit function
        end if
		
		
		'Step 4: Strip off the trailing FCS field (2 Byte)
        cell__reply = left( cell__reply, len(cell__reply)-2 )
		
		
		'Step 5: Check if the Address `0xFF` and Control `0x03` fields are present in the received PPP message
        if NOT (ADDRESS_FIELD_ISPRESENT) then
            cell__reply = CELL__EMPTYSTRING	'set variable as empty string
            
			#if CELL__DEBUG_PRINT			
                cell__debugprint_ppp_phase(PHASE_PPP_ADDRESS_FIELD_NOTPRESENT, CELL__EMPTYSTRING)	'PRINT failed message
            #endif
			
			'Set all next-phases to IDLE
            cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

			'CALLBACK
            cell__callback_ppp_missing_address_field()
			
            exit function
		else
            if NOT (CONTROL_FIELD_ISPRESENT) then
                cell__reply = CELL__EMPTYSTRING	'set variable as empty string
                
				#if CELL__DEBUG_PRINT		
                    cell__debugprint_ppp_phase(PHASE_PPP_CONTROL_FIELD_NOTPRESENT, CELL__EMPTYSTRING)	'PRINT failed message
                #endif
				
				'Set all next-phases to IDLE
                cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

				'CALLBACK
                cell__callback_ppp_missing_control_field()
				
                exit function
            end if
        end if
		
		
		'Step 6: Strip off the leading Control (1 Byte) and Address fields (1 Byte)
        cell__reply = right( cell__reply, len(cell__reply)-2 )
			
		'The end result is a parsed message containing:
		'+-------------------+------------------------------------------------------------------------------------------+   
		'| Protocol (2Bytes) | 										Information 										| 
		'+-------------------+------------------------------------------------------------------------------------------+ 
		'
		'												PACKET_LENGTH_REGIST_LHEX	PACKET_LENGTH_REGIST_RHEX
		'	=															  |					  |
		'															      V					  V
		'+-------------------+--------------+--------------------+------------------+-------------------+---------------+
		'| Protocol (2Bytes) | Code (1Byte) | Identifier (1Byte) | LEFT-LEN (1Byte) | RIGHT-LEN (1Byte) | Data (x-Bytes)|
		'+-------------------+--------------+--------------------+------------------+-------------------+---------------+
		'					 ^				 												   					   	    ^
		'					 |									 											   		    |
		'					 +----------------------------------------------+-------------------------------------------+
		'												 				    |
		'										  				PACKET_LENGTH_COUNTED
		'
		'
		'Data Packet looks like this:
		'+--------------+----------------+------------------------+--------------+----------------+------------------------+------
		'| Type (1Byte) | Length (1Byte) | Data-content (m-Bytes) | Type (1Byte) | Length (1Byte) | Data-content (n-Bytes) | etc.
		'+--------------+----------------+------------------------+--------------+----------------+------------------------+------
		

		
		'Step 7: Compare the `Registered` length with the `Counted` length
        if PACKET_LENGTH_REGIST <> PACKET_LENGTH_COUNTED then	'no match was found
			#if CELL__DEBUG_PRINT
				cell__debugprint_ppp_phase(PHASE_PPP_MSG_LEN_NOTMATCH, CELL__EMPTYSTRING)	'PRINT failed message
			#endif
				
			'Set all next-phases to IDLE
			cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

			'CALLBACK
			cell__callback_ppp_lcp_msg_length_not_matching()
			
			exit function
        end if
		
		'***IMPORTANT: update start-timecounter
        cell__ppp_starttime = sys.timercount
    end function
    sub cell__ppp_parse_message__retry()
        cell__ppp_newtime = sys.timercount	'update new timercounter
        cell__ppp_elapsedtime = cell__calc_timediff_16b(cell__ppp_starttime, cell__ppp_newtime)	'calculate the elapsed time

        if cell__ppp_elapsedtime <= CELL__STATUS_TIMEOUT_MAX then	'maximum timeout for completing the parsing process of a received message
			if (cell__ppp_retry_param <= CELL__PPP_RETRY_MAX) then	'maximum retries NOT EXCEEDED yet
				cell__ppp_retry_param = cell__ppp_retry_param + 1	'increment retry parameter by 1

				cell__modem_restart(PHASE_PWR_PWRKEY_ON)	'initiate a modem-restart

			else	'maximum retries EXCEEDED and `CELL__PPP_RETRY_MAX <> CELL__INF`
				cell__init_param_var_bool()	'initialize parameters, variables and booleans
						
				cell__init_ppp()	'initialize PPP parameters, variables and booleans
				
				#if CELL__DEBUG_PRINT				
					cell__debugprint_ppp_phase(PHASE_PPP_RETRY_ERROR, CELL__EMPTYSTRING)	'PRINT
				#endif
				
				'Set all next-phases to IDLE
				cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
				
				'CALLBACK
				cell__callback_ppp_retry_exceeded()
				
			end if	
        end if
    end sub
	
    sub cell__ppp_proc_parsed_lcp_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases,
												next_gps_phase as en_cell__op_gps_phases, next_parse_phase as en_cell__op_parse_phases)
		'Define Variables
        dim ppp_peer_id as byte	= asc(mid(cell__reply, 4, 1))	'identifier field (1 Byte) 
        dim ppp_peer_data as string = right(cell__reply, len(cell__reply) - CELL__6b_LEN)	'peer's data field
        dim ppp_sender_data as string = right(cell__ppp_sender, len(cell__ppp_sender) - CELL__6b_LEN)	'sender's data field
        dim ppp_peer_code as byte = asc(mid(cell__reply, 3, 1))	'peer's code
        dim ppp_sender_code as en_cell__op_ppp_sender_codes	'sender's code
        dim authentication_isPAP as word = instr(1, cell__reply, CELL__PPP_PROTO_PAP_STR, 1)	'check if the authentication is PAP
			
		'Handle *Peer*'s data based on *Peer*'s code
        select case ppp_peer_code
            case PPP_PEER_CONFACK:
				'*Peer* has answered with a CONFACK to the *Sender*'s CONFREQ.
				'Therefore this boolean can be set to YES
				cell__ppp_sender_confreq_isAck = true

            case PPP_PEER_CONFNAK:
				'*Peer* has answered with a CONFNAK to the *Sender*'s CONFREQ.
				'Therefore change the `ppp_sender_data` to the values as specified in the *Peer*'s CONFNAK 
				cell__ppp_substitute_data(ppp_sender_data, ppp_peer_data, PPP_CONFNAK)

				'After that, send a CONFREQ!!!
				'Do not forget to use the *Sender*'s ID.
				cell__ppp_send_data(CELL__PPP_PROTO_LCP, PPP_CONFREQ, cell__ppp_sender_id, ppp_sender_data,
										next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

            case PPP_PEER_CONFREJ:
				'*Peer* has answered with a CONFREJ to the *Sender*'s CONFREQ.
				'Therefore remove the Rejected values as specified in the *Peer*'s CONFREJ from the `ppp_sender_data`
				cell__ppp_substitute_data(ppp_sender_data, ppp_peer_data, PPP_CONFREJ)

					'Send a CONFREQ!!!
					'Do not forget to use the *Sender*'s ID.
				cell__ppp_send_data(CELL__PPP_PROTO_LCP, PPP_CONFREQ, cell__ppp_sender_id, ppp_sender_data,
										next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
									
            case PPP_PEER_DISREQ:
				'*Peer* has answered with a DISCARD RREQUEST to the *Sender*'s CONFREQ.
				'In this case do NOTHING.
				#if CELL__DEBUG_PRINT		
					cell__debugprint_ppp_phase(PHASE_PPP_LCP_DISCREQ_BY_PEER, CELL__EMPTYSTRING)	'PRINT
				#endif
				
				cell__callback_ppp_lcp_disreq_from_peer()	'CALLBACK

            case PPP_PEER_CONFREQ:
				'*Peer* has sent a CONFREQ.
				'Therefore process the parsed LCP CONFREQ message from the *Peer*
				ppp_sender_code = cell__ppp_proc_parsed_lcp_confreq_message_result(ppp_peer_data, cell__ppp_confrej_str)

				'Handle *Peer*'s data based on the *Sender*'s code
				select case ppp_sender_code
					case PPP_SENDER_CONFACK:
						'*Sender* will answer with CONFACK to *Peer*'s CONFREQ.
						'Therefore, this boolean can be sete to YES
						cell__ppp_peer_confreq_isAck = true
								
						'*Sender* will send a CONFACK using the unchanged `ppp_peer_data' for FINAL CONFIRMATION.
						'Do not forget to use the *Peer*'s ID, because otherwise the *Peer* wouldn't know what the *Sender* is talking about.
						'Note: when replying with a CONFACK, the same MAGIC-NUMBER must be used as specified in the `ppp_peer_data`
						'IMPORTANT: make sure to set thee `next_parse_phase` to `PHASE_PARSE_IDLE`, otherwise we will have an endless LOOP!!!
						cell__ppp_send_data(CELL__PPP_PROTO_LCP, PPP_CONFACK, ppp_peer_id, ppp_peer_data,
												next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

				case PPP_SENDER_CONFNAK:
					if authentication_isPAP then	'only continue if the AGREED authentication is PAP already
						'Set all booleans to YES
						cell__ppp_sender_confreq_isAck = true
						cell__ppp_peer_confreq_isAck = true
						cell__ppp_pap_isRequired = true

						'*Sender* will send a CONFACK using the unchanged `ppp_peer_data' for FINAL CONFIRMATION.
						'Do not forget to use the *Peer*'s ID, because otherwise the *Peer* wouldn't know what the *Sender* is talking about.
						'Note: when replying with a CONFACK, the same MAGIC-NUMBER must be used as specified in the `ppp_peer_data`
						'IMPORTANT: make sure to set thee `next_parse_phase` to `PHASE_PARSE_IDLE`, otherwise we will have an endless LOOP!!!
						cell__ppp_send_data(CELL__PPP_PROTO_LCP, PPP_CONFACK, ppp_peer_id, ppp_peer_data,
												next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
						
'						#if CELL__DEBUG_PRINT						
'							cell__debugprint_ppp_phase(PHASE_PPP_LCP_NEGO_SUCCESS, CELL__EMPTYSTRING)	'PRINT
'						#endif
									
'						cell__callback_ppp_lcp_successful()	'CALLBACK

					else	'authentication is NOT PAP yet
						'*Sender* will answer with CONFNAK to *Peer*'s CONFREQ requesting *Peer* to accept PAP
						'Do not forget to use the *Peer*'s ID, because otherwise the *Peer* wouldn't know what the *Sender* is talking about.
						'IMPORTANT: make sure to set thee `next_parse_phase` to `PHASE_PARSE_IDLE`, otherwise we will have an endless LOOP!!!
						cell__ppp_send_data(CELL__PPP_PROTO_LCP, PPP_CONFNAK, ppp_peer_id, CELL__PPP_LCP_OPTION_PAP_STR,
												next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
								
					end if
						
				case PPP_SENDER_CONFREJ:	'Configure-Reject
					'*Sender* will send a CONFREJ stating ONLY the data configuration objects,
					'	which the *Sender* would want to be EXCLUDED from the *Peer*'s CONFREQ.
					'Do not forget to use the *Peer*'s ID, because otherwise the *Peer* wouldn't know what the *Sender* is talking about.
					cell__ppp_send_data(CELL__PPP_PROTO_LCP, PPP_CONFREJ, ppp_peer_id, cell__ppp_confrej_str,
											next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
								
				case PPP_SENDER_DISREQ:	'Configure-reject/Discard-request
					'*Sender* does NOT agree with any data configuration objects as requested in the *Peer*'s CONFREQ.
					'In this case do NOTHING.
					#if CELL__DEBUG_PRINT					
						cell__debugprint_ppp_phase(PHASE_PPP_LCP_DISCREQ_FROM_SENDER, CELL__EMPTYSTRING)	'PRINT
					#endif	
							
					cell__callback_ppp_lcp_disreq_from_sender()	'CALLBACK
		
            end select
        end select
		
		
		'------------------------------------------------------------------
		'SENDER and PEER have BOTH AGREED with CONFACK:
		'*Sender* has answered with a CONFACK to the *Peer*'s CONFREQ
		'*Peer* has answered with a CONFACK to the *Sender*'s CONFREQ
		'------------------------------------------------------------------
		if (cell__ppp_sender_confreq_isAck = true) AND (cell__ppp_peer_confreq_isAck = true) then	

				
			'Set next phase to transit to (e.g. PHASE_PPP_PAP_NEGOTIATION or PHASE_PPP_IPCP_NEGOTIATION)
			'ALL other phases should be set to IDLE
			cell__ppp_proc_parsed_lcp_message_confack_handler(next_pwr_phase, next_at_phase, 
																next_ppp_phase, 
																	next_gps_phase, PHASE_PARSE_IDLE)
		end if
    end sub

    function cell__ppp_proc_parsed_lcp_confreq_message_result(byref parsed_message as string, byref confrej_str as string) as en_cell__op_ppp_sender_codes
		
		'Define variables
        dim parsed_message_copy as string(CELL__128b_LEN)
        dim parsed_message_copy_len as byte	'this is data-length of the current `parsed_message_copy`
        dim parsed_message_copy_next_pos as byte	'this is the position of the next configuration option within `parsed_message_copy`
        dim config_option_type as byte
        dim authen_protocol_lhex as word
        dim authen_protocol_rhex as word
        dim authen_protocol as word


		'Define Macros
        #define DATA_LENGTH_IS_ACCEPTABLE ( parsed_message_copy_len <= len(parsed_message_copy) )	'data-length of each data does NOT exceed the length of all data
        #define AUTHEN_PROTOCOL_IS_PAP ( authen_protocol = CELL__PPP_PROTO_PAP )	'Authentical Protocol matches PAP
        #define DATA_ISNOT_EMPTY ( parsed_message_copy <> CELL__EMPTYSTRING )

		'Set initial values
        confrej_str = CELL__EMPTYSTRING	'set CONFREJ data as EMPTY string
		
		'Make a copy of `parsed_message`.
		'This is necessary, because after each cycle the leading data packet will be stripped off from the `parsed_message_copy`
        parsed_message_copy = parsed_message

        while DATA_ISNOT_EMPTY	'cycle through `parsed_message_copy` until it's EMPTY
			'Update the variables for each cycle
            parsed_message_copy_len = asc(mid(parsed_message_copy, 2, 1))
            parsed_message_copy_next_pos = asc(mid(parsed_message_copy, 2, 1)) + 1
            config_option_type = asc(left(parsed_message_copy, 1))
            authen_protocol_lhex = asc(mid(parsed_message_copy, 3, 1))*256
            authen_protocol_rhex = asc(mid(parsed_message_copy, 4, 1))
            authen_protocol = authen_protocol_lhex + authen_protocol_rhex

			'Compare the `Registered` length with the `Counted` length
            if NOT DATA_LENGTH_IS_ACCEPTABLE then	'no match was found
				cell__ppp_proc_parsed_lcp_confreq_message_result = PPP_SENDER_DISREQ	'output with DISCARD REQUEST

				exit function
            end if
			
			'Data length of 1 packet is not greater than the total data length (of all packets combined)
			'Handle each data packet based on its Config Option
            select case config_option_type
                case CONFIG_OPTION_MRU:
					'DO NOTHING
					'	In subroutine `gprs_ppp_lcp_parse_message()` a CONFACK will be sent once
					'	sender and peer has come to an agreement. In this case, the data field 
					'	of the peer (`cell__reply`) will be used. This would mean that the 
					'	MRU is already included in the peer's data-field.					
				
                case CONFIG_OPTION_ACCM:	'Async Control Character Map
					'DO NOTHING
					'	In subroutine `gprs_ppp_lcp_parse_message()` a CONFACK will be sent once
					'	sender and peer has come to an agreement. In this case, the data field 
					'	of the peer (`cell__reply`) will be used. This would mean that the 
					'	ACCM is already included in the peer's data-field.
					
                case CONFIG_OPTION_AUTH:	'Authentication Protocol
					if NOT AUTHEN_PROTOCOL_IS_PAP then

						cell__ppp_proc_parsed_lcp_confreq_message_result = PPP_SENDER_CONFNAK	'output with Configure NAK
							
						exit function
					end if
					
					cell__ppp_pap_isRequired = true

                case CONFIG_OPTION_MAGIC:	'Magic Number
					'DO NOTHING
					'	In subroutine `gprs_ppp_lcp_parse_message()` a CONFACK will be sent once
					'	sender and peer has come to an agreement. In this case, the data field 
					'	of the peer (`cell__reply`) will be used. This would mean that the 
					'	MAGIC-NUMBER is already included in the peer's data-field.
					'REMARK: please note though that if an CONFREQ is sent, then the MAGIC-NUMBER
					'		 MUST BE unique. If the magic-number of both the sender and peer are the same, 
					'		the session terminates because of the loopback that is detected.
					
                case CONFIG_OPTION_PFC:	'Protocol-Field-COmpression
					confrej_str = confrej_str + CELL__PPP_LCP_OPTION_PFC_STR	'append PFC data to the `rejected string`
			
                case CONFIG_OPTION_ACFC:	'Address and Control Field Compression
					confrej_str = confrej_str + CELL__PPP_LCP_OPTION_ACFC_STR	'append ACFC data to the `rejected string`

                case else:	'for any unrecognized Configuration Options
					cell__ppp_proc_parsed_lcp_confreq_message_result = PPP_SENDER_DISREQ	'output with DISCARD REQUEST
					
					exit function
            end select

			'Strip off current data packet, and move on to Next data packet'
			'Note: if Next data packet is EMPTY then while-loop will stop.
			'		This would also automaticaly mean thhat the `case else` is NOT touched.
            parsed_message_copy = mid(parsed_message_copy, parsed_message_copy_next_pos, 255)
        wend

		'OUTPUT
        if confrej_str <> CELL__EMPTYSTRING then	'CONFREJ messages found
			cell__ppp_proc_parsed_lcp_confreq_message_result = PPP_SENDER_CONFREJ	'output with Configure Reject
        else	'Everything is Fine
			cell__ppp_proc_parsed_lcp_confreq_message_result = PPP_SENDER_CONFACK	'output with Configure ACK
        end if
    end function
    sub cell__ppp_proc_parsed_lcp_message_confack_handler(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
															next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
																next_parse_phase as en_cell__op_parse_phases)
		
		'RESET PPP-booleans
		'REMARK: these Booleans will be re-used in subroutine `cell__ppp_proc_parsed_ipcp_message`
		cell__ppp_sender_confreq_isAck = false
		cell__ppp_peer_confreq_isAck = false
		
		
		'PRINT
		#if CELL__DEBUG_PRINT
            cell__debugprint_ppp_phase(PHASE_PPP_LCP_NEGO_SUCCESS, CELL__EMPTYSTRING)
        #endif
		
		
		'Set next phase to transit to (e.g. PHASE_PPP_PAP_NEGOTIATION or PHASE_PPP_IPCP_NEGOTIATION)
		'ALL other phases should be set to IDLE
 		if cell__ppp_pap_isRequired = true then 'PAP is NOT required
			if next_ppp_phase = PHASE_PPP_DETERMINED_BY_SYSTEM then	'only continue if next_ppp_phase is set to `PHASE_PPP_DETERMINED_BY_SYSTEM`
				next_ppp_phase = PHASE_PPP_PAP_NEGOTIATION	'set phase to PHASE_PPP_PAP_NEGOTIATION
			end if													
		else	'PAP is required
			if next_ppp_phase = PHASE_PPP_DETERMINED_BY_SYSTEM then	'only continue if next_ppp_phase is set to `PHASE_PPP_DETERMINED_BY_SYSTEM`
				next_ppp_phase = PHASE_PPP_IPCP_NEGOTIATION	'set phase to PHASE_PPP_IPCP_NEGOTIATION				
			end if	
		end if
		
		'Set next-phase where to transit to
		cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
		
		'CALLBACK
        cell__callback_ppp_lcp_successful()

		'Enable Fast-Load (if needed)
        #if CELL__PPP_FAST_LOAD_ISENABLED
            cell__ppp_proc_sys_timer()
        #endif
    end sub


    sub cell__ppp_proc_parsed_pap_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
        next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
        next_parse_phase as en_cell__op_parse_phases)
		'Define Variables
        dim ppp_protocoltype_lhex as word = asc(left(cell__reply, 1))*256	'protocol-type (left hex value)
        dim ppp_protocoltype_rhex as word = asc(mid(cell__reply, 2, 1))	'protocol-type (right hex value)
        dim ppp_protocoltype as word = ppp_protocoltype_lhex + ppp_protocoltype_rhex	'protocol-type (complete)
        dim ppp_peer_code as byte = asc(mid(cell__reply, 3, 1))	'peer's code value

		'Handle *Peer*'s data based on the *Sender*'s code
        select case ppp_peer_code
            case PPP_PEER_CONFACK:
				'*Peer* has answered with a CONFACK to the *Sender*'s CONFREQ.
				'In this case do NOT send anything to *Peer*.

				'PRINT
				#if CELL__DEBUG_PRINT	
					cell__debugprint_ppp_phase(PHASE_PPP_PAP_NEGO_SUCCESS, CELL__EMPTYSTRING)
				#endif
				
				'Set next phase to transit to (e.g. PHASE_PPP_IPCP_NEGOTIATION)
				'ALL other phases should be set to IDLE
				'IMPORTANT: make sure to set thee `next_parse_phase` to `PHASE_PARSE_IDLE`, otherwise we will have an endless LOOP!!!
				cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)

				'CALLBACK
				cell__callback_ppp_pap_successful()
				
            case PPP_PEER_CONFNAK, PPP_PEER_CONFREJ, PPP_PEER_DISREQ:
				'PRINT
				#if CELL__DEBUG_PRINT		
					cell__debugprint_ppp_phase(PHASE_PPP_PAP_NEGO_FAILED, CELL__EMPTYSTRING)
				#endif
					
				'Set all next-phases to IDLE
				cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)

				'CALLBACK
				cell__callback_ppp_pap_nego_failed()
				
        end select

		'Enable Fast-Load (if needed)
        #if CELL__PPP_FAST_LOAD_ISENABLED
            cell__ppp_proc_sys_timer()
        #endif
    end sub


    sub cell__ppp_proc_parsed_ipcp_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
												next_parse_phase as en_cell__op_parse_phases)

		'Define Variables
        dim ppp_peer_id as byte	= asc(mid(cell__reply, 4, 1))	'identifier field (1 Byte) 
        dim ppp_peer_data as string = right(cell__reply, len(cell__reply) - CELL__6b_LEN)	'peer's data field
        dim ppp_sender_data as string = right(cell__ppp_sender, len(cell__ppp_sender) - CELL__6b_LEN)	'sender's data field
        dim ppp_peer_code as byte = asc(mid(cell__reply, 3, 1))	'peer's code value
        dim ppp_sender_code as en_cell__op_ppp_sender_codes	'sender's code value

		'Handle *Peer*'s data based on the *Peer*'s code
        select case ppp_peer_code
            case PPP_PEER_CONFACK:
				'*Peer* has answered with a CONFACK to the *Sender*'s CONFREQ.
				'Note: 	this means that the *Sender* has sent a CONFREQ with a suggested valid ip-address 
				'		to which the *Sender* would like to connect to.
				cell__ppp_sender_confreq_isAck = true

            case PPP_PEER_CONFNAK:
				'*Peer* has answered with a CONFNAK to the *Sender*'s CONFREQ in which 
				cell__ppp_sender_ip = right(ppp_peer_data, CELL__4b_LEN)	'get the remote ip-address to which the *Sender* can connect to

					'Change the `ppp_sender_data` to the values as specified in the *Peer*'s CONFNAK 
				cell__ppp_substitute_data(ppp_sender_data, ppp_peer_data, PPP_CONFNAK)

					'Send a CONFREQ!!!
					'Do not forget to use the *Sender*'s ID.
				cell__ppp_send_data(CELL__PPP_PROTO_IPCP, PPP_CONFREQ, cell__ppp_sender_id, ppp_sender_data,
										next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
				
            case PPP_PEER_CONFREJ:
				'*Peer* has answered with a CONFREJ to the *Sender*'s CONFREQ.
				'Therefore remove the Rejected values as specified in the *Peer*'s CONFREJ from the `ppp_sender_data`
				cell__ppp_substitute_data(ppp_sender_data, ppp_peer_data, PPP_CONFREJ)
				
				'Send a CONFREQ!!!
				'Do not forget to use the *Sender*'s ID.
				cell__ppp_send_data(CELL__PPP_PROTO_IPCP, PPP_CONFREQ, cell__ppp_sender_id, ppp_sender_data,
										next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

            case PPP_PEER_DISREQ:
				'*Peer* has answered with a DISCARD RREQUEST to the *Sender*'s CONFREQ.
				'In this case do NOTHING.		
				#if CELL__DEBUG_PRINT
					cell__debugprint_ppp_phase(PHASE_PPP_IPCP_DISCREQ_BY_PEER, CELL__EMPTYSTRING)	'PRINT
				#endif
					
				cell__callback_ppp_ipcp_disreq_from_peer()	'CALLBACK

            case PPP_PEER_CONFREQ
				'*Peer* has sent a CONFREQ.
				'Therefore process the parsed PPP CONFREQ message from the *Peer*
				ppp_sender_code = cell__ppp_proc_parsed_ipcp_confreq_message_result(ppp_peer_data, ppp_peer_code, cell__ppp_confrej_str)
			
			'Handle *Peer*'s data based on the *Sender*'s code	
            select case ppp_sender_code
                case PPP_SENDER_CONFACK:
					'Send a CONFACK as response to a CONFREQ
					cell__ppp_send_data(CELL__PPP_PROTO_IPCP, PPP_CONFACK, ppp_peer_id, ppp_peer_data,
											next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)
					
					'*Sender* has answered with a CONFACK to the *Peer*'s CONFREQ.
					cell__ppp_peer_confreq_isAck = true
					
                case PPP_SENDER_CONFNAK:
					'Sender is NOT expected to send a CONFNAK
					'DO NOTHING
						
                case PPP_SENDER_CONFREJ:
					'Sender is NOT expected to send a CONFREJ
					'DO NOTHING			
						
                case PPP_SENDER_DISREQ:
					'*Sender* does NOT agree with any data configuration objects as requested in the *Peer*'s CONFREQ.
					'In this case do NOTHING.
					#if CELL__DEBUG_PRINT					
						cell__debugprint_ppp_phase(PHASE_PPP_IPCP_DISCREQ_FROM_SENDER, CELL__EMPTYSTRING)	'PRINT
					#endif
						
					cell__callback_ppp_ipcp_disreq_from_sender()	'CALLBACK

            end select
        end select
		
		'------------------------------------------------------------------
		'SENDER and PEER have BOTH AGREED with CONFACK:
		'*Sender* has answered with a CONFACK to the *Peer*'s CONFREQ
		'*Peer* has answered with a CONFACK to the *Sender*'s CONFREQ
		'------------------------------------------------------------------
		if (cell__ppp_sender_confreq_isAck = true) AND (cell__ppp_peer_confreq_isAck = true) then	

				
			'Set next phase to transit to (e.g. PHASE_PPP_PAP_NEGOTIATION or PHASE_PPP_IPCP_NEGOTIATION)
			'ALL other phases should be set to IDLE
			cell__ppp_proc_parsed_ipcp_message_confack_handler(ppp_peer_data, next_pwr_phase, next_at_phase, 
																next_ppp_phase, 
																	next_gps_phase, PHASE_PARSE_IDLE)
		end if
		
    end sub
    function cell__ppp_proc_parsed_ipcp_confreq_message_result(byref parsed_message as string(CELL__128b_LEN), 
															code as en_cell__op_ppp_codes, 
																byref confrej_str as string) as en_cell__op_ppp_sender_codes
		'Define variables
        dim parsed_message_copy as string(CELL__128b_LEN)
        dim parsed_message_copy_len as byte
        dim parsed_message_copy_next_pos as byte
        dim config_option_type as byte

		'Define Macros
        #define DATA_LENGTH_IS_ACCEPTABLE ( parsed_message_copy_len <= len(parsed_message_copy) )
        #define DATA_IS_6BYTES_IN_LENGTH ( parsed_message_copy_len = CELL__6b_LEN )	'data-length of each data does NOT exceed the length of all data
        #define DATA_ISNOT_EMPTY ( parsed_message_copy <> CELL__EMPTYSTRING )

		'Set initial values
        confrej_str = CELL__EMPTYSTRING	'set CONFREJ data as EMPTY string
		
		'Make a copy of `parsed_message`.
		'This is necessary, because after each cycle the leading data packet will be stripped off from the `parsed_message_copy`
        parsed_message_copy = parsed_message

        while DATA_ISNOT_EMPTY	'cycle through `parsed_message_copy` until it's EMPTY
			'Update the variables for each cycle
            parsed_message_copy_len = asc(mid(parsed_message_copy, 2, 1))
            parsed_message_copy_next_pos = asc(mid(parsed_message_copy, 2, 1)) + 1
            config_option_type = asc(left(parsed_message_copy, 1))
			
			'Compare the `Registered` length with the `Counted` length
            if NOT (DATA_LENGTH_IS_ACCEPTABLE) then	'no match was found
				cell__ppp_proc_parsed_ipcp_confreq_message_result = PPP_SENDER_DISREQ	'output with DISCARD REQUEST

				exit function
            end if
			
			
			'Data-length of 1 packet is not greater than the total data-length (of all packets combined)
			'Handle each data packet based on its Config Option
            select case config_option_type
                case CONFIG_OPTION_IP:
					'For IP configuration option, check if the data-length is 6 Bytes
					if NOT (DATA_IS_6BYTES_IN_LENGTH) then
						cell__ppp_proc_parsed_ipcp_confreq_message_result = PPP_SENDER_DISREQ	'output with DISCARD REQUEST
							
						exit function
					end if
					
					'Data-length is 6 Bytes
					if code = PPP_CONFREQ then	'peer responded with a CONFREQ
						'GET the IP-address to which the *Peer* can connect to which was assigned by the *Sender*
						cell__ppp_peer_ip = right(parsed_message_copy, CELL__4b_LEN)
						
					else	'peer responded with anything else but a CONFREQ
						'GET the IP-address to which the *Sender* can connect to which was assigned by the *Peer*
						cell__ppp_sender_ip = right(parsed_message_copy, CELL__4b_LEN)
						
					end if
				
                case CONFIG_OPTION_IP_COMPRESSION, CONFIG_OPTION_PRI_DNS, CONFIG_OPTION_SEC_DNS:
					'DO NOTHING
					'	In subroutine `gprs_ppp_ipcp_parse_message()` a CONFACK will be sent once
					'	sender and peer has come to an agreement. In this case, the data field 
					'	of the peer (`cell__reply`) will be used. This would mean that the 
					'	PRIMARY DNS Server Address, Secondary DNS Server Address, and
					'	IP COMPRESSION are already included in the peer's data-field.
					
                case else: 'unrecognized stuff
					cell__ppp_proc_parsed_ipcp_confreq_message_result = PPP_SENDER_DISREQ	'output with DISCARD REQUEST
					
					exit function
            end select

			'Strip off current data packet, and move on to Next data packet'
			'Note: if Next data packet is EMPTY then while-loop will stop.
			'		This would also automaticaly mean thhat the `case else` is NOT touched.
            parsed_message_copy = mid(parsed_message_copy, parsed_message_copy_next_pos, 255)
        wend

		'THIS IS THE OUTPUT when there NO MATCH is found in the `case select` (in the above while loop)
        cell__ppp_proc_parsed_ipcp_confreq_message_result = PPP_SENDER_CONFACK	'output with Configure ACK
    end function
	sub cell__ppp_proc_parsed_ipcp_message_confack_handler(ppp_peer_data as string, next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
															next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
																next_parse_phase as en_cell__op_parse_phases)		

		'RESET Booleans
		'REMARK: these Booleans will be re-used in subroutine `cell__ppp_proc_parsed_lcp_message`
		cell__ppp_sender_confreq_isAck = false
		cell__ppp_peer_confreq_isAck = false


		'GET the Remote ip-address to which the *Sender* can connect to
		cell__ppp_sender_ip = right(ppp_peer_data, CELL__4b_LEN)	


		'PRINT
		#if CELL__DEBUG_PRINT	
			cell__debugprint_ppp_phase(PHASE_PPP_IPCP_NEGO_SUCCESS, CELL__EMPTYSTRING)	'PRINT
		#endif
			
			
		'Set next phase to transit to (e.g. PHASE_PPP_IPCP_CONNECT)
		'IMPORTANT: make sure to set thee `next_parse_phase` to `PHASE_PARSE_IDLE`
		cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)
		

		'CALLBACK
		cell__callback_ppp_ipcp_successful()
		
		
		'Enable Fast-Load (if needed)
        #if CELL__PPP_FAST_LOAD_ISENABLED
            cell__ppp_proc_sys_timer()
        #endif
    end sub

	sub cell__ppp_proc_parsed_ping_message(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
											next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
												next_parse_phase as en_cell__op_parse_phases)
		'Define constants
		const CODE_POSITION = 3
		
		'Define variables
		dim checksum as dword
		dim source_ip as string(CELL__16b_LEN)

		'Overview of the parsed message `cell__reply`, which is retrieved via function `cell__ppp_parse_message_func`
		'+-------------------+-------------------------------+
		'| Protocol (2Bytes) | ICMP MESSAGE FORMAT (32-Bytes)|
		'+-------------------+-------------------------------+
		
		'Discard the `Protocol` from `cell__reply`
		cell__reply = mid(cell__reply, CODE_POSITION, 255)

		'Get SOURCE-IP
		source_ip = mid(cell__reply, 13, 4)
		
		'Get the Frame Check Sequence (FCS)
		'Make sure to set parameter `icmp_isSent` to `false`, because ICMP is going to be received
		checksum = cell__ppp_ping_generate_checksum(cell__reply, false)


		'FIRST REQUIREMENT: FCS has to be equal to 0xFFFF
		if (checksum <> &hFFFF) then	'FCS is NOT equal to 0xFFFF
			'OUTPUT
			cell__ppp_ping_reply = CELL__NG
			
			'PRINT
			#if CELL__DEBUG_PRINT
				cell__debugprint_ppp_phase(PHASE_PPP_PING_FAILED, ddstr(source_ip))
			#endif
			
			'CALLBACK
			cell__callback_ppp_ping_failed()
			
			'RETRY
			cell__ppp_parse_message__retry()
			
		else	'FCS is EQUAL to 0xFFFF
			'SECOND REQUIREMENT: SOURCE-IP, which is received via `cell__reply`, has to be equal to `CELL__PING_IP`
			if source_ip <> ddval(CELL__PING_IP) then	'cell__reply is NOT equal to CELL__PING_IP
				'OUTPUT
				cell__ppp_ping_reply = CELL__NG

				'PRINT
				#if CELL__DEBUG_PRINT
					cell__debugprint_ppp_phase(PHASE_PPP_PING_FAILED, ddstr(source_ip))
				#endif

				'CALLBACK
				cell__callback_ppp_ping_failed()
				
				'RETRY
				cell__ppp_parse_message__retry()
				
			else	'cell__reply is EQUAL to CELL__PING_IP			
				'OUTPUT
				cell__ppp_ping_reply = CELL__OK

				'PRINT
				#if CELL__DEBUG_PRINT
					cell__debugprint_ppp_phase(PHASE_PPP_PING_SUCCESSFUL, ddstr(source_ip))
				#endif
				
				'Set next phase to transit to (e.g.,  PHASE_PPP_IPCP_CONNECT)
				'***IMPORTANT: Make sure to set `next_parse_phase` to `PHASE_PARSE_IDLE`
				cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, PHASE_PARSE_IDLE)

				'CALLBACK
				cell__callback_ppp_ping_successful()
				
			end if
		end if
	end sub

	sub cell_ppp_enable()
		'Define, assign, and enable PPP
        ppp.portnum = CELL__DATA_SER_PORT	'assign a PPP-portnumber (which is equal to the serial-port number used for AT-commands)
        ppp.ip = ddstr(cell__ppp_sender_ip)	'set a valid remote ip-address (retrieved during the IPCP-negotiation)
        ppp.enabled = YES	'enable PPP (required to establish the connection)

		'PRINT
		#if CELL__DEBUG_PRINT
            cell__debugprint_ppp_phase(PHASE_PPP_LINK_ESTABLISHED, ddstr(cell__ppp_sender_ip))	'show print out	
        #endif

		'Set all next-phases to IDLE
        cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)	
	end sub

    sub cell__ppp_link_to_tower()
		'Connect via PPP
		cell_ppp_enable()
		
		'CALLBACK
        cell__callback_ppp_link_established()
		
    end sub

'    sub cell__combine_uptime_and_lost_conn(byref uptime as string, lost_conn as word)
'        uptime = uptime + ", " + str(lost_conn) + " failed"	'OUTPUT
'    end sub
#endif


'***GPS SUBROUTINES-----------------------------------------------------
#if CELL__GPS_MODE_ISENABLED
    sub cell__gps_parse_message()
		'Define variables
        dim gps_gpgsv_pos as byte
        dim gps_gpgga_pos as byte
			
		'Define MACROS
        #define PEEKDATA_CONTAINS_GPGSV ( gps_gpgsv_pos <> 0 )
        #define PEEKDATA_CONTAINS_GPGGA ( gps_gpgga_pos <> 0 )
        #define PEEKDATA_CONTAINS_LF ( cell__rxlen <> 0 )
					
        #define SIVDATA_ISEMPTY (cell__gps_siv_data = CELL__EMPTYSTRING)
        #define POSDATA_ISEMPTY (cell__gps_pos_data = CELL__EMPTYSTRING)
        #define FLUSHDATA_BEFORE_GPGSV ( ser.getdata(gps_gpgsv_pos - 1) )
        #define FLUSHDATA_BEFORE_GPGGA ( ser.getdata(gps_gpgga_pos - 1) )
        #define FLUSHDATA ( ser.getdata(cell__rxlen) )
			
		'SIV PROCESSING:
		'FIRST: `PEEKDATA` and check if the string `GPGSV` are found in there
        gps_gpgsv_pos = instr(1, ser.peekdata(CELL__128b_LEN), CELL__GPGSV, 1)
			
		'NEXT: If `GPGSV` was found, `PEEKDATA`and find the postion of `LF`
        if PEEKDATA_CONTAINS_GPGSV then	'match was found for `GPGSV`
			FLUSHDATA_BEFORE_GPGSV	'FLUSH any data before string `$GPGSV`
					
			cell__rxlen = instr(1, ser.peekdata(CELL__128b_LEN), CELL__LF, 1)	'get the complete SIV-data length

			if PEEKDATA_CONTAINS_LF then	'LF was found, which means that SIV-data can be retrieved
				if SIVDATA_ISEMPTY then	'we don't have any SIV-data
					cell__gps_siv_data = ser.getdata(cell__rxlen)	'get SIV-data from rx-buffer
									
					cell__rxlen = 0	'reset value
								
				else	'we already have SIV-data
					FLUSHDATA	'flush DUPLICATE SIV-data
								
				end if
			end if	
        end if
			
		'PROCESS: SIV-DATA (if any)
        if NOT SIVDATA_ISEMPTY then	'currently we DO have SIV-data
			cell__gps_siv_data = cell__get_string_between_2chars(cell__gps_siv_data, 3, CELL__COMMA, CELL__COMMA)	'get the SIV-data which should be between 2 commas at the nth-occurence.
		   
			#if CELL__GPS_MODE_ISENABLED		
				cell__debugprint_gps_phase(PHASE_GPS_SIV, cell__at_cmd, cell__gps_siv_data)	'PRINT
			#endif
					
			cell__gps_siv_data = CELL__EMPTYSTRING	'reset variable (IMPORTANT)
					
			cell__callback_gps_siv()	'CALLBACK
			
		end if


		'POS PROCESSING:
		'FIRST: `PEEKDATA` and check if the string `GPGGA` are found in there
        gps_gpgga_pos = instr(1, ser.peekdata(CELL__128b_LEN), CELL__GPGGA, 1)	'get the complete POS-data length

			'NEXT: If `GPGGA` was found, `PEEKDATA`and find the postion of `LF`
        if PEEKDATA_CONTAINS_GPGGA then	'match was found for `GPGSV`
			FLUSHDATA_BEFORE_GPGGA	'FLUSH any data before string `$GPGGA`
				
			cell__rxlen = instr(1, ser.peekdata(CELL__128b_LEN), CELL__LF, 1)	

			if PEEKDATA_CONTAINS_LF then	'LF was found, which means that POS-data can be retrieved
				if POSDATA_ISEMPTY then	'we don't have any POS-data
					cell__gps_pos_data = ser.getdata(cell__rxlen)	'get POS-data from rx-buffer
									
					cell__rxlen = 0	'reset value
								
				else	'we already have POS-data
					FLUSHDATA	'flush DUPLICATE POS-data
								
				end if
			end if
		else
			FLUSHDATA	'flush NOT useful data
			
        end if

		'PROCESS: POS-DATA (if any)
        if NOT POSDATA_ISEMPTY then	'currently we DO have SIV-data
			cell__gps_get_position(cell__gps_pos_data)	'get GPS-position data (containing Latitude and Longtitude information)
			
			#if CELL__GPS_MODE_ISENABLED
				cell__debugprint_gps_phase(PHASE_GPS_POS, cell__at_cmd, cell__gps_pos_data)	'PRINT
			#endif
					
			cell__gps_pos_data = CELL__EMPTYSTRING	'reset variable (IMPORTANT)

			cell__callback_gps_position()	'CALLBACK
			
        end if
    end sub

    sub cell__gps_get_position(byref inputdata as string)
	
        dim latitude as string	'N or S
        dim longtitude as string 'E or W
        dim tail_len as byte = 9	'tail is 9 bytes long
			
        #define LATITUDE_TAIL ( right(latitude, tail_len ) )
        #define LATITUDE_HEAD ( left(latitude, len(latitude) - tail_len) )
        #define LONGTITUDE_TAIL ( right(longtitude, tail_len ) )
        #define LONGTITUDE_HEAD ( left(longtitude, len(longtitude) - tail_len) )
        #define LATITUDE_DIRECTION ( cell__get_string_between_2chars(inputdata, 3, CELL__COMMA, CELL__COMMA) )	'North or South
        #define LONGTITUDE_DIRECTION ( cell__get_string_between_2chars(inputdata, 5, CELL__COMMA, CELL__COMMA) )	'East or West


		'LATITUDE:
		'	North: positive value
		'	South: negative value
        latitude = cell__get_string_between_2chars(inputdata, 2, CELL__COMMA, CELL__COMMA)	'get GPS laititude coordinate

		'Update GPS latitude as string
		'	can be converted to FLOAT with function `strtof(byref str as string)`
		'	OR, even easier, can be INVOKED IMPLICITELY (see https://docs.tibbo.com/taiko/syscall_strtof#strtof-function)
        cell__gps_latitude = strtof(latitude)
		
        latitude = LATITUDE_HEAD + CELL__SPACE + LATITUDE_TAIL + LATITUDE_DIRECTION	'sample: 25 04.186720 N
		
		'LONGITUDE:
		'	East: positive value
		'	West: negative value
        longtitude = cell__get_string_between_2chars(inputdata, 4, CELL__COMMA, CELL__COMMA)	'get GPS longtitude coordinate

		'Update GPS longtitude as string
		'Note: 
		'	can be converted to FLOAT with function `strtof(byref str as string)`
		'	OR, even easier, can be INVOKED IMPLICITELY (see https://docs.tibbo.com/taiko/syscall_strtof#strtof-function)
        cell__gps_longitude = strtof(longtitude)
		
        longtitude = LONGTITUDE_HEAD + CELL__SPACE + LONGTITUDE_TAIL + LONGTITUDE_DIRECTION 'sample: 121 37.340056 E
		
		'OUTPUT
        if (LATITUDE_HEAD <> CELL__SPACE) AND (LONGTITUDE_HEAD <> CELL__SPACE) then
            inputdata = latitude + ", " + longtitude
		else
            inputdata = "<No Data Available>"
        end if
    end sub
#endif


'***USERMODE / MIXEDMODE SUBROUTINES-----------------------------------------------------
sub cell__at_usermode_cmd_input(byref atcmd as string)

	'Define MACROS
	#define ATCMD_LEN ( len(atcmd) )
	#define CURR_STOR_ARRAY_PAGE ( cell__at_cmd_storArray(cell__at_cmd_storArray_index) )
	#define CURR_STOR_ARRAY_PAGE__USED ( len(CURR_STOR_ARRAY_PAGE) )
	#define CURR_STOR_ARRAY_PAGE__FREE ( CELL__BYTE_SIZE_MAX - CURR_STOR_ARRAY_PAGE__USED )
	#define CURR_STOR_ARRAY_PAGE__CONTAINS_DATA (CURR_STOR_ARRAY_PAGE__USED > 0)
	#define CURR_STOR_ARRAY_PAGE__IS_AVAILABLE ( CURR_STOR_ARRAY_PAGE__FREE > ATCMD_LEN )
	#define INDEX_NOT_EXCEEDED ( cell__at_cmd_storArray_index < ( countof(cell__at_cmd_storArray) - 1) )

	'Loop through `cell__at_cmd_storArray` and add/append AT-commands
	while true
		if CURR_STOR_ARRAY_PAGE__IS_AVAILABLE then	'current array-page is not full yet
			'Add/Append AT-command to STORAGE
			if NOT CURR_STOR_ARRAY_PAGE__CONTAINS_DATA then
				CURR_STOR_ARRAY_PAGE = atcmd	'add AT-command
			else
				CURR_STOR_ARRAY_PAGE = CURR_STOR_ARRAY_PAGE + CELL__RS + atcmd	'append AT-command
			end if				

			'Keep a record of the number of AT-command inputs
			cell__at_cmd_storArray_numof_cmds = cell__at_cmd_storArray_numof_cmds + 1

			'Set next phase to transit to (e.g. PHASE_AT_USERMODE_GET_AND_SEND_CMD)
			cell__update_op_next_phases(PHASE_PWR_DONOT_CHANGE, PHASE_AT_USERMODE_GET_AND_SEND_CMD, 
											PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, 
												PHASE_PARSE_IDLE)

			EXIT WHILE
		else	'current array-page is full
			if INDEX_NOT_EXCEEDED then
				'Go to the next array-index
				cell__at_cmd_storArray_index = cell__at_cmd_storArray_index + 1	'increment index by 1
			 else
				'PRINT
				#if CELL__DEBUGPRINT_AT_ISENABLED
					cell__debugprint_at_phase(PHASE_AT_USERMODE_BUFFER_FULL, CELL__USERMODE, CELL__EMPTYSTRING)
				#endif
	
				'Set next phase to transit to (e.g. PHASE_AT_IDLE)
				cell__update_op_next_phases(PHASE_PWR_DONOT_CHANGE, PHASE_AT_IDLE, 
												PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, 
													PHASE_PARSE_IDLE)


				EXIT WHILE
			end if
		end if 
	wend
end sub

sub cell__at_usermode_get_cmd_fifo()
	'Define variables
	dim rs_pos as byte
	
	'Define MACROS
	#define CURR_STOR_ARRAY_PAGE ( cell__at_cmd_storArray(cell__at_cmd_storArray_index) )
	#define CURR_STOR_ARRAY_PAGE__USED ( len(CURR_STOR_ARRAY_PAGE) )
	#define CURR_STOR_ARRAY_PAGE__CONTAINS_DATA (CURR_STOR_ARRAY_PAGE__USED > 0)
	#define INDEX_NOT_EXCEEDED ( cell__at_cmd_storArray_index < ( countof(cell__at_cmd_storArray) - 1) )

START_HANDLER:
	'Initalize variables
	cell__at_cmd = CELL__EMPTYSTRING
	cell__at_cmd_storArray_index = 0
	
	'Loop through `cell__at_cmd_storArray` and get oldest AT-command
	while true
		if CURR_STOR_ARRAY_PAGE__CONTAINS_DATA then	'current array-page contains data
			'Find the 1st occurrence of the `Record Separator`
			rs_pos = instr(1, CURR_STOR_ARRAY_PAGE, CELL__RS, 1)
			
			'Retrieve the OLDEST AT-command from `cell__at_cmd_stor`
			if rs_pos <> 0 then	'there are multiple records of AT-commands, because `RS` was found
				cell__at_cmd = left( CURR_STOR_ARRAY_PAGE, (rs_pos - 1) )	'get the oldest data (which is on the most left-side)
					
				cell__at_cmd_storArray(cell__at_cmd_storArray_index) = right( CURR_STOR_ARRAY_PAGE, (CURR_STOR_ARRAY_PAGE__USED - rs_pos) )	'strip off the oldest data
			else	'rs_pos = 0 (it means that there is only 1 record)
				cell__at_cmd = CURR_STOR_ARRAY_PAGE	'get the last data on current array-page
						
				cell__at_cmd_storArray(cell__at_cmd_storArray_index) =  CELL__EMPTYSTRING	'update current array-page
			end if				
			
			EXIT WHILE
		else	'current array-page contains no data
			if INDEX_NOT_EXCEEDED then	'goto the next array-page (=index)
				cell__at_cmd_storArray_index = cell__at_cmd_storArray_index + 1	'increment index by 1
					
			else	'all array-pages have been parsed
				'Final check to see if there are any data left
				cell__at_cmd_storArray_index = 0	'reset index
					
				'Loop through `cell__at_cmd_storArray` and get oldest AT-command (if any)
				while true
					if CURR_STOR_ARRAY_PAGE__CONTAINS_DATA then	'current array-page contains data
						goto START_HANDLER	'go to the top of the page
							
						EXIT WHILE
					else	'current array-page contains no data
						if INDEX_NOT_EXCEEDED then
							cell__at_cmd_storArray_index = cell__at_cmd_storArray_index + 1	'increment index by 1
						else
							EXIT WHILE
						end if
					end if
				wend
					
				'Set next phase to transit to: PHASE_AT_IDLE and PHASE_PARSE_IDLE
'					cell__update_op_next_phases(PHASE_PWR_DONOT_CHANGE, PHASE_AT_IDLE, 
'													PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, 
'														PHASE_PARSE_IDLE)

				EXIT WHILE
			end if
		end if 
	wend
end sub

sub cell__at_usermode_go_into_idle(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
									next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
										next_parse_phase as en_cell__op_parse_phases)
'<b>METHODE. </b><br><br>
'Initializes USERMODE-related variables and parameters.
'<b>Input args:</b>
'<ul>
	'<li>next_pwr_phase: <i>next POWER phase</i>
	'<li>next_at_phase: <i>next AT phase</i>
	'<li>next_ppp_phase: <i>next PPP phase</i>
	'<li>next_gps_phase: <i>next GPS phase</i>
	'<li>next_parse_phase: <i>next parse phase</i>
'</ul>

	'Initialize Array and Array-index
	cell__init_at_cmd_storArray()

	'Set next phase to transit to (e.g. PHASE_AT_IDLE, PHASE_PARSE_IDLE)
	cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)	
end sub

#if CELL__AT_USERMODE_ISENABLED
    sub cell__at_notification(next_pwr_phase as en_cell__op_pwr_phases, next_at_phase as en_cell__op_at_phases, 
								next_ppp_phase as en_cell__op_ppp_phases, next_gps_phase as en_cell__op_gps_phases,
									next_parse_phase as en_cell__op_parse_phases)
		
		'PRINT
		#if CELL__DEBUGPRINT_AT_ISENABLED
			cell__debugprint_at_phase(PHASE_AT_FREE_INPUT, CELL__USERMODE, CELL__READY)
		#endif
		
		'Set next phase to transit to (e.g. PHASE_AT_IDLE)
        cell__update_op_next_phases(next_pwr_phase, next_at_phase, next_ppp_phase, next_gps_phase, next_parse_phase)

		'CALLBACK
        cell__callback_at_notification()
		
	end sub
	
	sub cell__at_usermode_sms_send(byref phonenumber as string(CELL__16b_LEN), byref sms_message_total as string, 
										byref csmp_fo as string(CELL__16b_LEN), byref csmp_vp as string(CELL__16b_LEN), 
											byref csmp_pid as string(CELL__16b_LEN), byref csmp_dcs as string(CELL__16b_LEN))
		
		'Define variables
		dim sms_message_tobe_sent as string(CELL__160b_LEN)
		dim sms_message_tobe_sent_lastchar as string(CELL__1b_LEN)
		dim sms_message_tobe_sent_char_after_lastchar as string(CELL__1b_LEN)
		
		'Assign values to global variables
		cell__phonenumber = phonenumber
		cell__csmp_fo = csmp_fo
		cell__csmp_vp = csmp_vp
		cell__csmp_pid = csmp_pid
		cell__csmp_dcs = csmp_dcs


		'Check if `sms_message_total` is an EMPTY STRING?
		if (sms_message_total = CELL__EMPTYSTRING) then
			'PRINT
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_SMS_EMPTY_STRING, CELL__SMS, CELL__EMPTYSTRING)
			#endif
			
			'Set all next-phases to IDLE
			cell__update_op_next_phases(PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, PHASE_GPS_IDLE, PHASE_PARSE_IDLE)
				
			EXIT SUB
		end if

START_HANDLER:
		'FIRSTLY: Get SMS-message length
		dim sms_message_total_len as byte = len(sms_message_total)
		dim sms_message_tobe_sent_len as byte = CELL__128b_LEN
		
		'THEN: Check if the SMS-message length is greater than 160 characters.
		'Note: in the end an SMS-message is still limited to 255 characters, because a string is 255 bytes.
		if (sms_message_total_len > CELL__160b_LEN) then
			'This part takes care of the overexceeded SMS-message... 
			'... by cutting this overexceeded message into chunks (at the right place)...
			'... and then sending those chunks via multiple SMS connections.
		
			'How does this work?
			
			'Loop until a SPACE followed by a character is found
			while true
				'Get the character at position `sms_message_tobe_sent_len`
				sms_message_tobe_sent_lastchar = mid(sms_message_total, sms_message_tobe_sent_len, CELL__1b_LEN)

				'Check if the `sms_message_tobe_sent_lastchar` is a SPACE
				'If that's the case, then an acceptable SMS-length has been found
				if (sms_message_tobe_sent_lastchar = CELL__SPACE) then	'sms_message_tobe_sent_lastchar is a SPACE
					'Check if the `sms_message_tobe_sent_len` has reached the maximum allowed 160 bytes
					if (sms_message_tobe_sent_len = CELL__160b_LEN) then	'maximum has been reached
						'Get the SMS-message which is 160 bytes in length
						sms_message_tobe_sent = left(sms_message_total, sms_message_tobe_sent_len)
					
						EXIT WHILE
					else	'maximum not reached yet, continue...
						'INCREMENT
						sms_message_tobe_sent_len = sms_message_tobe_sent_len + 1
						
						'Get the character at position `sms_message_tobe_sent_len + 1`
						sms_message_tobe_sent_char_after_lastchar = mid(sms_message_total, sms_message_tobe_sent_len, CELL__1b_LEN)
					
						'Check if the `sms_message_tobe_sent_char_after_lastchar` is a SPACE
						if (sms_message_tobe_sent_char_after_lastchar <> CELL__SPACE) then	'sms_message_tobe_sent_char_after_lastchar is NOT a SPACE
							'Important: go back one byte
							sms_message_tobe_sent_len = sms_message_tobe_sent_len - 1
						
							'Get SMS-message which is `sms_message_tobe_sent_len` in length
							sms_message_tobe_sent = left(sms_message_total, sms_message_tobe_sent_len)	
							
							EXIT WHILE
						else	'sms_message_tobe_sent_char_after_lastchar is a SPACE
							'Check if the `sms_message_tobe_sent_len` has reached the maximum allowed 160 bytes
							if (sms_message_tobe_sent_len = CELL__160b_LEN) then	'maximum has been reached
								'Get the SMS-message which is 160 bytes in length
								sms_message_tobe_sent = left(sms_message_total, sms_message_tobe_sent_len)
							
								EXIT WHILE
							end if	'maximum not reached yet, continue...
						end if
					end if
				else	'sms_message_tobe_sent_lastchar is NOT a SPACE
					if (sms_message_tobe_sent_len = CELL__160b_LEN) then	'SMS-message length can NOT exceed 160 bytes
						'Get SMS-message which is 160 bytes in length
						sms_message_tobe_sent = left(sms_message_total, sms_message_tobe_sent_len)
					
						EXIT WHILE
					end if
				end if

				'Goto the next byte
				sms_message_tobe_sent_len = sms_message_tobe_sent_len + 1	
			wend
			
		else	'ORIGINAL SMS-message does NOT exceed the maximum allowed 160 bytes (therefore no need to cut the SMS-message in chunks)
			sms_message_tobe_sent = sms_message_total	'set value
			
			sms_message_tobe_sent_len = sms_message_total_len	'set length
		end if


		'SECONDLY: mandatory AT-commands to check the Network
		cell__at_usermode_cmd_input(CELL__AT)
		cell__at_usermode_cmd_input(CELL__ATE1)
		cell__at_usermode_cmd_input(CELL__AT_CPIN_Q)
		cell__at_usermode_cmd_input(CELL__AT_COPS_Q)
'		cell__at_usermode_cmd_input(CELL__AT_CGREG_Q)
		
		'THIRDLY: prepare and send SMS-message
		cell__at_usermode_cmd_input(CELL__AT_CMGF)	'set SMS-system into text-mode (IMPORTANT)
		cell__at_usermode_cmd_input(CELL__AT_CSMP)	'set text-mode parameters
		cell__at_usermode_cmd_input(CELL__AT_CSCS)	'select TE characters
		cell__at_usermode_cmd_input(CELL__AT_CMGS)	'set & call to destination phonenumber
		cell__at_usermode_cmd_input(sms_message_tobe_sent)	'send SMS-message
		cell__at_usermode_cmd_input(CELL__SUBSTITUTE)	'close call by sending a SUBSTITUTE character chr(26)


		'LASTLY: double-check if there are any `sms_message_total`s left (excluding `sms_message_tobe_sent`)
		sms_message_total = right(sms_message_total, len(sms_message_total) - sms_message_tobe_sent_len)
		
		'If the newly defined `sms_message_total` contains data then go back to `START_HANDLER`
		if (sms_message_total <> CELL__EMPTYSTRING) then
			GOTO START_HANDLER
		end if
	end sub

	sub cell__at_usermode_sms_receive(byref cpms_mem1_stor_type as string(CELL__2b_LEN), 
										byref cpms_mem2_stor_type as string(CELL__2b_LEN),
											byref cpms_mem3_stor_type as string(CELL__2b_LEN),
												byref cnmi_mode as string(CELL__1b_LEN),
													byref cnmi_mt as string(CELL__1b_LEN))
		'Assign values to global variables
		cell__cpms_mem1_stor_type = cpms_mem1_stor_type
		cell__cpms_mem2_stor_type = cpms_mem2_stor_type
		cell__cpms_mem3_stor_type = cpms_mem3_stor_type
		cell__cnmi_mode = cnmi_mode
		cell__cnmi_mt = cnmi_mt

		'Mandatory AT-commands to check the Network
		cell__at_usermode_cmd_input(CELL__AT)
		cell__at_usermode_cmd_input(CELL__ATE1)
		cell__at_usermode_cmd_input(CELL__AT_CPIN_Q)
		cell__at_usermode_cmd_input(CELL__AT_COPS_Q)
		cell__at_usermode_cmd_input(CELL__AT_CGREG_Q)
		

		'Setup SMS for message receival
		cell__at_usermode_cmd_input(CELL__AT_CMGF)	'set SMS-system to text-mode
		cell__at_usermode_cmd_input(CELL__AT_CPMS)	'Set the Message Storage
		cell__at_usermode_cmd_input(CELL__AT_CNMI)	'Set new message indications to TE
	end sub

	sub cell__at_usermode_sms_parse()
		'Define MACROS
		#define AT_REPLIED_WITH_CMTI ( instr(1, ser.peekdata(255), CELL__CMTI, 1) <> 0 )
		#define AT_REPLIED_WITH_SMS_FULL ( instr(1, ser.peekdata(255), CELL__SMS_FULL, 1) <> 0 )

		'Check if SMS-message has been received
		if (AT_REPLIED_WITH_CMTI) then	'match was found
			'Get the AT-reply containing the last index of the received SMS-message
			'REMARK: ALL DATA (255 bytes in length) in the serial-port will be retrieved
			cell__at_get_cleandata_filter(255)
		
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_SMS_RCV, CELL__SMS, CELL__EMPTYSTRING)	'PRINT
			#endif
			
			cell__callback_at_usermode_sms_rcv_notif()	'CALLBACK
		else if (AT_REPLIED_WITH_SMS_FULL) then
			'Get the AT-reply containing the text `+SMS FULL` only
			'REMARK: ALL DATA (255 bytes in length) in the serial-port will be retrieved
			cell__at_get_cleandata_filter(255)
			
			#if CELL__DEBUGPRINT_AT_ISENABLED
				cell__debugprint_at_phase(PHASE_SMS_FULL, CELL__SMS, CELL__EMPTYSTRING)	'PRINT
			#endif
			
			cell__callback_at_usermode_sms_storage_full_notif()	'CALLBACK		
		end if
	end sub

#endif



'PROC_SYS_TIMER SUBROUTINES------------------------------------------
sub cell__proc_sys_timer()
	if cell__init_flag<>CELL_INIT_SIGNATURE then
		exit sub
	end if
	'Set the serial-port number
    ser.num = CELL__DATA_SER_PORT
	
	'Only continue here if there is NO PARSING ongoing
    if (cell__op_parse_phase = PHASE_PARSE_IDLE) then
        if (cell__op_pwr_phase <> PHASE_PWR_IDLE) then
            cell__pwr_proc_sys_timer()
			
			EXIT SUB
        end if
		
        if (cell__op_at_phase <> PHASE_AT_IDLE) then
            cell__at_proc_sys_timer()
			
			EXIT SUB
        end if
		
        #if CELL__PPP_MODE_ISENABLED
            if (cell__op_ppp_phase <> PHASE_PPP_IDLE) then
                cell__ppp_proc_sys_timer()
			
				EXIT SUB
			end if
        #endif

        #if CELL__GPS_MODE_ISENABLED
            if (cell__op_gps_phase <> PHASE_GPS_IDLE) then
                cell__gps_proc_sys_timer()
			
				EXIT SUB
			end if
        #endif
		
		'Check if there are any Retries in Progress
		cell__isretry_inprogr_in_idlemode()
		
	else
		'***IMPORTANT: reset parameter
		cell__isretry_inprogr_in_idlemode_retry_param = 0
	
		'Only for 
		#if CELL__GPS_MODE_ISENABLED=0
			'cell__op_parse_phase is set to PHASE_PARSE_xxx_MESSAGE,...
			'... however on Serial Data Arrival is Not Triggered,...
			'... which causes the modem to be in an infinite loop.
			cell__on_ser_data_arriv_not_trigg()
		#endif
		
    end if
end sub 
sub cell__isretry_inprogr_in_idlemode()
	'Calculate the elapsed time
	'REMARK: in this case `cell__starttime`, which was initiated in subroutine `cell__at_cmd_exec`, is used.
	cell__isretry_newtime  = sys.timercount	'update new timercounter
	cell__isretry_elapsedtime = cell__calc_timediff_16b(cell__isretry_starttime , cell__isretry_newtime)	'calculate the elapsed time
	
	'At this stage ALL Phases are set to IDLE.
	'However, is modem really in IDLE-mode, or are there any ongoing retries?
	'If true, then Modem is Frozen and needs to be Restarted.
	if (cell__isretry_elapsedtime > CELL__ISRETRY_INPROGR_IN_IDLEMODE_RETRY_TIMEOUT_MIN) then	'wait for at least a specified number of seconds
		if ( cell__retry_in_progress() = true ) then	'at least one retry-process is in progress
			if (cell__isretry_inprogr_in_idlemode_retry_param < CELL__ISRETRY_INPROGR_IN_IDLEMODE_RETRY_MAX) then
				cell__isretry_starttime  = sys.timercount	'reset start timecounter
			
				cell__isretry_inprogr_in_idlemode_retry_param = cell__isretry_inprogr_in_idlemode_retry_param + 1
				
				cell__debugprint_at_phase(PHASE_AT_ISRETRY_IN_PROGRESS_IN_IDLE_MODE, cell__at_cmd, CELL__EMPTYSTRING)
			else
				cell__debugprint_at_phase(PHASE_AT_ISRETRY_IN_PROGRESS_IN_IDLE_MODE_EXCEEDED, cell__at_cmd, CELL__EMPTYSTRING)

				cell__at_parse_message_retry(cell__op_pwr_phase, cell__op_at_phase, cell__op_ppp_phase, cell__op_gps_phase, PHASE_PARSE_IDLE)
'				cell__modem_restart(PHASE_PWR_PWRKEY_ON)	'initiate a modem-restart
			end if
		end if
	end if
end sub

function cell__retry_in_progress() as boolean
	'INITIAL value
	cell__retry_in_progress = false
	

	'PWRKEY retry
	if ( (cell__pwrkey_retry_param > 0) AND (cell__pwrkey_retry_param < CELL__POWER_ONOFF_RETRY_MAX) ) then
		cell__retry_in_progress = true
	end if
	
	'RESET retry
	if ( (cell__reset_retry_param > 0) AND (cell__reset_retry_param < CELL__RESET_RETRY_MAX) ) then
		cell__retry_in_progress = true
	end if
	
	'SHDN retry
	if ( (cell__shdn_retry_param > 0) AND (cell__shdn_retry_param < CELL__SHDN_RETRY_MAX) ) then
		cell__retry_in_progress = true
	end if
	
	'AT retry
	#if CELL__AT_USERMODE_ISENABLED	
		if (cell__sms_msg_inputmode_isOn = true) then
			if ( (cell__at_retry_param > 0) AND (cell__at_retry_param < CELL__SMS_RETRY_MAX) ) then
				cell__retry_in_progress = true
			end if
		else
			if ( (cell__at_retry_param > 0) AND (cell__at_retry_param < CELL__AT_RETRY_MAX) ) then
				cell__retry_in_progress = true
			end if
		end if
	#else
		if ( (cell__at_retry_param > 0) AND (cell__at_retry_param < CELL__AT_RETRY_MAX) ) then
			cell__retry_in_progress = true
		end if
	#endif
	
	'EXEC AT-CMD retry
	if ( (cell__at_cmd_exec_retry_param > 0) AND (cell__at_cmd_exec_retry_param < CELL__AT_CMD_EXEC_RETRY_MAX) ) then
		cell__retry_in_progress = true
	end if
	
	'MODEM RESTART retry
	if ( (cell__modem_restart_retry_param > 0) AND (cell__modem_restart_retry_param < CELL__MODEM_RESTART_RETRY_MAX) ) then
		cell__retry_in_progress = true
	end if
end function
function cell__all_phases_are_idle() as boolean
	'INITIAL value
	cell__all_phases_are_idle = true

	if (cell__op_pwr_phase <> PHASE_PWR_IDLE) then
		cell__all_phases_are_idle = false
	end if
	if (cell__op_at_phase <> PHASE_AT_IDLE) then
		cell__all_phases_are_idle = false
	end if
	if (cell__op_ppp_phase <> PHASE_PPP_IDLE) then
		cell__all_phases_are_idle = false
	end if
	if (cell__op_gps_phase <> PHASE_GPS_IDLE) then
		cell__all_phases_are_idle = false
	end if
	if (cell__op_parse_phase <> PHASE_PARSE_IDLE) then
		cell__all_phases_are_idle = false
	end if
end function

sub cell__on_ser_data_arriv_not_trigg()
	'Calculate the elapsed time
	'REMARK: in this case `cell__starttime`, which was initiated in subroutine `cell__at_cmd_exec`, is used
	cell__on_ser_data_newtime  = sys.timercount	'update new timercounter
	cell__on_ser_data_elapsedtime = cell__calc_timediff_16b(cell__on_ser_data_starttime , cell__on_ser_data_newtime)	'calculate the elapsed time
	
	'cell__op_parse_phase is set to a PARSE-mode (e.g. PHASE_PARSE_AT_MESSAGE)
	'However, subroutine `on_ser_data_arriv` is NOT triggered
	'Wait for a minimum of time and restart modem
	if (cell__on_ser_data_elapsedtime > CELL__ON_SER_DATA_ARRIV_NOT_TRIGG_RETRY_TIMOUT_MIN) then	'wait for at least a specified number of seconds
		if (cell__on_ser_data_arriv_not_trigg_retry_param < CELL__ON_SER_DATA_ARRIV_NOT_TRIGG_RETRY_MAX) then
			cell__on_ser_data_starttime  = sys.timercount	'reset start timecounter
		
			cell__on_ser_data_arriv_not_trigg_retry_param = cell__on_ser_data_arriv_not_trigg_retry_param + 1
			
			'PRINT (except when GPS is enabled)
			cell__debugprint_at_phase(PHASE_AT_ON_SER_DATA_ARRIV_NOT_TRIGG, cell__at_cmd, CELL__EMPTYSTRING)
		else
			cell__debugprint_at_phase(PHASE_AT_ON_SER_DATA_ARRIV_NOT_TRIGG_EXCEEDED, cell__at_cmd, CELL__EMPTYSTRING)
		
			cell__modem_restart(PHASE_PWR_PWRKEY_ON)	'initiate a modem-restart
		end if
	end if
end sub

sub cell__pwr_proc_sys_timer()

    select case cell__op_pwr_phase
		case PHASE_PWR_MODEM_RESTART_RETRY:
			cell__start(cell__pin, cell__apn, cell__username, cell__password)	'restart and initialize modem						
			
        case PHASE_PWR_RESET_ON:
			cell__reset_on(PHASE_PWR_RESET_WAIT, 
							PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)

        case PHASE_PWR_RESET_WAIT:
			cell__reset_wait(PHASE_PWR_RESET_OFF, 
								PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)

        case PHASE_PWR_RESET_OFF:
			cell__reset_off(PHASE_PWR_PWRKEY_ON, PHASE_PWR_POWERING_ONOFF,
								PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)

        case PHASE_PWR_SHDN_OFF:
			cell__shdn_off(PHASE_PWR_SHDN_WAIT, 
							PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)
			
        case PHASE_PWR_SHDN_WAIT:
			cell__shdn_wait(PHASE_PWR_SHDN_ON, 
								PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)
			
        case PHASE_PWR_SHDN_ON:
			cell__shdn_on(PHASE_PWR_PWRKEY_ON, PHASE_PWR_MODEM_ONOFF, 
							PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)
       
		case PHASE_PWR_PWRKEY_ON:
			cell__pwrkey_on(PHASE_PWR_PWRKEY_OFF, 
								PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)

        case PHASE_PWR_PWRKEY_OFF:
			cell__pwrkey_off(PHASE_PWR_POWERING_ONOFF, 
								PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)
			
        case PHASE_PWR_POWERING_ONOFF:
			cell__powering_onoff(PHASE_PWR_POWERING_ONOFF_WAIT, 
									PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)

        case PHASE_PWR_POWERING_ONOFF_WAIT:
			cell__powering_onoff_wait(PHASE_PWR_SERPORT_CHK_RDY_STATE, PHASE_PWR_MODEM_ONOFF,
										PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)
						
        case PHASE_PWR_SERPORT_CHK_RDY_STATE:
			cell__check_rdy_state(PHASE_PWR_MODEM_ONOFF, 
									PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)

        case PHASE_PWR_MODEM_ONOFF:
			'The serial-port is checked whether it is RDY or NOT-RDY during the `PHASE_PWR_SERPORT_CHK_RDY_STATE`.
			'Option 1: serial-port is RDY
			'Option 1.1: bandtype = `1` or `3`, then go to phase `PHASE_AT_AT`.
			'Option 1.2: bandtype = `2`, then go to phase `PHASE_AT_INIT` (force to go to this phase).
			'Option 2: serial-port is NOT RDY, then go to phase `PHASE_AT_INIT`.
			if (cell__ser_port_isRdy = true) then	'serial-port is RDY
'				if (cell__bandtype = 2 ) then	'2: NB-IoT
'					cell__op_at_phase = PHASE_AT_INIT
'				else	'1: CATM1, 3: CATM1 and NB-IoT
					cell__op_at_phase = PHASE_AT_AT
'				end if
			else	'serial-port is NOT RDY
				cell__op_at_phase = PHASE_AT_INIT
			end if

			cell__modem_onoff(PHASE_PWR_IDLE, cell__op_at_phase, 
								PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_DONOT_CHANGE)

    end select
end sub

sub cell__at_proc_sys_timer()

    select case cell__op_at_phase
'---ALL-MODE
        case PHASE_AT_INIT:
			cell__at_send_multiple_commands_without_timeout(CELL__AT, CELL__NUMOF_TIMES_TO_SEND_ATCMD,
																PHASE_PWR_DONOT_CHANGE, PHASE_AT_AT, 
																	PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
																		PHASE_PARSE_DONOT_CHANGE)
        case PHASE_AT_AT:
			cell__at_cmd_exec(CELL__AT, 
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_AMPERSAND_E1, 
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)


		case PHASE_AT_AMPERSAND_E1:
			cell__at_cmd_exec(CELL__AT_AMPERSAND_E1,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGMM,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
										
		case PHASE_AT_CGMM:
			cell__at_cmd_exec(CELL__AT_CGMM, 
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CBC, 
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
										
        case PHASE_AT_CBC:
			#if CELL__PPP_MODE_ISENABLED
				if CELL__SIM_MODEL_IS_7000 then
					cell__op_at_phase = PHASE_AT_AMPERSAND_C0
				else
					cell__op_at_phase = PHASE_AT_CNMP
				end if	
            #else 
				#if CELL__AT_USERMODE_ISENABLED
					cell__op_at_phase = PHASE_AT_NOTIFICATION
                #else	'CELL__GPS_MODE_ISENABLED
					cell__op_gps_phase = PHASE_GPS_CGPSNMEA
					cell__op_at_phase = PHASE_AT_IDLE
				#endif
			#endif
				
			cell__at_cmd_exec(CELL__AT_CBC, 
								PHASE_PWR_DONOT_CHANGE, cell__op_at_phase, 
									PHASE_PPP_DONOT_CHANGE, cell__op_gps_phase,
										PHASE_PARSE_AT_MESSAGE)
										
		
		case PHASE_AT_AMPERSAND_C0:	'only for SIM7000 (this command is added to fix the PPP-disconnection issue)
			cell__at_cmd_exec(CELL__AT_AMPERSAND_C0,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CPSMS_0,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

										
		case PHASE_AT_CPSMS_0:	'only for SIM7000 (this command is added to fix the PPP-disconnection issue)
			cell__at_cmd_exec(CELL__AT_CPSMS_0,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_AMPERSAND_D0,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)


		case PHASE_AT_AMPERSAND_D0:	'only for SIM7000 (this command is added to fix the PPP-disconnection issue)
			cell__at_cmd_exec(CELL__AT_AMPERSAND_D0,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CMNB,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

		
		case PHASE_AT_CMNB:	'only for SIM7000
			cell__at_cmd_exec(CELL__AT_CMNB,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CNMP,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)


'---PPP-MODE
#if CELL__PPP_MODE_ISENABLED
	
		case PHASE_AT_CNMP:
			cell__at_cmd_exec(CELL__AT_CNMP, 
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_ATE1,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)	

		case PHASE_AT_ATE1:
			cell__at_cmd_exec(CELL__ATE1,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_IPR,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)	
			
		case PHASE_AT_IPR:
			cell__at_cmd_exec(CELL__AT_IPR,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_IFC,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
			
		case PHASE_AT_IFC:
			cell__at_ifc(PHASE_PWR_DONOT_CHANGE, PHASE_AT_CMEE,
							PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
								PHASE_PARSE_AT_MESSAGE)

		case PHASE_AT_CMEE:
			
			
			cell__at_cmd_exec(CELL__AT_CMEE,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CPIN_CHECK,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
											
		case PHASE_AT_CPIN_CHECK:
			cell__at_cmd_exec(CELL__AT_CPIN_Q,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_COPS,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

		case PHASE_AT_CPIN:
			cell__at_cmd_exec(CELL__AT_CPIN,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_COPS,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

'			case PHASE_AT_CFUN:
'				cell__at_cmd_exec(CELL__AT_CFUN,
'									PHASE_PWR_DONOT_CHANGE, PHASE_AT_COPS,
'										PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
'											PHASE_PARSE_AT_MESSAGE)
							
			
		case PHASE_AT_COPS:
			cell__at_cmd_exec(CELL__AT_COPS_Q,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGDCONT,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
														
		case PHASE_AT_CGDCONT:
'				if CELL__SIM_MODEL_IS_7000 then
'					cell__op_at_phase = PHASE_AT_CSTT
'				else
'					cell__op_at_phase = PHASE_AT_CGREG
'				end if	
			
			cell__at_cmd_exec(CELL__AT_CGDCONT,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGREG,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

'            case PHASE_AT_CSTT:			'only for SIM7000
'				if CELL__SIM_MODEL_IS_7000 then
'					cell__at_cmd_exec(CELL__AT_CSTT,
'										PHASE_PWR_DONOT_CHANGE, PHASE_AT_CIICR,
'											PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
'												PHASE_PARSE_AT_MESSAGE)
'				end if
										
'            case PHASE_AT_CIICR:		'only for SIM7000
'				if CELL__SIM_MODEL_IS_7000 then
'					cell__at_cmd_exec(CELL__AT_CIICR,
'										PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGREG,
'											PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
'												PHASE_PARSE_AT_MESSAGE)
'				end if
			
		case PHASE_AT_CGREG:
			cell__at_cgreg_dblchk_isEnabled = true
		
			cell__at_cmd_exec(CELL__AT_CGREG_Q,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGATT,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
		
		case PHASE_AT_CGATT:
			if CELL__SIM_MODEL_IS_7000 then
				cell__op_at_phase = PHASE_AT_CGACT
			else
				cell__op_at_phase = PHASE_AT_CGPADDR
			end if	

			cell__at_cmd_exec(CELL__AT_CGATT,
								PHASE_PWR_DONOT_CHANGE, cell__op_at_phase,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

		case PHASE_AT_CGACT:	'only for SIM7000
			if CELL__SIM_MODEL_IS_7000 then
				cell__at_cmd_exec(CELL__AT_CGACT,
									PHASE_PWR_DONOT_CHANGE, PHASE_AT_CPSI,
										PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
											PHASE_PARSE_AT_MESSAGE)
			end if

		case PHASE_AT_CPSI: 	'only for SIM7000
			if CELL__SIM_MODEL_IS_7000 then
				cell__at_cmd_exec(CELL__AT_CPSI,
									PHASE_PWR_DONOT_CHANGE, PHASE_AT_CSQ,
										PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
											PHASE_PARSE_AT_MESSAGE)	
			end if
			
		case PHASE_AT_CSQ: 		'only for SIM7000
			if CELL__SIM_MODEL_IS_7000 then
				cell__at_cmd_exec(CELL__AT_CSQ,
							PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGPADDR,
								PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
									PHASE_PARSE_AT_MESSAGE)
			end if
	
		case PHASE_AT_CGPADDR:
			cell__at_cmd_exec(CELL__AT_CGPADDR,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGREG_DBLCHK,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

		case PHASE_AT_CGREG_DBLCHK:
			cell__at_cmd_exec(CELL__AT_CGREG_Q,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_CGDATA,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)			

		case PHASE_AT_CGDATA:
			'NOTE: You cannot use one serial-port for PPP and GPS at the same time!!!
			cell__at_cmd_exec(CELL__AT_CGDATA,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_IDLE,
									PHASE_PPP_LCP_NEGOTIATION,
										PHASE_GPS_DONOT_CHANGE,
											PHASE_PARSE_AT_MESSAGE)
#endif

'---AT USER-MODE
#if CELL__AT_USERMODE_ISENABLED
		case PHASE_AT_NOTIFICATION:
			cell__at_notification(PHASE_PWR_DONOT_CHANGE, PHASE_AT_USERMODE_CMD_INPUT, 
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE, 
										PHASE_PARSE_IDLE)

		case PHASE_AT_USERMODE_CMD_INPUT:
			cell__callback_at_usermode_cmd_input()
#endif

'---AT USER-MODE & MIXED-MODE

		case PHASE_AT_USERMODE_GET_AND_SEND_CMD:
			cell__at_usermode_get_cmd_fifo()	'get the oldest AT-command first (FIFO methodology)
				
			if cell__at_cmd <> CELL__EMPTYSTRING then	'fifo-buffer is NOT empty
				cell__at_cmd_exec(cell__at_cmd,
									PHASE_PWR_DONOT_CHANGE, PHASE_AT_USERMODE_GET_AND_SEND_CMD,
										PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
											PHASE_PARSE_AT_MESSAGE)							

			else	'fifo-buffer is EMPTY
				'IMPORTANT for SMS: Change to next-phase accordingly
				cell__at_usermode_go_into_idle(PHASE_PWR_DONOT_CHANGE, PHASE_AT_IDLE,
												PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
													PHASE_PARSE_DONOT_CHANGE)		
			end if
			
		case PHASE_AT_USERMODE_RETRY:
			'We would enter this phase IF an error has occured when trying to send the `AT+CREQ?` command
			'In this case, just RESEND the same command as in phase `PHASE_AT_USERMODE_GET_AND_SEND_CMD`
			cell__at_cmd_exec(cell__at_cmd,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_USERMODE_GET_AND_SEND_CMD,
									PHASE_PPP_DONOT_CHANGE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)

'---ALL-MODE
		case PHASE_AT_SWITCH_FROM_DATA_TO_CMD_MODE:
			'This PHASE is used to switch from the Data-mode or PPP-mode to back to the Command-mode
			'REMARK:
			'1. When in Data-mode, no special actions are needed to be taken
			'2. *IMPORTANT*: When in PPP-mode, make sure to set `ppp.enabled=NO`
			cell__at_cmd_exec(CELL__TRIPLEPLUS,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_IDLE,
									PHASE_PPP_IDLE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
										
		case PHASE_AT_SWITCH_FROM_CMD_TO_DATA_MODE: 
			cell__at_cmd_exec(CELL__ATO,
								PHASE_PWR_DONOT_CHANGE, PHASE_AT_IDLE,
									PHASE_PPP_IDLE, PHASE_GPS_DONOT_CHANGE,
										PHASE_PARSE_AT_MESSAGE)
																	
		case PHASE_AT_IDLE:
			'DO NOTHING
		
			
    end select

end sub

sub cell__ppp_proc_sys_timer()
    #if CELL__PPP_MODE_ISENABLED
        select case cell__op_ppp_phase
            case PHASE_PPP_LCP_NEGOTIATION:
				cell__ppp_send_data(CELL__PPP_PROTO_LCP, PPP_CONFREQ, cell__ppp_sender_id, CELL__PPP_LCP_CONFREQ_DATA_STR,
										PHASE_PWR_DONOT_CHANGE, PHASE_AT_DONOT_CHANGE, 
											PHASE_PPP_DETERMINED_BY_SYSTEM, 
												PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_PPP_MESSAGE)

            case PHASE_PPP_PAP_NEGOTIATION:
				cell__ppp_send_data(CELL__PPP_PROTO_PAP, PPP_CONFREQ,  cell__ppp_sender_id, cell__pap_credentials,
										PHASE_PWR_DONOT_CHANGE, PHASE_AT_DONOT_CHANGE, 
											PHASE_PPP_IPCP_NEGOTIATION, 
												PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_PPP_MESSAGE)

            case PHASE_PPP_IPCP_NEGOTIATION:
				cell__ppp_ipcp_send_confreq(CELL__PPP_PROTO_IPCP, PPP_CONFREQ, cell__ppp_sender_id, CELL__PPP_IPCP_CONFREQ_DATA_STR,
												PHASE_PWR_DONOT_CHANGE, PHASE_AT_DONOT_CHANGE, 
													PHASE_PPP_PING, 
														PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_PPP_MESSAGE)
														
            case PHASE_PPP_PING:
				cell__ppp_ping_send(CELL__PPP_PROTO_IP, CELL__ICMP_CODE, CELL__ICMP_SENDER_ID, CELL__ICMP_MESSAGE_FORMAT_STR,
										PHASE_PWR_DONOT_CHANGE, PHASE_AT_DONOT_CHANGE, 
											PHASE_PPP_IPCP_CONNECT, 
												PHASE_GPS_DONOT_CHANGE, PHASE_PARSE_PPP_MESSAGE)
												
            case PHASE_PPP_IPCP_CONNECT:
				cell__ppp_link_to_tower()
				
				
			case PHASE_PPP_IDLE:
				'DO NOTHING
			
			
        end select
    #endif
end sub

sub cell__gps_proc_sys_timer()
    #if CELL__GPS_MODE_ISENABLED
        select case cell__op_gps_phase	
            case PHASE_GPS_CGPSNMEA:
				cell__at_cmd_exec(CELL__AT_CGPSNMEA,
									PHASE_PWR_DONOT_CHANGE, PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, 
										PHASE_GPS_CGPSHOR, PHASE_PARSE_AT_MESSAGE)							
					
            case PHASE_GPS_CGPSHOR:
				cell__at_cmd_exec(CELL__AT_CGPSHOR, 
									PHASE_PWR_DONOT_CHANGE, PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, 
										PHASE_GPS_CGPS_ENABLE, PHASE_PARSE_AT_MESSAGE)
					
            case PHASE_GPS_CGPS_ENABLE:
				cell__at_cmd_exec(CELL__AT_CGPS_ENABLE, 
									PHASE_PWR_DONOT_CHANGE, PHASE_AT_DONOT_CHANGE, PHASE_PPP_DONOT_CHANGE, 
										PHASE_GPS_CGPSINFOCFG_START, PHASE_PARSE_AT_MESSAGE)
					
            case PHASE_GPS_CGPSINFOCFG_START:
				cell__at_cmd_exec(CELL__AT_CGPSINFOCFG_START, PHASE_PWR_IDLE, PHASE_AT_IDLE, PHASE_PPP_IDLE, 
									PHASE_GPS_IDLE, PHASE_PARSE_GPS_MESSAGE)
				
        end select
    #endif
end sub

sub cell__proc_on_ser_data_arrival()

	if cell__init_flag<>CELL_INIT_SIGNATURE then
		exit sub
	end if
	'FIRST:	check if it's the correct serial-port number
    if NOT CELL__SER_PORT_NUM_IS_CORRECT then
        EXIT SUB
    end if

	''***IMPORTANT: reset parameter
	cell__on_ser_data_arriv_not_trigg_retry_param = 0

	'THEN:	once the serial-port number has been confirmed, parse the received messages
    select case cell__op_parse_phase
        case PHASE_PARSE_AT_MESSAGE:
			cell__at_parse_message(cell__op_pwr_phase, cell__op_at_phase, cell__op_ppp_phase, cell__op_gps_phase, cell__op_parse_phase)
				
			#if CELL__PPP_MODE_ISENABLED
				if CELL__AT_CMD_CONTAINS_CGPADDR then
					cell__ppp_at_cgpaddr_retrieve_ip()
				end if
			#endif
			
        case PHASE_PARSE_PPP_MESSAGE:
			#if CELL__PPP_MODE_ISENABLED
				cell__ppp_parse_message(cell__op_pwr_phase, cell__op_at_phase, cell__op_ppp_phase, cell__op_gps_phase, cell__op_parse_phase)
			#endif
			
        case PHASE_PARSE_GPS_MESSAGE:
			#if CELL__GPS_MODE_ISENABLED
				cell__gps_parse_message()
			#endif
		
		case PHASE_PARSE_SMS_MESSAGE:
			#if CELL__AT_USERMODE_ISENABLED
				cell__at_usermode_sms_parse()
			#endif
		
        case else:
			
    end select
end sub
